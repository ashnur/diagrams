(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
void function(){
  var viral = require('viral')
  var enslave = require('enslave')

  function size(arr){
    return arr.values.length
  }

  function clone(arr){
    return Arr.make(arr)
  }

  function forEach(set, fn){
    set.values.forEach(fn)
  }

  function reduce(set, fn, init){
    if ( init !== undefined ) {
      return set.values.reduce(fn, init)
    } else {
      return set.values.reduce(fn)
    }
  }

  function map(set, fn){
    return set.values.map(fn)
  }

  function some(set, fn){
    return set.values.some(fn)
  }

  function indexOf(set, value){
    return set.values.indexOf(value)
  }

  var Arr = viral.extend({
    init: function(arr){
      this.values = arr != null ? arr.values.slice(0) : []
    }
  , forEach: enslave(forEach)
  , reduce: enslave(reduce)
  , map: enslave(map)
  , some: enslave(some)
  , size: enslave(size)
  , clone: enslave(clone)
  , indexOf: enslave(indexOf)
  })

  module.exports = Arr

}()

},{"enslave":57,"viral":66}],2:[function(require,module,exports){
void function(){
  var Snap = require('snapsvg')
  var viral = require('viral')
  var enslave = require('enslave')
  var dagre = require('dagre')
  var events = require('events')
  var hglue = require('hyperglue')
  var defaults = require('../util/defaults.js')
  var uid = require('../util/unique_id.js')
  var dom = require('../util/dom.js')
  var intersect = require('./intersect.js')
  var floor = Math.floor
  var ceil = Math.ceil
  var min = Math.min
  var max = Math.max

  var Item = require('./item.js')
  var print = console.log.bind(console)

  function from_defs(diagram, classname){
    return diagram.svgel.parent().select('defs .' + classname)
  }

  function to_defs(diagram, svg){
    var p = diagram.svgel.parent()
    if ( typeof svg == 'string' ) {
      var el = Snap.parse(svg).select('*')
    } else if ( Array.isArray(svg) ) {
      var el = p.el.apply(p.el, svg)
    } else {
      // TODO: replace this
      print('not sure how to handle')
    }
    return p.select('defs').append(el)
  }

  function draw(diagram, el){
    var new_el = from_defs(diagram, el.classname).clone()
    var node = hglue(new_el.node, el.content)
    diagram.svgel.append(new_el)
    return new_el
  }

  function set_line_attrs(item, line_height, x){
    item.g.selectAll('tspan').forEach(function(tspan, idx){
      tspan.attr({ dy: idx ? line_height : 0 , x: x })
    })
  }

  function pos_calc(x,w,y,h){
    return [x + w / 2, y + h / 2]
  }

  function get_textwidth(node){
    return node.getComputedTextLength()
  }

  function inviz_bbox(diagram, el){
    var clone = el.clone().attr()
    diagram.svgel.append(clone)
    var bbox = clone.getBBox()
    clone.remove()
    return bbox
  }

  function point_to_string(p){ return p.x + ',' + p.y }

  function horizontal(line){
    return line.getAttribute('x1') == line.getAttribute('x2')
  }


  function display(diagram){
    // apply height / width on nodes
    var ingraph = diagram.ingraph
    var bbox_cache = {}
    ingraph.eachNode(function(id, node){
      var classname = node.classname
      var bbox = bbox_cache[classname] || (bbox_cache[classname] = inviz_bbox(diagram, from_defs(diagram, classname)))
      node.attr('x', bbox.x)
      node.attr('y', bbox.y)
      node.attr('width', bbox.width)
      node.attr('height', bbox.height)
    })

    var layout = diagram.layout
    var gcfg = diagram.graph.config
    if ( gcfg ) {
      Object.keys(gcfg).forEach(function(method){
        layout = layout[method](gcfg[method])
      })
    }
    layout.rankSimplex = true
    // calculate nodes layout
    layout = layout.run(ingraph)

    var graph = diagram.outgraph = layout.graph()

    // display nodes
    layout.eachNode(function(id, values){
      var node = diagram.ingraph.node(id)
      node.transform(values)
      draw(diagram, node)
    })


    // calculate edges layout
    var lanes = require('./edges.js')(layout, diagram)
    var segments = []

    var draw_bound = draw.bind(null, diagram)

    lanes.forEach(function(lane){
      lane.forEach(function(pw){
        var start = pw[0]
        var end = pw[pw.length - 1]
        // draw path
        var path_segment = {id: uid(), x1: start.x, y1:start.y, x2: end.x, y2: end.y}
        draw_bound({
          classname: diagram.config.edgeClass
        , content: {'.Edge:first': path_segment}
        })
        segments.push(path_segment)

        // draw the junctions
        var junctions = pw.filter(function(p){return p.node && ! p.entry })
        draw_bound({
          classname: diagram.config.edgeClass
        , content: {
            '.Edge': junctions.map(function(p){
              var j_segment = {id: uid(), x1: p.x, y1:p.y, x2: p.node.x, y2: p.node.y}
              segments.push(j_segment)
              return { ':first': j_segment}
            })
          }
        })

        var entries = pw.filter(function(p){return !! p.entry })
        draw_bound({
          classname: diagram.config.edgeEndClass
        , content: {
            '.Edge': entries.map(function(p){
              var j_segment = {id: uid(), x1: p.x, y1:p.y, x2: p.cut.x, y2: p.cut.y}
              segments.push(j_segment)
              return {':first': j_segment}
            })
          , '.Edge--end': entries.map(function(p){
              var j_segment = {id: uid(), x1: p.cut.x, y1:p.cut.y, x2: p.node.x, y2: p.node.y}
              segments.push(j_segment)
              return {':first': j_segment}
            })
          }
        })

      })
    })

    // draw the skips
    draw_bound({
      classname: diagram.config.edgeClass
    , content: {'.Edge': lanes.skips.map(function(p){
        var skip_segment = {id: uid(), x1: p[0].x, y1:p[0].y, x2: p[1].x, y2: p[1].y}
        segments.push(skip_segment)
        return { ':first': skip_segment }
      })}
    })

    var intersection_size = inviz_bbox(diagram, from_defs(diagram, diagram.config.intersectionClass))
    var intersection_middle = [intersection_size.width / 2, intersection_size.height / 2]
    segments.forEach(function(seg1, id1){
      segments.forEach(function(seg2, id2){
        if ( id2 > id1 && seg1.x1 != seg2.x1 &&  seg1.x2 != seg2.x2 && seg1.y1 != seg2.y1 &&  seg1.y2 != seg2.y2 ) {
          var isct = intersect(seg1, seg2)
          if ( isct ) {
            var seg1node = dom.$id(seg1.id)
            var seg2node = dom.$id(seg2.id)
            var topnode = seg1node.compareDocumentPosition(seg2node) & 4 ? seg1node : seg2node
            var intersect_node = draw(diagram, { classname: diagram.config.intersectionClass , content: {} })
            if ( horizontal(topnode) ) {
              intersect_node.transform((new Snap.Matrix(1, 0, 0, 1, 0 , 0)).rotate(90, isct[0] , isct[1] ).toTransformString())
                            .transform(intersect_node.matrix.translate(isct[0] - intersection_middle[0], isct[1] - intersection_middle[1]))
            } else {
              intersect_node.transform(new Snap.Matrix(1, 0, 0, 1, isct[0] - intersection_middle[0], isct[1] - intersection_middle[1]))
            }

            dom.insertAfter(topnode.parentNode, intersect_node.node, topnode.nextSibling)

          }
        }
      })
    })

    var move = diagram.svgel.matrix.clone()
    if ( graph.rankDir == "LR" || graph.rankDir == "RL" ) {
      graph.height = graph.height + lanes.growth * 2
      var move = move.translate(0, lanes.growth)
    } else {
      graph.width = graph.width + lanes.growth * 2
      var move = move.translate(lanes.growth, 0)
    }

    diagram.svgel.attr({ width: graph.width, height: graph.height }).transform(move.toTransformString())
    diagram.svgel.parent().attr({ width: graph.width + diagram.config.edgeWidth + diagram.config.padding, height: graph.height + diagram.config.edgeWidth + diagram.config.padding })
    return layout
  }

  module.exports = viral.extend(new events.EventEmitter).extend({
    init: function(config, graph){
      this.config = config
      this.items = {}
      this.connectors = {}
      this.graph = graph
      this.ingraph = graph.ingraph
      this.layout = dagre.layout()
      this.svgel = Snap.apply(Snap, config.snap_args).g().attr({ transform: "translate(20,20)", id:uid()})
    }
  , display: enslave(display)
  , draw: enslave(draw)
  , to_defs: enslave(to_defs)

//  , addItem: enslave(add_item)
//  , delItem: enslave(remove_item)
//
//  , connect: enslave(add_connector)
//  , disconnect: enslave(remove_connector)
//
//
//  , selectItems: enslave(filter_items)
//  , selectConnectors: enslave(filter_items)

  })
}()

},{"../util/defaults.js":70,"../util/dom.js":71,"../util/unique_id.js":72,"./edges.js":3,"./intersect.js":4,"./item.js":5,"dagre":12,"enslave":57,"events":74,"hyperglue":58,"snapsvg":64,"viral":66}],3:[function(require,module,exports){
void function(){

  var Set = require('../set.js')
  var Pathways = require('../pathway.js')

  var translate = require('./translate.js')
  var V = require('./vectors.js')

  function point(x, y){
    return { x: x || 0, y: y || 0 }
  }

  function side_from_direction(node, d){
    var c = point(node.x, node.y)
    var w = node.width / 2
    var h = node.height / 2
    var tl = translate([-w, -h], c)
    var tr = translate([w, -h], c)
    var bl = translate([-w, h], c)
    var br = translate([w, h], c)
    switch ( d ) {
      case 'L' :
        return [tl, bl]
      case 'R' :
        return [tr, br]
      case 'B' :
        return [bl, br]
      case 'T' :
        return [tl, tr]
    }
  }

  function divide_side(side, n){
    var X1 = side[0].x
    var Y1 = side[0].y
    var X2 = side[1].x
    var Y2 = side[1].y

    var W = X2 - X1
    var H = Y2 - Y1
    var points = []
    var rw = W / n
    var rh = H / n
    while ( --n > 0 ) {
      points.push(translate([ n * rw, n * rh ], side[0]))
    }
    points.reverse()
    return points
  }

  function get_rank_dim(margin, key, node){
    return Math.ceil(node[key] / margin) * margin
  }

  function num_comp(a, b){
    return a > b ?  1
         : a < b ? -1
         :          0
  }

  function sort_nodes_in_rank(dir, a, b){
    switch ( dir ) {
      case 'TB':
        return a.x < b.x ? -1
             : a.x > b.x ?  1
             :              0
      case 'BT':
        return a.x > b.x ? -1
             : a.x < b.x ?  1
             :              0
      case 'LR':
        return a.y < b.y ? -1
             : a.y > b.y ?  1
             :              0
      case 'RL':
        return a.y > b.y ? -1
             : a.y < b.y ?  1
             :              0
    }

  }

  function count_exits(pathways, source_id){
    var count = 0, finds = []

    pathways.forEach(function(p, pi){
      p.forEach(function(w, wi){
        if ( w.sources.has(source_id) ) {
          finds.push([pi, wi, w])
          count++
        }
      })
    })
    return count
  }

  module.exports = function(outgraph, diagram){
    var g = outgraph.graph()
    var rankDir = g.rankDir
    var vertical = rankDir == 'TB' || rankDir == 'BT'
    var reversed = rankDir == 'BT' || rankDir == 'RL'
    var rankSep = diagram.graph.config.rankSep
    var rank_sorter = sort_nodes_in_rank.bind(null, rankDir)
    var level_dir = vertical ? 'width' : 'height'
    var ranks_positions = []
    var ranks = []
    var norm_rank_dim = get_rank_dim.bind(null, diagram.config.rank_detection_error_margin, vertical ? 'y' : 'x' )

    function get_junction(path, level){
      return {
        x: vertical ? level : path
      , y: vertical ? path : level
      }
    }

    outgraph.eachNode(function(id, node){
      var rdim = norm_rank_dim(node)
      if ( ranks_positions.indexOf(rdim) == -1 ) {
        ranks_positions.push(rdim)
        ranks_positions.sort(num_comp)
      }
      node.rdim = rdim
    })
    if ( reversed ) {
      ranks_positions.reverse()
    }
    outgraph.eachNode(function(id, node){
      var r = ranks_positions.indexOf(node.rdim)
      node.true_rank = r
      if ( ranks[r] == null ) ranks[r] = []
      ranks[r].push(node)
    })

    ranks.forEach(function(r, i){
      ranks[i].sort(rank_sorter)
    })

    var edges_in_ranks = []
    var pathway_count = ranks.length + 1
    for ( var i = 0; i < pathway_count; i++ ) {
      edges_in_ranks[i] = Set.make()
    }

    outgraph.eachNode(function(id, node){

      var node_rank = node.true_rank
      outgraph.outEdges(id).forEach(function(out_edge_id){
        edges_in_ranks[node_rank + 1].add(out_edge_id)
      })

    })

    var lanes = []
    edges_in_ranks.forEach(function(rank, idx){
      lanes[idx] = Pathways.make()
      rank.forEach(function(edge_id){
        lanes[idx].add( outgraph.source(edge_id)
                    , edge_id
                    , outgraph.target(edge_id))
      })
    })

    outgraph.eachNode(function(id, node){
      var exits = divide_side(side_from_direction(node, rankDir[1]), count_exits(lanes, id) + 1)
      node.exits = exits
      node.entries = divide_side(side_from_direction(node, rankDir[0]), 2)
    })

    var fskips = []
    var bskips = []
    var edges = []
    var skipsep = diagram.config.edgeWidth
    lanes.forEach(function(lane, rank_nr){
      var pws  = []
      var pathways_count = lane.size()
      var psep = rankSep / (pathways_count + 1)
      lane.forEach(function(pathway, pw_idx){
        var tr = psep * (pw_idx + 1)
        if ( reversed ) tr  = tr * -1
        var tr_exit = translate.bind(null, vertical ? [0, tr] : [tr, 0])
        var tr_entry = translate.bind(null, vertical ? [0, tr - (reversed ? -1 * rankSep : rankSep)] : [tr - (reversed ? -1 * rankSep : rankSep), 0])
        var pw = []
        pathway.sources.forEach(function(source_id){
          var source = outgraph.node(source_id)
          if ( source.true_rank == rank_nr - 1 ) {
            source.spwi = pw_idx
            var junctions = source.exits.map(function(exit, idx){
              var p = tr_exit(exit)
              p.node = exit
              source.exits[idx].junction = p
              return p
            })
            pw = pw.concat(junctions)
          }
        })
        pathway.targets.forEach(function(target_id){
          var target = outgraph.node(target_id)
          if ( target.true_rank == rank_nr ) {
            target.tpwi = pw_idx
            var junctions = target.entries.map(function(entry, idx){
              var p = tr_entry(entry)
              var vector = [entry.x - p.x, entry.y - p.y]
              var s = V.scale(vector, -1.2 * diagram.config.edgeWidth / V.magnitude(vector))
              p.cut = translate(s, entry)
              p.node = entry
              p.entry = true
              target.entries[idx].junction = p
              return p
            })
            pw = pw.concat(junctions)
          }
        })
        pws[pw_idx] = pw
      })
      edges[rank_nr] = pws
    })

    edges.skips = []
    lanes.forEach(function(lane, rank_nr){
      lane.forEach(function(pathway, pw_idx){
        pathway.edges.forEach(function(edge_id){
          var tid = outgraph.target(edge_id)
          var target = outgraph.node(tid)
          var target_rank = target.true_rank
          var sid = outgraph.source(edge_id)
          var source = outgraph.node(sid)
          var source_rank = source.true_rank
          var rd = target_rank - source_rank
          if ( rd > 1 && fskips.indexOf(pathway) == -1 ) {
            fskips.push(pathway)
            var level_amount = fskips.length * skipsep
            var level = reversed ? 0 - level_amount : g[level_dir] + level_amount
            var source_junction = get_junction(source.exits[0].junction[vertical ? 'y' : 'x'], level )
            edges[source.true_rank + 1][source.spwi].push(source_junction)
            var target_junction = get_junction(target.entries[0].junction[vertical ? 'y' : 'x'], level )
            edges[target.true_rank][target.tpwi].push(target_junction)
            edges.skips.push([source_junction, target_junction])
          }
          if ( rd < 0 && bskips.indexOf(pathway) == -1 ) {
            bskips.push(pathway)
            var level_amount = bskips.length * skipsep
            var level = reversed ? g[level_dir] + level_amount : 0 - level_amount
            var source_junction = get_junction(source.exits[0].junction[vertical ? 'y' : 'x'], level )
            edges[source.true_rank + 1][source.spwi].push(source_junction)
            var target_junction = get_junction(target.entries[0].junction[vertical ? 'y' : 'x'], level )
            edges[target.true_rank][target.tpwi].push(target_junction)
            edges.skips.push([source_junction, target_junction])
          }
        })
      })
    })
    lanes.forEach(function(lane, rank_nr){
      lane.forEach(function(pathway, pw_idx){
        edges[rank_nr][pw_idx].sort(rank_sorter)
      })
    })

    edges.growth = (fskips.length + bskips.length) * skipsep


    return edges
  }

}()

},{"../pathway.js":67,"../set.js":68,"./translate.js":6,"./vectors.js":7}],4:[function(require,module,exports){
void function(){

  var V = require('./vectors.js')

  module.exports = function(seg1, seg2){
    var p = [seg1.x1, seg1.y1]
    var r = V.subtract([seg1.x2, seg1.y2], p)
    var q = [seg2.x1, seg2.y1]
    var s = V.subtract([seg2.x2, seg2.y2], q)

    var rxs = V.cross(r, s)
    if ( rxs == 0 ) return false

    var q_p = V.subtract(q,p)
    var rxs = V.cross(r, s)
    var t = V.cross(q_p, s) / rxs
    if ( t < 0 || t > 1 ) return false
    var u = V.cross(q_p, r) / rxs
    if ( u < 0 || u > 1 ) return false

    // var z1 = V.add(p, V.scale(r, t))
    // var z2 = V.add(q, V.scale(s, u))

    return V.add(p, V.scale(r, t))
  }

}()

},{"./vectors.js":7}],5:[function(require,module,exports){
void function(){
  var viral = require('viral')
  var enslave = require('enslave')

//  function draw_item(item){
//    return item.g = item.diagram.draw(item)
//  }

  var Item = viral.extend({
    init: function(diagram, id, value, invalues){
      this.diagram = diagram
      this.id = id
      this.value = value
      this.input = invalues



//      console.log('o', value)
//      console.log('i', invalues)
    }
//    , draw: enslave(draw_item)
  })

  module.exports = Item

}()


},{"enslave":57,"viral":66}],6:[function(require,module,exports){
void function(){
  module.exports = function translate(vector, point){
    return { x: point.x + vector[0], y: point.y + vector[1] }
  }
}()

},{}],7:[function(require,module,exports){
void function(){

  function pyth(a, b){
    return Math.sqrt(Math.pow(a,2), Math.pow(b,2))
  }

  module.exports = {
    cross: function cross(v, w){
      return v[0] * w[1] - v[1] * w[0]
    }

  , add:  function add(v, w){
      return [v[0] + w[0], v[1] + w[1]]
    }

  , subtract:  function subtract(v, w){
      return [v[0] - w[0], v[1] - w[1]]
    }

  , scale:  function scale(v, s){
      return [v[0] * s, v[1] * s]
    }

  , eq:  function eq(v, w){
      return v[0] == w[0] &&  v[1] == w[1]
    }
  , magnitude: function magnitude(v){
      return pyth(v[0], v[1])
    }

  }
}()

},{}],8:[function(require,module,exports){
void function(){
  var enslave = require('enslave')
  var Node = require('./node.js')
  var uid = require('../util/unique_id.js')

  var Edge = Node.extend({
    init: function(graph, source, target, transform, attrs){
      this.id = uid()
      this.type = 'edge'
      this.graph = graph
      this.source = source
      this.target = target
    }
  })

  module.exports = Edge
}()

},{"../util/unique_id.js":72,"./node.js":10,"enslave":57}],9:[function(require,module,exports){
void function(){
  var viral = require('viral')
  var enslave = require('enslave')
  var dagre = require('dagre')
  var events = require('events')
  var uid = require('../util/unique_id.js')
  var Node = require('./node.js')
  var Edge = require('./edge.js')

  function add_node(graph, classname, transform, content, prefRank){
    var node = Node.make(graph, transform, {
        classname: classname
      , content: content
      , rank: prefRank
    })

    graph.ingraph.addNode(node.id, node)
    return node
  }

  function remove_node(graph, node_id){
    var g = graph.ingraph
    if ( g.hasNode(node_id) ) {
      char.delNode(node_id)
      return true
    }
    return false
  }

  function connect(graph, classname, source, target, transform, content){
    var edge = Edge.make(graph, source, target)
    graph.ingraph.addEdge(edge.id, source.id, target.id, edge)
    return edge
  }

  function disconnect(graph, source, target){
    var g = graph.ingraph
    var edge_id = g.outEdges(source.id, target.id)
    if ( g.hasEdge(edge_id) ) {
      g.delEdge(edge_id)
      return true
    } else {
      return false
    }
  }

  module.exports = viral.extend(new events.EventEmitter).extend({
    init: function(cfgobj){
      this.config = cfgobj
      this.ingraph =  new dagre.Digraph()
    }
  , add_node: enslave(add_node)
  , del_node: enslave(remove_node)
  , connect: enslave(connect)
  , disconnect: enslave(disconnect)
  })

}()

},{"../util/unique_id.js":72,"./edge.js":8,"./node.js":10,"dagre":12,"enslave":57,"events":74,"viral":66}],10:[function(require,module,exports){
void function(){
  var viral = require('viral')
  var enslave = require('enslave')
  var uid = require('../util/unique_id.js')

  function set_attrs(node, attrs){
    Object.keys(attrs).forEach(function(key){
      node[key] = attrs[key]
    })
    node.graph.emit(node.type + '_attrs', attrs)
  }

  function set_attr(node, attr, value){
    node[attr] = value
    node.graph.emit(node.type + '_attr', attr, value)
  }

  function add_attr(node, selector, name, value){
    node.content[selector] = node.content[selector] || {}
    node.content[selector][name] = value
  }

  function add_attrs(node, selector, attrs){
    node.content[selector] = value
  }

  module.exports = viral.extend({
    init: function(graph, transform, attrs){
      this.id = uid()
      this.type = 'vertex'
      this.graph = graph
      this.transform = transform.bind(null, this)
      set_attrs(this, attrs)
    }
  , attrs: enslave(set_attrs)
  , attr: enslave(set_attr)
  , add_attr: enslave(add_attr)
  , add_attrs: enslave(add_attrs)
  })

}()

},{"../util/unique_id.js":72,"enslave":57,"viral":66}],11:[function(require,module,exports){
void function(){
//  var Snap = require('snapsvg')
//    init: function(){
//      this.svgel = Snap.apply(Snap, arguments)
//    }

  if (!String.prototype.trim) {
    String.prototype.trim = function () {
      return this.replace(/^\s+|\s+$/g, '')
    }
  }

  var defaults = require('./util/defaults.js')
  var Graph = require('./graph/graph.js')
  var Diagram = require('./diagram/diagram.js')


  /**
  * Set default configuration
  * @param      {Object} options
  * @return     {Object} options filled with defaults
  */
  function config(cfgobj){
    var default_cfg = {
      width: window.innerWidth
    , height: window.innerHeight
    , font_size: 21
    , line_height: 26 // for font-size 21
    }
    return cfgobj == null ? default_cfg
         :                  defaults(cfgobj, default_cfg)
  }

  /**
  * Create a new graph object to store diagram data in it
  * @return     {Object}   graph object
  */
  function graph(cfgobj){
    return Graph.make(cfgobj)
  }

  /**
  * Initialize diagram with options and graph object
  * and register event handlers
  * @param      {Object}   options
  * @param      {Object}   graph object
  * @return     {Object}   diagram
  */
  function diagram(cfgobj, graph){
    return Diagram.make(cfgobj, graph)
  }


  module.exports = {
    config: config
  , graph: graph
  , diagram: diagram
  }

}()

},{"./diagram/diagram.js":2,"./graph/graph.js":9,"./util/defaults.js":70}],12:[function(require,module,exports){
/*
Copyright (c) 2012-2013 Chris Pettitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
exports.Digraph = require("graphlib").Digraph;
exports.Graph = require("graphlib").Graph;
exports.layout = require("./lib/layout");
exports.version = require("./lib/version");

},{"./lib/layout":13,"./lib/version":28,"graphlib":34}],13:[function(require,module,exports){
var util = require('./util'),
    rank = require('./rank'),
    order = require('./order'),
    CGraph = require('graphlib').CGraph,
    CDigraph = require('graphlib').CDigraph;

module.exports = function() {
  // External configuration
  var config = {
    // How much debug information to include?
    debugLevel: 0,
    // Max number of sweeps to perform in order phase
    orderMaxSweeps: order.DEFAULT_MAX_SWEEPS,
    // Use network simplex algorithm in ranking
    rankSimplex: false,
    // Rank direction. Valid values are (TB, LR)
    rankDir: 'TB'
  };

  // Phase functions
  var position = require('./position')();

  // This layout object
  var self = {};

  self.orderIters = util.propertyAccessor(self, config, 'orderMaxSweeps');

  self.rankSimplex = util.propertyAccessor(self, config, 'rankSimplex');

  self.nodeSep = delegateProperty(position.nodeSep);
  self.edgeSep = delegateProperty(position.edgeSep);
  self.universalSep = delegateProperty(position.universalSep);
  self.rankSep = delegateProperty(position.rankSep);
  self.rankDir = util.propertyAccessor(self, config, 'rankDir');
  self.debugAlignment = delegateProperty(position.debugAlignment);

  self.debugLevel = util.propertyAccessor(self, config, 'debugLevel', function(x) {
    util.log.level = x;
    position.debugLevel(x);
  });

  self.run = util.time('Total layout', run);

  self._normalize = normalize;

  return self;

  /*
   * Constructs an adjacency graph using the nodes and edges specified through
   * config. For each node and edge we add a property `dagre` that contains an
   * object that will hold intermediate and final layout information. Some of
   * the contents include:
   *
   *  1) A generated ID that uniquely identifies the object.
   *  2) Dimension information for nodes (copied from the source node).
   *  3) Optional dimension information for edges.
   *
   * After the adjacency graph is constructed the code no longer needs to use
   * the original nodes and edges passed in via config.
   */
  function initLayoutGraph(inputGraph) {
    var g = new CDigraph();

    inputGraph.eachNode(function(u, value) {
      if (value === undefined) value = {};
      g.addNode(u, {
        width: value.width,
        height: value.height
      });
      if (value.hasOwnProperty('rank')) {
        g.node(u).prefRank = value.rank;
      }
    });

    // Set up subgraphs
    if (inputGraph.parent) {
      inputGraph.nodes().forEach(function(u) {
        g.parent(u, inputGraph.parent(u));
      });
    }

    inputGraph.eachEdge(function(e, u, v, value) {
      if (value === undefined) value = {};
      var newValue = {
        e: e,
        minLen: value.minLen || 1,
        width: value.width || 0,
        height: value.height || 0,
        points: []
      };

      g.addEdge(null, u, v, newValue);
    });

    // Initial graph attributes
    var graphValue = inputGraph.graph() || {};
    g.graph({
      rankDir: graphValue.rankDir || config.rankDir,
      orderRestarts: graphValue.orderRestarts
    });

    return g;
  }

  function run(inputGraph) {
    var rankSep = self.rankSep();
    var g;
    try {
      // Build internal graph
      g = util.time('initLayoutGraph', initLayoutGraph)(inputGraph);

      if (g.order() === 0) {
        return g;
      }

      // Make space for edge labels
      g.eachEdge(function(e, s, t, a) {
        a.minLen *= 2;
      });
      self.rankSep(rankSep / 2);

      // Determine the rank for each node. Nodes with a lower rank will appear
      // above nodes of higher rank.
      util.time('rank.run', rank.run)(g, config.rankSimplex);

      // Normalize the graph by ensuring that every edge is proper (each edge has
      // a length of 1). We achieve this by adding dummy nodes to long edges,
      // thus shortening them.
      util.time('normalize', normalize)(g);

      // Order the nodes so that edge crossings are minimized.
      util.time('order', order)(g, config.orderMaxSweeps);

      // Find the x and y coordinates for every node in the graph.
      util.time('position', position.run)(g);

      // De-normalize the graph by removing dummy nodes and augmenting the
      // original long edges with coordinate information.
      util.time('undoNormalize', undoNormalize)(g);

      // Reverses points for edges that are in a reversed state.
      util.time('fixupEdgePoints', fixupEdgePoints)(g);

      // Restore delete edges and reverse edges that were reversed in the rank
      // phase.
      util.time('rank.restoreEdges', rank.restoreEdges)(g);

      // Construct final result graph and return it
      return util.time('createFinalGraph', createFinalGraph)(g, inputGraph.isDirected());
    } finally {
      self.rankSep(rankSep);
    }
  }

  /*
   * This function is responsible for 'normalizing' the graph. The process of
   * normalization ensures that no edge in the graph has spans more than one
   * rank. To do this it inserts dummy nodes as needed and links them by adding
   * dummy edges. This function keeps enough information in the dummy nodes and
   * edges to ensure that the original graph can be reconstructed later.
   *
   * This method assumes that the input graph is cycle free.
   */
  function normalize(g) {
    var dummyCount = 0;
    g.eachEdge(function(e, s, t, a) {
      var sourceRank = g.node(s).rank;
      var targetRank = g.node(t).rank;
      if (sourceRank + 1 < targetRank) {
        for (var u = s, rank = sourceRank + 1, i = 0; rank < targetRank; ++rank, ++i) {
          var v = '_D' + (++dummyCount);
          var node = {
            width: a.width,
            height: a.height,
            edge: { id: e, source: s, target: t, attrs: a },
            rank: rank,
            dummy: true
          };

          // If this node represents a bend then we will use it as a control
          // point. For edges with 2 segments this will be the center dummy
          // node. For edges with more than two segments, this will be the
          // first and last dummy node.
          if (i === 0) node.index = 0;
          else if (rank + 1 === targetRank) node.index = 1;

          g.addNode(v, node);
          g.addEdge(null, u, v, {});
          u = v;
        }
        g.addEdge(null, u, t, {});
        g.delEdge(e);
      }
    });
  }

  /*
   * Reconstructs the graph as it was before normalization. The positions of
   * dummy nodes are used to build an array of points for the original 'long'
   * edge. Dummy nodes and edges are removed.
   */
  function undoNormalize(g) {
    g.eachNode(function(u, a) {
      if (a.dummy) {
        if ('index' in a) {
          var edge = a.edge;
          if (!g.hasEdge(edge.id)) {
            g.addEdge(edge.id, edge.source, edge.target, edge.attrs);
          }
          var points = g.edge(edge.id).points;
          points[a.index] = { x: a.x, y: a.y, ul: a.ul, ur: a.ur, dl: a.dl, dr: a.dr };
        }
        g.delNode(u);
      }
    });
  }

  /*
   * For each edge that was reversed during the `acyclic` step, reverse its
   * array of points.
   */
  function fixupEdgePoints(g) {
    g.eachEdge(function(e, s, t, a) { if (a.reversed) a.points.reverse(); });
  }

  function createFinalGraph(g, isDirected) {
    var out = isDirected ? new CDigraph() : new CGraph();
    out.graph(g.graph());
    g.eachNode(function(u, value) { out.addNode(u, value); });
    g.eachNode(function(u) { out.parent(u, g.parent(u)); });
    g.eachEdge(function(e, u, v, value) {
      out.addEdge(value.e, u, v, value);
    });

    // Attach bounding box information
    var maxX = 0, maxY = 0;
    g.eachNode(function(u, value) {
      if (!g.children(u).length) {
        maxX = Math.max(maxX, value.x + value.width / 2);
        maxY = Math.max(maxY, value.y + value.height / 2);
      }
    });
    g.eachEdge(function(e, u, v, value) {
      var maxXPoints = Math.max.apply(Math, value.points.map(function(p) { return p.x; }));
      var maxYPoints = Math.max.apply(Math, value.points.map(function(p) { return p.y; }));
      maxX = Math.max(maxX, maxXPoints + value.width / 2);
      maxY = Math.max(maxY, maxYPoints + value.height / 2);
    });
    out.graph().width = maxX;
    out.graph().height = maxY;

    return out;
  }

  /*
   * Given a function, a new function is returned that invokes the given
   * function. The return value from the function is always the `self` object.
   */
  function delegateProperty(f) {
    return function() {
      if (!arguments.length) return f();
      f.apply(null, arguments);
      return self;
    };
  }
};


},{"./order":14,"./position":19,"./rank":20,"./util":27,"graphlib":34}],14:[function(require,module,exports){
var util = require('./util'),
    crossCount = require('./order/crossCount'),
    initLayerGraphs = require('./order/initLayerGraphs'),
    initOrder = require('./order/initOrder'),
    sortLayer = require('./order/sortLayer');

module.exports = order;

// The maximum number of sweeps to perform before finishing the order phase.
var DEFAULT_MAX_SWEEPS = 24;
order.DEFAULT_MAX_SWEEPS = DEFAULT_MAX_SWEEPS;

/*
 * Runs the order phase with the specified `graph, `maxSweeps`, and
 * `debugLevel`. If `maxSweeps` is not specified we use `DEFAULT_MAX_SWEEPS`.
 * If `debugLevel` is not set we assume 0.
 */
function order(g, maxSweeps) {
  if (arguments.length < 2) {
    maxSweeps = DEFAULT_MAX_SWEEPS;
  }

  var restarts = g.graph().orderRestarts || 0;

  var layerGraphs = initLayerGraphs(g);
  // TODO: remove this when we add back support for ordering clusters
  layerGraphs.forEach(function(lg) {
    lg = lg.filterNodes(function(u) { return !g.children(u).length; });
  });

  var iters = 0,
      currentBestCC,
      allTimeBestCC = Number.MAX_VALUE,
      allTimeBest = {};

  function saveAllTimeBest() {
    g.eachNode(function(u, value) { allTimeBest[u] = value.order; });
  }

  for (var j = 0; j < Number(restarts) + 1 && allTimeBestCC !== 0; ++j) {
    currentBestCC = Number.MAX_VALUE;
    initOrder(g, restarts > 0);

    util.log(2, 'Order phase start cross count: ' + g.graph().orderInitCC);

    var i, lastBest, cc;
    for (i = 0, lastBest = 0; lastBest < 4 && i < maxSweeps && currentBestCC > 0; ++i, ++lastBest, ++iters) {
      sweep(g, layerGraphs, i);
      cc = crossCount(g);
      if (cc < currentBestCC) {
        lastBest = 0;
        currentBestCC = cc;
        if (cc < allTimeBestCC) {
          saveAllTimeBest();
          allTimeBestCC = cc;
        }
      }
      util.log(3, 'Order phase start ' + j + ' iter ' + i + ' cross count: ' + cc);
    }
  }

  Object.keys(allTimeBest).forEach(function(u) {
    if (!g.children || !g.children(u).length) {
      g.node(u).order = allTimeBest[u];
    }
  });
  g.graph().orderCC = allTimeBestCC;

  util.log(2, 'Order iterations: ' + iters);
  util.log(2, 'Order phase best cross count: ' + g.graph().orderCC);
}

function predecessorWeights(g, nodes) {
  var weights = {};
  nodes.forEach(function(u) {
    weights[u] = g.inEdges(u).map(function(e) {
      return g.node(g.source(e)).order;
    });
  });
  return weights;
}

function successorWeights(g, nodes) {
  var weights = {};
  nodes.forEach(function(u) {
    weights[u] = g.outEdges(u).map(function(e) {
      return g.node(g.target(e)).order;
    });
  });
  return weights;
}

function sweep(g, layerGraphs, iter) {
  if (iter % 2 === 0) {
    sweepDown(g, layerGraphs, iter);
  } else {
    sweepUp(g, layerGraphs, iter);
  }
}

function sweepDown(g, layerGraphs) {
  var cg;
  for (i = 1; i < layerGraphs.length; ++i) {
    cg = sortLayer(layerGraphs[i], cg, predecessorWeights(g, layerGraphs[i].nodes()));
  }
}

function sweepUp(g, layerGraphs) {
  var cg;
  for (i = layerGraphs.length - 2; i >= 0; --i) {
    sortLayer(layerGraphs[i], cg, successorWeights(g, layerGraphs[i].nodes()));
  }
}

},{"./order/crossCount":15,"./order/initLayerGraphs":16,"./order/initOrder":17,"./order/sortLayer":18,"./util":27}],15:[function(require,module,exports){
var util = require('../util');

module.exports = crossCount;

/*
 * Returns the cross count for the given graph.
 */
function crossCount(g) {
  var cc = 0;
  var ordering = util.ordering(g);
  for (var i = 1; i < ordering.length; ++i) {
    cc += twoLayerCrossCount(g, ordering[i-1], ordering[i]);
  }
  return cc;
}

/*
 * This function searches through a ranked and ordered graph and counts the
 * number of edges that cross. This algorithm is derived from:
 *
 *    W. Barth et al., Bilayer Cross Counting, JGAA, 8(2) 179–194 (2004)
 */
function twoLayerCrossCount(g, layer1, layer2) {
  var indices = [];
  layer1.forEach(function(u) {
    var nodeIndices = [];
    g.outEdges(u).forEach(function(e) { nodeIndices.push(g.node(g.target(e)).order); });
    nodeIndices.sort(function(x, y) { return x - y; });
    indices = indices.concat(nodeIndices);
  });

  var firstIndex = 1;
  while (firstIndex < layer2.length) firstIndex <<= 1;

  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;

  var tree = [];
  for (var i = 0; i < treeSize; ++i) { tree[i] = 0; }

  var cc = 0;
  indices.forEach(function(i) {
    var treeIndex = i + firstIndex;
    ++tree[treeIndex];
    while (treeIndex > 0) {
      if (treeIndex % 2) {
        cc += tree[treeIndex + 1];
      }
      treeIndex = (treeIndex - 1) >> 1;
      ++tree[treeIndex];
    }
  });

  return cc;
}

},{"../util":27}],16:[function(require,module,exports){
var nodesFromList = require('graphlib').filter.nodesFromList,
    /* jshint -W079 */
    Set = require('cp-data').Set;

module.exports = initLayerGraphs;

/*
 * This function takes a compound layered graph, g, and produces an array of
 * layer graphs. Each entry in the array represents a subgraph of nodes
 * relevant for performing crossing reduction on that layer.
 */
function initLayerGraphs(g) {
  var ranks = [];

  function dfs(u) {
    if (u === null) {
      g.children(u).forEach(function(v) { dfs(v); });
      return;
    }

    var value = g.node(u);
    value.minRank = ('rank' in value) ? value.rank : Number.MAX_VALUE;
    value.maxRank = ('rank' in value) ? value.rank : Number.MIN_VALUE;
    var uRanks = new Set();
    g.children(u).forEach(function(v) {
      var rs = dfs(v);
      uRanks = Set.union([uRanks, rs]);
      value.minRank = Math.min(value.minRank, g.node(v).minRank);
      value.maxRank = Math.max(value.maxRank, g.node(v).maxRank);
    });

    if ('rank' in value) uRanks.add(value.rank);

    uRanks.keys().forEach(function(r) {
      if (!(r in ranks)) ranks[r] = [];
      ranks[r].push(u);
    });

    return uRanks;
  }
  dfs(null);

  var layerGraphs = [];
  ranks.forEach(function(us, rank) {
    layerGraphs[rank] = g.filterNodes(nodesFromList(us));
  });

  return layerGraphs;
}

},{"cp-data":29,"graphlib":34}],17:[function(require,module,exports){
var crossCount = require('./crossCount'),
    util = require('../util');

module.exports = initOrder;

/*
 * Given a graph with a set of layered nodes (i.e. nodes that have a `rank`
 * attribute) this function attaches an `order` attribute that uniquely
 * arranges each node of each rank. If no constraint graph is provided the
 * order of the nodes in each rank is entirely arbitrary.
 */
function initOrder(g, random) {
  var layers = [];

  g.eachNode(function(u, value) {
    var layer = layers[value.rank];
    if (g.children && g.children(u).length > 0) return;
    if (!layer) {
      layer = layers[value.rank] = [];
    }
    layer.push(u);
  });

  layers.forEach(function(layer) {
    if (random) {
      util.shuffle(layer);
    }
    layer.forEach(function(u, i) {
      g.node(u).order = i;
    });
  });

  var cc = crossCount(g);
  g.graph().orderInitCC = cc;
  g.graph().orderCC = Number.MAX_VALUE;
}

},{"../util":27,"./crossCount":15}],18:[function(require,module,exports){
var util = require('../util');
/*
    Digraph = require('graphlib').Digraph,
    topsort = require('graphlib').alg.topsort,
    nodesFromList = require('graphlib').filter.nodesFromList;
*/

module.exports = sortLayer;

/*
function sortLayer(g, cg, weights) {
  var result = sortLayerSubgraph(g, null, cg, weights);
  result.list.forEach(function(u, i) {
    g.node(u).order = i;
  });
  return result.constraintGraph;
}
*/

function sortLayer(g, cg, weights) {
  var ordering = [];
  var bs = {};
  g.eachNode(function(u, value) {
    ordering[value.order] = u;
    var ws = weights[u];
    if (ws.length) {
      bs[u] = util.sum(ws) / ws.length;
    }
  });

  var toSort = g.nodes().filter(function(u) { return bs[u] !== undefined; });
  toSort.sort(function(x, y) {
    return bs[x] - bs[y] || g.node(x).order - g.node(y).order;
  });

  for (var i = 0, j = 0, jl = toSort.length; j < jl; ++i) {
    if (bs[ordering[i]] !== undefined) {
      g.node(toSort[j++]).order = i;
    }
  }
}

// TOOD: re-enable constrained sorting once we have a strategy for handling
// undefined barycenters.
/*
function sortLayerSubgraph(g, sg, cg, weights) {
  cg = cg ? cg.filterNodes(nodesFromList(g.children(sg))) : new Digraph();

  var nodeData = {};
  g.children(sg).forEach(function(u) {
    if (g.children(u).length) {
      nodeData[u] = sortLayerSubgraph(g, u, cg, weights);
      nodeData[u].firstSG = u;
      nodeData[u].lastSG = u;
    } else {
      var ws = weights[u];
      nodeData[u] = {
        degree: ws.length,
        barycenter: ws.length > 0 ? util.sum(ws) / ws.length : 0,
        list: [u]
      };
    }
  });

  resolveViolatedConstraints(g, cg, nodeData);

  var keys = Object.keys(nodeData);
  keys.sort(function(x, y) {
    return nodeData[x].barycenter - nodeData[y].barycenter;
  });

  var result =  keys.map(function(u) { return nodeData[u]; })
                    .reduce(function(lhs, rhs) { return mergeNodeData(g, lhs, rhs); });
  return result;
}

/*
function mergeNodeData(g, lhs, rhs) {
  var cg = mergeDigraphs(lhs.constraintGraph, rhs.constraintGraph);

  if (lhs.lastSG !== undefined && rhs.firstSG !== undefined) {
    if (cg === undefined) {
      cg = new Digraph();
    }
    if (!cg.hasNode(lhs.lastSG)) { cg.addNode(lhs.lastSG); }
    cg.addNode(rhs.firstSG);
    cg.addEdge(null, lhs.lastSG, rhs.firstSG);
  }

  return {
    degree: lhs.degree + rhs.degree,
    barycenter: (lhs.barycenter * lhs.degree + rhs.barycenter * rhs.degree) /
                (lhs.degree + rhs.degree),
    list: lhs.list.concat(rhs.list),
    firstSG: lhs.firstSG !== undefined ? lhs.firstSG : rhs.firstSG,
    lastSG: rhs.lastSG !== undefined ? rhs.lastSG : lhs.lastSG,
    constraintGraph: cg
  };
}

function mergeDigraphs(lhs, rhs) {
  if (lhs === undefined) return rhs;
  if (rhs === undefined) return lhs;

  lhs = lhs.copy();
  rhs.nodes().forEach(function(u) { lhs.addNode(u); });
  rhs.edges().forEach(function(e, u, v) { lhs.addEdge(null, u, v); });
  return lhs;
}

function resolveViolatedConstraints(g, cg, nodeData) {
  // Removes nodes `u` and `v` from `cg` and makes any edges incident on them
  // incident on `w` instead.
  function collapseNodes(u, v, w) {
    // TODO original paper removes self loops, but it is not obvious when this would happen
    cg.inEdges(u).forEach(function(e) {
      cg.delEdge(e);
      cg.addEdge(null, cg.source(e), w);
    });

    cg.outEdges(v).forEach(function(e) {
      cg.delEdge(e);
      cg.addEdge(null, w, cg.target(e));
    });

    cg.delNode(u);
    cg.delNode(v);
  }

  var violated;
  while ((violated = findViolatedConstraint(cg, nodeData)) !== undefined) {
    var source = cg.source(violated),
        target = cg.target(violated);

    var v;
    while ((v = cg.addNode(null)) && g.hasNode(v)) {
      cg.delNode(v);
    }

    // Collapse barycenter and list
    nodeData[v] = mergeNodeData(g, nodeData[source], nodeData[target]);
    delete nodeData[source];
    delete nodeData[target];

    collapseNodes(source, target, v);
    if (cg.incidentEdges(v).length === 0) { cg.delNode(v); }
  }
}

function findViolatedConstraint(cg, nodeData) {
  var us = topsort(cg);
  for (var i = 0; i < us.length; ++i) {
    var u = us[i];
    var inEdges = cg.inEdges(u);
    for (var j = 0; j < inEdges.length; ++j) {
      var e = inEdges[j];
      if (nodeData[cg.source(e)].barycenter >= nodeData[u].barycenter) {
        return e;
      }
    }
  }
}
*/

},{"../util":27}],19:[function(require,module,exports){
var util = require('./util');

/*
 * The algorithms here are based on Brandes and Köpf, "Fast and Simple
 * Horizontal Coordinate Assignment".
 */
module.exports = function() {
  // External configuration
  var config = {
    nodeSep: 50,
    edgeSep: 10,
    universalSep: null,
    rankSep: 30
  };

  var self = {};

  self.nodeSep = util.propertyAccessor(self, config, 'nodeSep');
  self.edgeSep = util.propertyAccessor(self, config, 'edgeSep');
  // If not null this separation value is used for all nodes and edges
  // regardless of their widths. `nodeSep` and `edgeSep` are ignored with this
  // option.
  self.universalSep = util.propertyAccessor(self, config, 'universalSep');
  self.rankSep = util.propertyAccessor(self, config, 'rankSep');
  self.debugLevel = util.propertyAccessor(self, config, 'debugLevel');

  self.run = run;

  return self;

  function run(g) {
    g = g.filterNodes(util.filterNonSubgraphs(g));

    var layering = util.ordering(g);

    var conflicts = findConflicts(g, layering);

    var xss = {};
    ['u', 'd'].forEach(function(vertDir) {
      if (vertDir === 'd') layering.reverse();

      ['l', 'r'].forEach(function(horizDir) {
        if (horizDir === 'r') reverseInnerOrder(layering);

        var dir = vertDir + horizDir;
        var align = verticalAlignment(g, layering, conflicts, vertDir === 'u' ? 'predecessors' : 'successors');
        xss[dir]= horizontalCompaction(g, layering, align.pos, align.root, align.align);

        if (config.debugLevel >= 3)
          debugPositioning(vertDir + horizDir, g, layering, xss[dir]);

        if (horizDir === 'r') flipHorizontally(xss[dir]);

        if (horizDir === 'r') reverseInnerOrder(layering);
      });

      if (vertDir === 'd') layering.reverse();
    });

    balance(g, layering, xss);

    g.eachNode(function(v) {
      var xs = [];
      for (var alignment in xss) {
        var alignmentX = xss[alignment][v];
        posXDebug(alignment, g, v, alignmentX);
        xs.push(alignmentX);
      }
      xs.sort(function(x, y) { return x - y; });
      posX(g, v, (xs[1] + xs[2]) / 2);
    });

    // Align y coordinates with ranks
    var y = 0, reverseY = g.graph().rankDir === 'BT' || g.graph().rankDir === 'RL';
    layering.forEach(function(layer) {
      var maxHeight = util.max(layer.map(function(u) { return height(g, u); }));
      y += maxHeight / 2;
      layer.forEach(function(u) {
        posY(g, u, reverseY ? -y : y);
      });
      y += maxHeight / 2 + config.rankSep;
    });

    // Translate layout so that top left corner of bounding rectangle has
    // coordinate (0, 0).
    var minX = util.min(g.nodes().map(function(u) { return posX(g, u) - width(g, u) / 2; }));
    var minY = util.min(g.nodes().map(function(u) { return posY(g, u) - height(g, u) / 2; }));
    g.eachNode(function(u) {
      posX(g, u, posX(g, u) - minX);
      posY(g, u, posY(g, u) - minY);
    });
  }

  /*
   * Generate an ID that can be used to represent any undirected edge that is
   * incident on `u` and `v`.
   */
  function undirEdgeId(u, v) {
    return u < v
      ? u.toString().length + ':' + u + '-' + v
      : v.toString().length + ':' + v + '-' + u;
  }

  function findConflicts(g, layering) {
    var conflicts = {}, // Set of conflicting edge ids
        pos = {},       // Position of node in its layer
        prevLayer,
        currLayer,
        k0,     // Position of the last inner segment in the previous layer
        l,      // Current position in the current layer (for iteration up to `l1`)
        k1;     // Position of the next inner segment in the previous layer or
                // the position of the last element in the previous layer

    if (layering.length <= 2) return conflicts;

    function updateConflicts(v) {
      var k = pos[v];
      if (k < k0 || k > k1) {
        conflicts[undirEdgeId(currLayer[l], v)] = true;
      }
    }

    layering[1].forEach(function(u, i) { pos[u] = i; });
    for (var i = 1; i < layering.length - 1; ++i) {
      prevLayer = layering[i];
      currLayer = layering[i+1];
      k0 = 0;
      l = 0;

      // Scan current layer for next node that is incident to an inner segement
      // between layering[i+1] and layering[i].
      for (var l1 = 0; l1 < currLayer.length; ++l1) {
        var u = currLayer[l1]; // Next inner segment in the current layer or
                               // last node in the current layer
        pos[u] = l1;
        k1 = undefined;

        if (g.node(u).dummy) {
          var uPred = g.predecessors(u)[0];
          // Note: In the case of self loops and sideways edges it is possible
          // for a dummy not to have a predecessor.
          if (uPred !== undefined && g.node(uPred).dummy)
            k1 = pos[uPred];
        }
        if (k1 === undefined && l1 === currLayer.length - 1)
          k1 = prevLayer.length - 1;

        if (k1 !== undefined) {
          for (; l <= l1; ++l) {
            g.predecessors(currLayer[l]).forEach(updateConflicts);
          }
          k0 = k1;
        }
      }
    }

    return conflicts;
  }

  function verticalAlignment(g, layering, conflicts, relationship) {
    var pos = {},   // Position for a node in its layer
        root = {},  // Root of the block that the node participates in
        align = {}; // Points to the next node in the block or, if the last
                    // element in the block, points to the first block's root

    layering.forEach(function(layer) {
      layer.forEach(function(u, i) {
        root[u] = u;
        align[u] = u;
        pos[u] = i;
      });
    });

    layering.forEach(function(layer) {
      var prevIdx = -1;
      layer.forEach(function(v) {
        var related = g[relationship](v), // Adjacent nodes from the previous layer
            mid;                          // The mid point in the related array

        if (related.length > 0) {
          related.sort(function(x, y) { return pos[x] - pos[y]; });
          mid = (related.length - 1) / 2;
          related.slice(Math.floor(mid), Math.ceil(mid) + 1).forEach(function(u) {
            if (align[v] === v) {
              if (!conflicts[undirEdgeId(u, v)] && prevIdx < pos[u]) {
                align[u] = v;
                align[v] = root[v] = root[u];
                prevIdx = pos[u];
              }
            }
          });
        }
      });
    });

    return { pos: pos, root: root, align: align };
  }

  // This function deviates from the standard BK algorithm in two ways. First
  // it takes into account the size of the nodes. Second it includes a fix to
  // the original algorithm that is described in Carstens, "Node and Label
  // Placement in a Layered Layout Algorithm".
  function horizontalCompaction(g, layering, pos, root, align) {
    var sink = {},       // Mapping of node id -> sink node id for class
        maybeShift = {}, // Mapping of sink node id -> { class node id, min shift }
        shift = {},      // Mapping of sink node id -> shift
        pred = {},       // Mapping of node id -> predecessor node (or null)
        xs = {};         // Calculated X positions

    layering.forEach(function(layer) {
      layer.forEach(function(u, i) {
        sink[u] = u;
        maybeShift[u] = {};
        if (i > 0)
          pred[u] = layer[i - 1];
      });
    });

    function updateShift(toShift, neighbor, delta) {
      if (!(neighbor in maybeShift[toShift])) {
        maybeShift[toShift][neighbor] = delta;
      } else {
        maybeShift[toShift][neighbor] = Math.min(maybeShift[toShift][neighbor], delta);
      }
    }

    function placeBlock(v) {
      if (!(v in xs)) {
        xs[v] = 0;
        var w = v;
        do {
          if (pos[w] > 0) {
            var u = root[pred[w]];
            placeBlock(u);
            if (sink[v] === v) {
              sink[v] = sink[u];
            }
            var delta = sep(g, pred[w]) + sep(g, w);
            if (sink[v] !== sink[u]) {
              updateShift(sink[u], sink[v], xs[v] - xs[u] - delta);
            } else {
              xs[v] = Math.max(xs[v], xs[u] + delta);
            }
          }
          w = align[w];
        } while (w !== v);
      }
    }

    // Root coordinates relative to sink
    util.values(root).forEach(function(v) {
      placeBlock(v);
    });

    // Absolute coordinates
    // There is an assumption here that we've resolved shifts for any classes
    // that begin at an earlier layer. We guarantee this by visiting layers in
    // order.
    layering.forEach(function(layer) {
      layer.forEach(function(v) {
        xs[v] = xs[root[v]];
        if (v === root[v] && v === sink[v]) {
          var minShift = 0;
          if (v in maybeShift && Object.keys(maybeShift[v]).length > 0) {
            minShift = util.min(Object.keys(maybeShift[v])
                                 .map(function(u) {
                                      return maybeShift[v][u] + (u in shift ? shift[u] : 0);
                                      }
                                 ));
          }
          shift[v] = minShift;
        }
      });
    });

    layering.forEach(function(layer) {
      layer.forEach(function(v) {
        xs[v] += shift[sink[root[v]]] || 0;
      });
    });

    return xs;
  }

  function findMinCoord(g, layering, xs) {
    return util.min(layering.map(function(layer) {
      var u = layer[0];
      return xs[u];
    }));
  }

  function findMaxCoord(g, layering, xs) {
    return util.max(layering.map(function(layer) {
      var u = layer[layer.length - 1];
      return xs[u];
    }));
  }

  function balance(g, layering, xss) {
    var min = {},                            // Min coordinate for the alignment
        max = {},                            // Max coordinate for the alginment
        smallestAlignment,
        shift = {};                          // Amount to shift a given alignment

    function updateAlignment(v) {
      xss[alignment][v] += shift[alignment];
    }

    var smallest = Number.POSITIVE_INFINITY;
    for (var alignment in xss) {
      var xs = xss[alignment];
      min[alignment] = findMinCoord(g, layering, xs);
      max[alignment] = findMaxCoord(g, layering, xs);
      var w = max[alignment] - min[alignment];
      if (w < smallest) {
        smallest = w;
        smallestAlignment = alignment;
      }
    }

    // Determine how much to adjust positioning for each alignment
    ['u', 'd'].forEach(function(vertDir) {
      ['l', 'r'].forEach(function(horizDir) {
        var alignment = vertDir + horizDir;
        shift[alignment] = horizDir === 'l'
            ? min[smallestAlignment] - min[alignment]
            : max[smallestAlignment] - max[alignment];
      });
    });

    // Find average of medians for xss array
    for (alignment in xss) {
      g.eachNode(updateAlignment);
    }
  }

  function flipHorizontally(xs) {
    for (var u in xs) {
      xs[u] = -xs[u];
    }
  }

  function reverseInnerOrder(layering) {
    layering.forEach(function(layer) {
      layer.reverse();
    });
  }

  function width(g, u) {
    switch (g.graph().rankDir) {
      case 'LR': return g.node(u).height;
      case 'RL': return g.node(u).height;
      default:   return g.node(u).width;
    }
  }

  function height(g, u) {
    switch(g.graph().rankDir) {
      case 'LR': return g.node(u).width;
      case 'RL': return g.node(u).width;
      default:   return g.node(u).height;
    }
  }

  function sep(g, u) {
    if (config.universalSep !== null) {
      return config.universalSep;
    }
    var w = width(g, u);
    var s = g.node(u).dummy ? config.edgeSep : config.nodeSep;
    return (w + s) / 2;
  }

  function posX(g, u, x) {
    if (g.graph().rankDir === 'LR' || g.graph().rankDir === 'RL') {
      if (arguments.length < 3) {
        return g.node(u).y;
      } else {
        g.node(u).y = x;
      }
    } else {
      if (arguments.length < 3) {
        return g.node(u).x;
      } else {
        g.node(u).x = x;
      }
    }
  }

  function posXDebug(name, g, u, x) {
    if (g.graph().rankDir === 'LR' || g.graph().rankDir === 'RL') {
      if (arguments.length < 3) {
        return g.node(u)[name];
      } else {
        g.node(u)[name] = x;
      }
    } else {
      if (arguments.length < 3) {
        return g.node(u)[name];
      } else {
        g.node(u)[name] = x;
      }
    }
  }

  function posY(g, u, y) {
    if (g.graph().rankDir === 'LR' || g.graph().rankDir === 'RL') {
      if (arguments.length < 3) {
        return g.node(u).x;
      } else {
        g.node(u).x = y;
      }
    } else {
      if (arguments.length < 3) {
        return g.node(u).y;
      } else {
        g.node(u).y = y;
      }
    }
  }

  function debugPositioning(align, g, layering, xs) {
    layering.forEach(function(l, li) {
      var u, xU;
      l.forEach(function(v) {
        var xV = xs[v];
        if (u) {
          var s = sep(g, u) + sep(g, v);
          if (xV - xU < s)
            console.log('Position phase: sep violation. Align: ' + align + '. Layer: ' + li + '. ' +
              'U: ' + u + ' V: ' + v + '. Actual sep: ' + (xV - xU) + ' Expected sep: ' + s);
        }
        u = v;
        xU = xV;
      });
    });
  }
};

},{"./util":27}],20:[function(require,module,exports){
var util = require('./util'),
    acyclic = require('./rank/acyclic'),
    initRank = require('./rank/initRank'),
    feasibleTree = require('./rank/feasibleTree'),
    constraints = require('./rank/constraints'),
    simplex = require('./rank/simplex'),
    components = require('graphlib').alg.components,
    filter = require('graphlib').filter;

exports.run = run;
exports.restoreEdges = restoreEdges;

/*
 * Heuristic function that assigns a rank to each node of the input graph with
 * the intent of minimizing edge lengths, while respecting the `minLen`
 * attribute of incident edges.
 *
 * Prerequisites:
 *
 *  * Each edge in the input graph must have an assigned 'minLen' attribute
 */
function run(g, useSimplex) {
  expandSelfLoops(g);

  // If there are rank constraints on nodes, then build a new graph that
  // encodes the constraints.
  util.time('constraints.apply', constraints.apply)(g);

  expandSidewaysEdges(g);

  // Reverse edges to get an acyclic graph, we keep the graph in an acyclic
  // state until the very end.
  util.time('acyclic', acyclic)(g);

  // Convert the graph into a flat graph for ranking
  var flatGraph = g.filterNodes(util.filterNonSubgraphs(g));

  // Assign an initial ranking using DFS.
  initRank(flatGraph);

  // For each component improve the assigned ranks.
  components(flatGraph).forEach(function(cmpt) {
    var subgraph = flatGraph.filterNodes(filter.nodesFromList(cmpt));
    rankComponent(subgraph, useSimplex);
  });

  // Relax original constraints
  util.time('constraints.relax', constraints.relax(g));

  // When handling nodes with constrained ranks it is possible to end up with
  // edges that point to previous ranks. Most of the subsequent algorithms assume
  // that edges are pointing to successive ranks only. Here we reverse any "back
  // edges" and mark them as such. The acyclic algorithm will reverse them as a
  // post processing step.
  util.time('reorientEdges', reorientEdges)(g);
}

function restoreEdges(g) {
  acyclic.undo(g);
}

/*
 * Expand self loops into three dummy nodes. One will sit above the incident
 * node, one will be at the same level, and one below. The result looks like:
 *
 *         /--<--x--->--\
 *     node              y
 *         \--<--z--->--/
 *
 * Dummy nodes x, y, z give us the shape of a loop and node y is where we place
 * the label.
 *
 * TODO: consolidate knowledge of dummy node construction.
 * TODO: support minLen = 2
 */
function expandSelfLoops(g) {
  g.eachEdge(function(e, u, v, a) {
    if (u === v) {
      var x = addDummyNode(g, e, u, v, a, 0, false),
          y = addDummyNode(g, e, u, v, a, 1, true),
          z = addDummyNode(g, e, u, v, a, 2, false);
      g.addEdge(null, x, u, {minLen: 1, selfLoop: true});
      g.addEdge(null, x, y, {minLen: 1, selfLoop: true});
      g.addEdge(null, u, z, {minLen: 1, selfLoop: true});
      g.addEdge(null, y, z, {minLen: 1, selfLoop: true});
      g.delEdge(e);
    }
  });
}

function expandSidewaysEdges(g) {
  g.eachEdge(function(e, u, v, a) {
    if (u === v) {
      var origEdge = a.originalEdge,
          dummy = addDummyNode(g, origEdge.e, origEdge.u, origEdge.v, origEdge.value, 0, true);
      g.addEdge(null, u, dummy, {minLen: 1});
      g.addEdge(null, dummy, v, {minLen: 1});
      g.delEdge(e);
    }
  });
}

function addDummyNode(g, e, u, v, a, index, isLabel) {
  return g.addNode(null, {
    width: isLabel ? a.width : 0,
    height: isLabel ? a.height : 0,
    edge: { id: e, source: u, target: v, attrs: a },
    dummy: true,
    index: index
  });
}

function reorientEdges(g) {
  g.eachEdge(function(e, u, v, value) {
    if (g.node(u).rank > g.node(v).rank) {
      g.delEdge(e);
      value.reversed = true;
      g.addEdge(e, v, u, value);
    }
  });
}

function rankComponent(subgraph, useSimplex) {
  var spanningTree = feasibleTree(subgraph);

  if (useSimplex) {
    util.log(1, 'Using network simplex for ranking');
    simplex(subgraph, spanningTree);
  }
  normalize(subgraph);
}

function normalize(g) {
  var m = util.min(g.nodes().map(function(u) { return g.node(u).rank; }));
  g.eachNode(function(u, node) { node.rank -= m; });
}

},{"./rank/acyclic":21,"./rank/constraints":22,"./rank/feasibleTree":23,"./rank/initRank":24,"./rank/simplex":26,"./util":27,"graphlib":34}],21:[function(require,module,exports){
var util = require('../util');

module.exports = acyclic;
module.exports.undo = undo;

/*
 * This function takes a directed graph that may have cycles and reverses edges
 * as appropriate to break these cycles. Each reversed edge is assigned a
 * `reversed` attribute with the value `true`.
 *
 * There should be no self loops in the graph.
 */
function acyclic(g) {
  var onStack = {},
      visited = {},
      reverseCount = 0;
  
  function dfs(u) {
    if (u in visited) return;
    visited[u] = onStack[u] = true;
    g.outEdges(u).forEach(function(e) {
      var t = g.target(e),
          value;

      if (u === t) {
        console.error('Warning: found self loop "' + e + '" for node "' + u + '"');
      } else if (t in onStack) {
        value = g.edge(e);
        g.delEdge(e);
        value.reversed = true;
        ++reverseCount;
        g.addEdge(e, t, u, value);
      } else {
        dfs(t);
      }
    });

    delete onStack[u];
  }

  g.eachNode(function(u) { dfs(u); });

  util.log(2, 'Acyclic Phase: reversed ' + reverseCount + ' edge(s)');

  return reverseCount;
}

/*
 * Given a graph that has had the acyclic operation applied, this function
 * undoes that operation. More specifically, any edge with the `reversed`
 * attribute is again reversed to restore the original direction of the edge.
 */
function undo(g) {
  g.eachEdge(function(e, s, t, a) {
    if (a.reversed) {
      delete a.reversed;
      g.delEdge(e);
      g.addEdge(e, t, s, a);
    }
  });
}

},{"../util":27}],22:[function(require,module,exports){
exports.apply = function(g) {
  function dfs(sg) {
    var rankSets = {};
    g.children(sg).forEach(function(u) {
      if (g.children(u).length) {
        dfs(u);
        return;
      }

      var value = g.node(u),
          prefRank = value.prefRank;
      if (prefRank !== undefined) {
        if (!checkSupportedPrefRank(prefRank)) { return; }

        if (!(prefRank in rankSets)) {
          rankSets.prefRank = [u];
        } else {
          rankSets.prefRank.push(u);
        }

        var newU = rankSets[prefRank];
        if (newU === undefined) {
          newU = rankSets[prefRank] = g.addNode(null, { originalNodes: [] });
          g.parent(newU, sg);
        }

        redirectInEdges(g, u, newU, prefRank === 'min');
        redirectOutEdges(g, u, newU, prefRank === 'max');

        // Save original node and remove it from reduced graph
        g.node(newU).originalNodes.push({ u: u, value: value, parent: sg });
        g.delNode(u);
      }
    });

    addLightEdgesFromMinNode(g, sg, rankSets.min);
    addLightEdgesToMaxNode(g, sg, rankSets.max);
  }

  dfs(null);
};

function checkSupportedPrefRank(prefRank) {
  if (prefRank !== 'min' && prefRank !== 'max' && prefRank.indexOf('same_') !== 0) {
    console.error('Unsupported rank type: ' + prefRank);
    return false;
  }
  return true;
}

function redirectInEdges(g, u, newU, reverse) {
  g.inEdges(u).forEach(function(e) {
    var origValue = g.edge(e),
        value;
    if (origValue.originalEdge) {
      value = origValue;
    } else {
      value =  {
        originalEdge: { e: e, u: g.source(e), v: g.target(e), value: origValue },
        minLen: g.edge(e).minLen
      };
    }

    // Do not reverse edges for self-loops.
    if (origValue.selfLoop) {
      reverse = false;
    }

    if (reverse) {
      // Ensure that all edges to min are reversed
      g.addEdge(null, newU, g.source(e), value);
      value.reversed = true;
    } else {
      g.addEdge(null, g.source(e), newU, value);
    }
  });
}

function redirectOutEdges(g, u, newU, reverse) {
  g.outEdges(u).forEach(function(e) {
    var origValue = g.edge(e),
        value;
    if (origValue.originalEdge) {
      value = origValue;
    } else {
      value =  {
        originalEdge: { e: e, u: g.source(e), v: g.target(e), value: origValue },
        minLen: g.edge(e).minLen
      };
    }

    // Do not reverse edges for self-loops.
    if (origValue.selfLoop) {
      reverse = false;
    }

    if (reverse) {
      // Ensure that all edges from max are reversed
      g.addEdge(null, g.target(e), newU, value);
      value.reversed = true;
    } else {
      g.addEdge(null, newU, g.target(e), value);
    }
  });
}

function addLightEdgesFromMinNode(g, sg, minNode) {
  if (minNode !== undefined) {
    g.children(sg).forEach(function(u) {
      // The dummy check ensures we don't add an edge if the node is involved
      // in a self loop or sideways edge.
      if (u !== minNode && !g.outEdges(minNode, u).length && !g.node(u).dummy) {
        g.addEdge(null, minNode, u, { minLen: 0 });
      }
    });
  }
}

function addLightEdgesToMaxNode(g, sg, maxNode) {
  if (maxNode !== undefined) {
    g.children(sg).forEach(function(u) {
      // The dummy check ensures we don't add an edge if the node is involved
      // in a self loop or sideways edge.
      if (u !== maxNode && !g.outEdges(u, maxNode).length && !g.node(u).dummy) {
        g.addEdge(null, u, maxNode, { minLen: 0 });
      }
    });
  }
}

/*
 * This function "relaxes" the constraints applied previously by the "apply"
 * function. It expands any nodes that were collapsed and assigns the rank of
 * the collapsed node to each of the expanded nodes. It also restores the
 * original edges and removes any dummy edges pointing at the collapsed nodes.
 *
 * Note that the process of removing collapsed nodes also removes dummy edges
 * automatically.
 */
exports.relax = function(g) {
  // Save original edges
  var originalEdges = [];
  g.eachEdge(function(e, u, v, value) {
    var originalEdge = value.originalEdge;
    if (originalEdge) {
      originalEdges.push(originalEdge);
    }
  });

  // Expand collapsed nodes
  g.eachNode(function(u, value) {
    var originalNodes = value.originalNodes;
    if (originalNodes) {
      originalNodes.forEach(function(originalNode) {
        originalNode.value.rank = value.rank;
        g.addNode(originalNode.u, originalNode.value);
        g.parent(originalNode.u, originalNode.parent);
      });
      g.delNode(u);
    }
  });

  // Restore original edges
  originalEdges.forEach(function(edge) {
    g.addEdge(edge.e, edge.u, edge.v, edge.value);
  });
};

},{}],23:[function(require,module,exports){
/* jshint -W079 */
var Set = require('cp-data').Set,
/* jshint +W079 */
    Digraph = require('graphlib').Digraph,
    util = require('../util');

module.exports = feasibleTree;

/*
 * Given an acyclic graph with each node assigned a `rank` attribute, this
 * function constructs and returns a spanning tree. This function may reduce
 * the length of some edges from the initial rank assignment while maintaining
 * the `minLen` specified by each edge.
 *
 * Prerequisites:
 *
 * * The input graph is acyclic
 * * Each node in the input graph has an assigned `rank` attribute
 * * Each edge in the input graph has an assigned `minLen` attribute
 *
 * Outputs:
 *
 * A feasible spanning tree for the input graph (i.e. a spanning tree that
 * respects each graph edge's `minLen` attribute) represented as a Digraph with
 * a `root` attribute on graph.
 *
 * Nodes have the same id and value as that in the input graph.
 *
 * Edges in the tree have arbitrarily assigned ids. The attributes for edges
 * include `reversed`. `reversed` indicates that the edge is a
 * back edge in the input graph.
 */
function feasibleTree(g) {
  var remaining = new Set(g.nodes()),
      tree = new Digraph();

  if (remaining.size() === 1) {
    var root = g.nodes()[0];
    tree.addNode(root, {});
    tree.graph({ root: root });
    return tree;
  }

  function addTightEdges(v) {
    var continueToScan = true;
    g.predecessors(v).forEach(function(u) {
      if (remaining.has(u) && !slack(g, u, v)) {
        if (remaining.has(v)) {
          tree.addNode(v, {});
          remaining.remove(v);
          tree.graph({ root: v });
        }

        tree.addNode(u, {});
        tree.addEdge(null, u, v, { reversed: true });
        remaining.remove(u);
        addTightEdges(u);
        continueToScan = false;
      }
    });

    g.successors(v).forEach(function(w)  {
      if (remaining.has(w) && !slack(g, v, w)) {
        if (remaining.has(v)) {
          tree.addNode(v, {});
          remaining.remove(v);
          tree.graph({ root: v });
        }

        tree.addNode(w, {});
        tree.addEdge(null, v, w, {});
        remaining.remove(w);
        addTightEdges(w);
        continueToScan = false;
      }
    });
    return continueToScan;
  }

  function createTightEdge() {
    var minSlack = Number.MAX_VALUE;
    remaining.keys().forEach(function(v) {
      g.predecessors(v).forEach(function(u) {
        if (!remaining.has(u)) {
          var edgeSlack = slack(g, u, v);
          if (Math.abs(edgeSlack) < Math.abs(minSlack)) {
            minSlack = -edgeSlack;
          }
        }
      });

      g.successors(v).forEach(function(w) {
        if (!remaining.has(w)) {
          var edgeSlack = slack(g, v, w);
          if (Math.abs(edgeSlack) < Math.abs(minSlack)) {
            minSlack = edgeSlack;
          }
        }
      });
    });

    tree.eachNode(function(u) { g.node(u).rank -= minSlack; });
  }

  while (remaining.size()) {
    var nodesToSearch = !tree.order() ? remaining.keys() : tree.nodes();
    for (var i = 0, il = nodesToSearch.length;
         i < il && addTightEdges(nodesToSearch[i]);
         ++i);
    if (remaining.size()) {
      createTightEdge();
    }
  }

  return tree;
}

function slack(g, u, v) {
  var rankDiff = g.node(v).rank - g.node(u).rank;
  var maxMinLen = util.max(g.outEdges(u, v)
                            .map(function(e) { return g.edge(e).minLen; }));
  return rankDiff - maxMinLen;
}

},{"../util":27,"cp-data":29,"graphlib":34}],24:[function(require,module,exports){
var util = require('../util'),
    topsort = require('graphlib').alg.topsort;

module.exports = initRank;

/*
 * Assigns a `rank` attribute to each node in the input graph and ensures that
 * this rank respects the `minLen` attribute of incident edges.
 *
 * Prerequisites:
 *
 *  * The input graph must be acyclic
 *  * Each edge in the input graph must have an assigned 'minLen' attribute
 */
function initRank(g) {
  var sorted = topsort(g);

  sorted.forEach(function(u) {
    var inEdges = g.inEdges(u);
    if (inEdges.length === 0) {
      g.node(u).rank = 0;
      return;
    }

    var minLens = inEdges.map(function(e) {
      return g.node(g.source(e)).rank + g.edge(e).minLen;
    });
    g.node(u).rank = util.max(minLens);
  });
}

},{"../util":27,"graphlib":34}],25:[function(require,module,exports){
module.exports = {
  slack: slack
};

/*
 * A helper to calculate the slack between two nodes (`u` and `v`) given a
 * `minLen` constraint. The slack represents how much the distance between `u`
 * and `v` could shrink while maintaining the `minLen` constraint. If the value
 * is negative then the constraint is currently violated.
 *
  This function requires that `u` and `v` are in `graph` and they both have a
  `rank` attribute.
 */
function slack(graph, u, v, minLen) {
  return Math.abs(graph.node(u).rank - graph.node(v).rank) - minLen;
}

},{}],26:[function(require,module,exports){
var util = require('../util'),
    rankUtil = require('./rankUtil');

module.exports = simplex;

function simplex(graph, spanningTree) {
  // The network simplex algorithm repeatedly replaces edges of
  // the spanning tree with negative cut values until no such
  // edge exists.
  initCutValues(graph, spanningTree);
  while (true) {
    var e = leaveEdge(spanningTree);
    if (e === null) break;
    var f = enterEdge(graph, spanningTree, e);
    exchange(graph, spanningTree, e, f);
  }
}

/*
 * Set the cut values of edges in the spanning tree by a depth-first
 * postorder traversal.  The cut value corresponds to the cost, in
 * terms of a ranking's edge length sum, of lengthening an edge.
 * Negative cut values typically indicate edges that would yield a
 * smaller edge length sum if they were lengthened.
 */
function initCutValues(graph, spanningTree) {
  computeLowLim(spanningTree);

  spanningTree.eachEdge(function(id, u, v, treeValue) {
    treeValue.cutValue = 0;
  });

  // Propagate cut values up the tree.
  function dfs(n) {
    var children = spanningTree.successors(n);
    for (var c in children) {
      var child = children[c];
      dfs(child);
    }
    if (n !== spanningTree.graph().root) {
      setCutValue(graph, spanningTree, n);
    }
  }
  dfs(spanningTree.graph().root);
}

/*
 * Perform a DFS postorder traversal, labeling each node v with
 * its traversal order 'lim(v)' and the minimum traversal number
 * of any of its descendants 'low(v)'.  This provides an efficient
 * way to test whether u is an ancestor of v since
 * low(u) <= lim(v) <= lim(u) if and only if u is an ancestor.
 */
function computeLowLim(tree) {
  var postOrderNum = 0;
  
  function dfs(n) {
    var children = tree.successors(n);
    var low = postOrderNum;
    for (var c in children) {
      var child = children[c];
      dfs(child);
      low = Math.min(low, tree.node(child).low);
    }
    tree.node(n).low = low;
    tree.node(n).lim = postOrderNum++;
  }

  dfs(tree.graph().root);
}

/*
 * To compute the cut value of the edge parent -> child, we consider
 * it and any other graph edges to or from the child.
 *          parent
 *             |
 *           child
 *          /      \
 *         u        v
 */
function setCutValue(graph, tree, child) {
  var parentEdge = tree.inEdges(child)[0];

  // List of child's children in the spanning tree.
  var grandchildren = [];
  var grandchildEdges = tree.outEdges(child);
  for (var gce in grandchildEdges) {
    grandchildren.push(tree.target(grandchildEdges[gce]));
  }

  var cutValue = 0;

  // TODO: Replace unit increment/decrement with edge weights.
  var E = 0;    // Edges from child to grandchild's subtree.
  var F = 0;    // Edges to child from grandchild's subtree.
  var G = 0;    // Edges from child to nodes outside of child's subtree.
  var H = 0;    // Edges from nodes outside of child's subtree to child.

  // Consider all graph edges from child.
  var outEdges = graph.outEdges(child);
  var gc;
  for (var oe in outEdges) {
    var succ = graph.target(outEdges[oe]);
    for (gc in grandchildren) {
      if (inSubtree(tree, succ, grandchildren[gc])) {
        E++;
      }
    }
    if (!inSubtree(tree, succ, child)) {
      G++;
    }
  }

  // Consider all graph edges to child.
  var inEdges = graph.inEdges(child);
  for (var ie in inEdges) {
    var pred = graph.source(inEdges[ie]);
    for (gc in grandchildren) {
      if (inSubtree(tree, pred, grandchildren[gc])) {
        F++;
      }
    }
    if (!inSubtree(tree, pred, child)) {
      H++;
    }
  }

  // Contributions depend on the alignment of the parent -> child edge
  // and the child -> u or v edges.
  var grandchildCutSum = 0;
  for (gc in grandchildren) {
    var cv = tree.edge(grandchildEdges[gc]).cutValue;
    if (!tree.edge(grandchildEdges[gc]).reversed) {
      grandchildCutSum += cv;
    } else {
      grandchildCutSum -= cv;
    }
  }

  if (!tree.edge(parentEdge).reversed) {
    cutValue += grandchildCutSum - E + F - G + H;
  } else {
    cutValue -= grandchildCutSum - E + F - G + H;
  }

  tree.edge(parentEdge).cutValue = cutValue;
}

/*
 * Return whether n is a node in the subtree with the given
 * root.
 */
function inSubtree(tree, n, root) {
  return (tree.node(root).low <= tree.node(n).lim &&
          tree.node(n).lim <= tree.node(root).lim);
}

/*
 * Return an edge from the tree with a negative cut value, or null if there
 * is none.
 */
function leaveEdge(tree) {
  var edges = tree.edges();
  for (var n in edges) {
    var e = edges[n];
    var treeValue = tree.edge(e);
    if (treeValue.cutValue < 0) {
      return e;
    }
  }
  return null;
}

/*
 * The edge e should be an edge in the tree, with an underlying edge
 * in the graph, with a negative cut value.  Of the two nodes incident
 * on the edge, take the lower one.  enterEdge returns an edge with
 * minimum slack going from outside of that node's subtree to inside
 * of that node's subtree.
 */
function enterEdge(graph, tree, e) {
  var source = tree.source(e);
  var target = tree.target(e);
  var lower = tree.node(target).lim < tree.node(source).lim ? target : source;

  // Is the tree edge aligned with the graph edge?
  var aligned = !tree.edge(e).reversed;

  var minSlack = Number.POSITIVE_INFINITY;
  var minSlackEdge;
  if (aligned) {
    graph.eachEdge(function(id, u, v, value) {
      if (id !== e && inSubtree(tree, u, lower) && !inSubtree(tree, v, lower)) {
        var slack = rankUtil.slack(graph, u, v, value.minLen);
        if (slack < minSlack) {
          minSlack = slack;
          minSlackEdge = id;
        }
      }
    });
  } else {
    graph.eachEdge(function(id, u, v, value) {
      if (id !== e && !inSubtree(tree, u, lower) && inSubtree(tree, v, lower)) {
        var slack = rankUtil.slack(graph, u, v, value.minLen);
        if (slack < minSlack) {
          minSlack = slack;
          minSlackEdge = id;
        }
      }
    });
  }

  if (minSlackEdge === undefined) {
    var outside = [];
    var inside = [];
    graph.eachNode(function(id) {
      if (!inSubtree(tree, id, lower)) {
        outside.push(id);
      } else {
        inside.push(id);
      }
    });
    throw new Error('No edge found from outside of tree to inside');
  }

  return minSlackEdge;
}

/*
 * Replace edge e with edge f in the tree, recalculating the tree root,
 * the nodes' low and lim properties and the edges' cut values.
 */
function exchange(graph, tree, e, f) {
  tree.delEdge(e);
  var source = graph.source(f);
  var target = graph.target(f);

  // Redirect edges so that target is the root of its subtree.
  function redirect(v) {
    var edges = tree.inEdges(v);
    for (var i in edges) {
      var e = edges[i];
      var u = tree.source(e);
      var value = tree.edge(e);
      redirect(u);
      tree.delEdge(e);
      value.reversed = !value.reversed;
      tree.addEdge(e, v, u, value);
    }
  }

  redirect(target);

  var root = source;
  var edges = tree.inEdges(root);
  while (edges.length > 0) {
    root = tree.source(edges[0]);
    edges = tree.inEdges(root);
  }

  tree.graph().root = root;

  tree.addEdge(null, source, target, {cutValue: 0});

  initCutValues(graph, tree);

  adjustRanks(graph, tree);
}

/*
 * Reset the ranks of all nodes based on the current spanning tree.
 * The rank of the tree's root remains unchanged, while all other
 * nodes are set to the sum of minimum length constraints along
 * the path from the root.
 */
function adjustRanks(graph, tree) {
  function dfs(p) {
    var children = tree.successors(p);
    children.forEach(function(c) {
      var minLen = minimumLength(graph, p, c);
      graph.node(c).rank = graph.node(p).rank + minLen;
      dfs(c);
    });
  }

  dfs(tree.graph().root);
}

/*
 * If u and v are connected by some edges in the graph, return the
 * minimum length of those edges, as a positive number if v succeeds
 * u and as a negative number if v precedes u.
 */
function minimumLength(graph, u, v) {
  var outEdges = graph.outEdges(u, v);
  if (outEdges.length > 0) {
    return util.max(outEdges.map(function(e) {
      return graph.edge(e).minLen;
    }));
  }

  var inEdges = graph.inEdges(u, v);
  if (inEdges.length > 0) {
    return -util.max(inEdges.map(function(e) {
      return graph.edge(e).minLen;
    }));
  }
}

},{"../util":27,"./rankUtil":25}],27:[function(require,module,exports){
/*
 * Returns the smallest value in the array.
 */
exports.min = function(values) {
  return Math.min.apply(Math, values);
};

/*
 * Returns the largest value in the array.
 */
exports.max = function(values) {
  return Math.max.apply(Math, values);
};

/*
 * Returns `true` only if `f(x)` is `true` for all `x` in `xs`. Otherwise
 * returns `false`. This function will return immediately if it finds a
 * case where `f(x)` does not hold.
 */
exports.all = function(xs, f) {
  for (var i = 0; i < xs.length; ++i) {
    if (!f(xs[i])) {
      return false;
    }
  }
  return true;
};

/*
 * Accumulates the sum of elements in the given array using the `+` operator.
 */
exports.sum = function(values) {
  return values.reduce(function(acc, x) { return acc + x; }, 0);
};

/*
 * Returns an array of all values in the given object.
 */
exports.values = function(obj) {
  return Object.keys(obj).map(function(k) { return obj[k]; });
};

exports.shuffle = function(array) {
  for (i = array.length - 1; i > 0; --i) {
    var j = Math.floor(Math.random() * (i + 1));
    var aj = array[j];
    array[j] = array[i];
    array[i] = aj;
  }
};

exports.propertyAccessor = function(self, config, field, setHook) {
  return function(x) {
    if (!arguments.length) return config[field];
    config[field] = x;
    if (setHook) setHook(x);
    return self;
  };
};

/*
 * Given a layered, directed graph with `rank` and `order` node attributes,
 * this function returns an array of ordered ranks. Each rank contains an array
 * of the ids of the nodes in that rank in the order specified by the `order`
 * attribute.
 */
exports.ordering = function(g) {
  var ordering = [];
  g.eachNode(function(u, value) {
    var rank = ordering[value.rank] || (ordering[value.rank] = []);
    rank[value.order] = u;
  });
  return ordering;
};

/*
 * A filter that can be used with `filterNodes` to get a graph that only
 * includes nodes that do not contain others nodes.
 */
exports.filterNonSubgraphs = function(g) {
  return function(u) {
    return g.children(u).length === 0;
  };
};

/*
 * Returns a new function that wraps `func` with a timer. The wrapper logs the
 * time it takes to execute the function.
 *
 * The timer will be enabled provided `log.level >= 1`.
 */
function time(name, func) {
  return function() {
    var start = new Date().getTime();
    try {
      return func.apply(null, arguments);
    } finally {
      log(1, name + ' time: ' + (new Date().getTime() - start) + 'ms');
    }
  };
}
time.enabled = false;

exports.time = time;

/*
 * A global logger with the specification `log(level, message, ...)` that
 * will log a message to the console if `log.level >= level`.
 */
function log(level) {
  if (log.level >= level) {
    console.log.apply(console, Array.prototype.slice.call(arguments, 1));
  }
}
log.level = 0;

exports.log = log;

},{}],28:[function(require,module,exports){
module.exports = '0.4.5';

},{}],29:[function(require,module,exports){
exports.Set = require('./lib/Set');
exports.PriorityQueue = require('./lib/PriorityQueue');
exports.version = require('./lib/version');

},{"./lib/PriorityQueue":30,"./lib/Set":31,"./lib/version":33}],30:[function(require,module,exports){
module.exports = PriorityQueue;

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}

/**
 * Returns the number of elements in the queue. Takes `O(1)` time.
 */
PriorityQueue.prototype.size = function() {
  return this._arr.length;
};

/**
 * Returns the keys that are in the queue. Takes `O(n)` time.
 */
PriorityQueue.prototype.keys = function() {
  return this._arr.map(function(x) { return x.key; });
};

/**
 * Returns `true` if **key** is in the queue and `false` if not.
 */
PriorityQueue.prototype.has = function(key) {
  return key in this._keyIndices;
};

/**
 * Returns the priority for **key**. If **key** is not present in the queue
 * then this function returns `undefined`. Takes `O(1)` time.
 *
 * @param {Object} key
 */
PriorityQueue.prototype.priority = function(key) {
  var index = this._keyIndices[key];
  if (index !== undefined) {
    return this._arr[index].priority;
  }
};

/**
 * Returns the key for the minimum element in this queue. If the queue is
 * empty this function throws an Error. Takes `O(1)` time.
 */
PriorityQueue.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};

/**
 * Inserts a new key into the priority queue. If the key already exists in
 * the queue this function returns `false`; otherwise it will return `true`.
 * Takes `O(n)` time.
 *
 * @param {Object} key the key to add
 * @param {Number} priority the initial priority for the key
 */
PriorityQueue.prototype.add = function(key, priority) {
  var keyIndices = this._keyIndices;
  if (!(key in keyIndices)) {
    var arr = this._arr;
    var index = arr.length;
    keyIndices[key] = index;
    arr.push({key: key, priority: priority});
    this._decrease(index);
    return true;
  }
  return false;
};

/**
 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
 */
PriorityQueue.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  var min = this._arr.pop();
  delete this._keyIndices[min.key];
  this._heapify(0);
  return min.key;
};

/**
 * Decreases the priority for **key** to **priority**. If the new priority is
 * greater than the previous priority, this function will throw an Error.
 *
 * @param {Object} key the key for which to raise priority
 * @param {Number} priority the new priority for the key
 */
PriorityQueue.prototype.decrease = function(key, priority) {
  var index = this._keyIndices[key];
  if (priority > this._arr[index].priority) {
    throw new Error("New priority is greater than current priority. " +
        "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
  }
  this._arr[index].priority = priority;
  this._decrease(index);
};

PriorityQueue.prototype._heapify = function(i) {
  var arr = this._arr;
  var l = 2 * i,
      r = l + 1,
      largest = i;
  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;
    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }
    if (largest !== i) {
      this._swap(i, largest);
      this._heapify(largest);
    }
  }
};

PriorityQueue.prototype._decrease = function(index) {
  var arr = this._arr;
  var priority = arr[index].priority;
  var parent;
  while (index !== 0) {
    parent = index >> 1;
    if (arr[parent].priority < priority) {
      break;
    }
    this._swap(index, parent);
    index = parent;
  }
};

PriorityQueue.prototype._swap = function(i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};

},{}],31:[function(require,module,exports){
var util = require('./util');

module.exports = Set;

/**
 * Constructs a new Set with an optional set of `initialKeys`.
 *
 * It is important to note that keys are coerced to String for most purposes
 * with this object, similar to the behavior of JavaScript's Object. For
 * example, the following will add only one key:
 *
 *     var s = new Set();
 *     s.add(1);
 *     s.add("1");
 *
 * However, the type of the key is preserved internally so that `keys` returns
 * the original key set uncoerced. For the above example, `keys` would return
 * `[1]`.
 */
function Set(initialKeys) {
  this._size = 0;
  this._keys = {};

  if (initialKeys) {
    for (var i = 0, il = initialKeys.length; i < il; ++i) {
      this.add(initialKeys[i]);
    }
  }
}

/**
 * Returns a new Set that represents the set intersection of the array of given
 * sets.
 */
Set.intersect = function(sets) {
  if (sets.length === 0) {
    return new Set();
  }

  var result = new Set(!util.isArray(sets[0]) ? sets[0].keys() : sets[0]);
  for (var i = 1, il = sets.length; i < il; ++i) {
    var resultKeys = result.keys(),
        other = !util.isArray(sets[i]) ? sets[i] : new Set(sets[i]);
    for (var j = 0, jl = resultKeys.length; j < jl; ++j) {
      var key = resultKeys[j];
      if (!other.has(key)) {
        result.remove(key);
      }
    }
  }

  return result;
};

/**
 * Returns a new Set that represents the set union of the array of given sets.
 */
Set.union = function(sets) {
  var totalElems = util.reduce(sets, function(lhs, rhs) {
    return lhs + (rhs.size ? rhs.size() : rhs.length);
  }, 0);
  var arr = new Array(totalElems);

  var k = 0;
  for (var i = 0, il = sets.length; i < il; ++i) {
    var cur = sets[i],
        keys = !util.isArray(cur) ? cur.keys() : cur;
    for (var j = 0, jl = keys.length; j < jl; ++j) {
      arr[k++] = keys[j];
    }
  }

  return new Set(arr);
};

/**
 * Returns the size of this set in `O(1)` time.
 */
Set.prototype.size = function() {
  return this._size;
};

/**
 * Returns the keys in this set. Takes `O(n)` time.
 */
Set.prototype.keys = function() {
  return values(this._keys);
};

/**
 * Tests if a key is present in this Set. Returns `true` if it is and `false`
 * if not. Takes `O(1)` time.
 */
Set.prototype.has = function(key) {
  return key in this._keys;
};

/**
 * Adds a new key to this Set if it is not already present. Returns `true` if
 * the key was added and `false` if it was already present. Takes `O(1)` time.
 */
Set.prototype.add = function(key) {
  if (!(key in this._keys)) {
    this._keys[key] = key;
    ++this._size;
    return true;
  }
  return false;
};

/**
 * Removes a key from this Set. If the key was removed this function returns
 * `true`. If not, it returns `false`. Takes `O(1)` time.
 */
Set.prototype.remove = function(key) {
  if (key in this._keys) {
    delete this._keys[key];
    --this._size;
    return true;
  }
  return false;
};

/*
 * Returns an array of all values for properties of **o**.
 */
function values(o) {
  var ks = Object.keys(o),
      len = ks.length,
      result = new Array(len),
      i;
  for (i = 0; i < len; ++i) {
    result[i] = o[ks[i]];
  }
  return result;
}

},{"./util":32}],32:[function(require,module,exports){
/*
 * This polyfill comes from
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
 */
if(!Array.isArray) {
  exports.isArray = function (vArg) {
    return Object.prototype.toString.call(vArg) === '[object Array]';
  };
} else {
  exports.isArray = Array.isArray;
}

/*
 * Slightly adapted polyfill from
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce
 */
if ('function' !== typeof Array.prototype.reduce) {
  exports.reduce = function(array, callback, opt_initialValue) {
    'use strict';
    if (null === array || 'undefined' === typeof array) {
      // At the moment all modern browsers, that support strict mode, have
      // native implementation of Array.prototype.reduce. For instance, IE8
      // does not support strict mode, so this check is actually useless.
      throw new TypeError(
          'Array.prototype.reduce called on null or undefined');
    }
    if ('function' !== typeof callback) {
      throw new TypeError(callback + ' is not a function');
    }
    var index, value,
        length = array.length >>> 0,
        isValueSet = false;
    if (1 < arguments.length) {
      value = opt_initialValue;
      isValueSet = true;
    }
    for (index = 0; length > index; ++index) {
      if (array.hasOwnProperty(index)) {
        if (isValueSet) {
          value = callback(value, array[index], index, array);
        }
        else {
          value = array[index];
          isValueSet = true;
        }
      }
    }
    if (!isValueSet) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    return value;
  };
} else {
  exports.reduce = function(array, callback, opt_initialValue) {
    return array.reduce(callback, opt_initialValue);
  };
}

},{}],33:[function(require,module,exports){
module.exports = '1.1.3';

},{}],34:[function(require,module,exports){
exports.Graph = require("./lib/Graph");
exports.Digraph = require("./lib/Digraph");
exports.CGraph = require("./lib/CGraph");
exports.CDigraph = require("./lib/CDigraph");
require("./lib/graph-converters");

exports.alg = {
  isAcyclic: require("./lib/alg/isAcyclic"),
  components: require("./lib/alg/components"),
  dijkstra: require("./lib/alg/dijkstra"),
  dijkstraAll: require("./lib/alg/dijkstraAll"),
  findCycles: require("./lib/alg/findCycles"),
  floydWarshall: require("./lib/alg/floydWarshall"),
  postorder: require("./lib/alg/postorder"),
  preorder: require("./lib/alg/preorder"),
  prim: require("./lib/alg/prim"),
  tarjan: require("./lib/alg/tarjan"),
  topsort: require("./lib/alg/topsort")
};

exports.converter = {
  json: require("./lib/converter/json.js")
};

var filter = require("./lib/filter");
exports.filter = {
  all: filter.all,
  nodesFromList: filter.nodesFromList
};

exports.version = require("./lib/version");

},{"./lib/CDigraph":36,"./lib/CGraph":37,"./lib/Digraph":38,"./lib/Graph":39,"./lib/alg/components":40,"./lib/alg/dijkstra":41,"./lib/alg/dijkstraAll":42,"./lib/alg/findCycles":43,"./lib/alg/floydWarshall":44,"./lib/alg/isAcyclic":45,"./lib/alg/postorder":46,"./lib/alg/preorder":47,"./lib/alg/prim":48,"./lib/alg/tarjan":49,"./lib/alg/topsort":50,"./lib/converter/json.js":52,"./lib/filter":53,"./lib/graph-converters":54,"./lib/version":56}],35:[function(require,module,exports){
/* jshint -W079 */
var Set = require("cp-data").Set;
/* jshint +W079 */

module.exports = BaseGraph;

function BaseGraph() {
  // The value assigned to the graph itself.
  this._value = undefined;

  // Map of node id -> { id, value }
  this._nodes = {};

  // Map of edge id -> { id, u, v, value }
  this._edges = {};

  // Used to generate a unique id in the graph
  this._nextId = 0;
}

// Number of nodes
BaseGraph.prototype.order = function() {
  return Object.keys(this._nodes).length;
};

// Number of edges
BaseGraph.prototype.size = function() {
  return Object.keys(this._edges).length;
};

// Accessor for graph level value
BaseGraph.prototype.graph = function(value) {
  if (arguments.length === 0) {
    return this._value;
  }
  this._value = value;
};

BaseGraph.prototype.hasNode = function(u) {
  return u in this._nodes;
};

BaseGraph.prototype.node = function(u, value) {
  var node = this._strictGetNode(u);
  if (arguments.length === 1) {
    return node.value;
  }
  node.value = value;
};

BaseGraph.prototype.nodes = function() {
  var nodes = [];
  this.eachNode(function(id) { nodes.push(id); });
  return nodes;
};

BaseGraph.prototype.eachNode = function(func) {
  for (var k in this._nodes) {
    var node = this._nodes[k];
    func(node.id, node.value);
  }
};

BaseGraph.prototype.hasEdge = function(e) {
  return e in this._edges;
};

BaseGraph.prototype.edge = function(e, value) {
  var edge = this._strictGetEdge(e);
  if (arguments.length === 1) {
    return edge.value;
  }
  edge.value = value;
};

BaseGraph.prototype.edges = function() {
  var es = [];
  this.eachEdge(function(id) { es.push(id); });
  return es;
};

BaseGraph.prototype.eachEdge = function(func) {
  for (var k in this._edges) {
    var edge = this._edges[k];
    func(edge.id, edge.u, edge.v, edge.value);
  }
};

BaseGraph.prototype.incidentNodes = function(e) {
  var edge = this._strictGetEdge(e);
  return [edge.u, edge.v];
};

BaseGraph.prototype.addNode = function(u, value) {
  if (u === undefined || u === null) {
    do {
      u = "_" + (++this._nextId);
    } while (this.hasNode(u));
  } else if (this.hasNode(u)) {
    throw new Error("Graph already has node '" + u + "'");
  }
  this._nodes[u] = { id: u, value: value };
  return u;
};

BaseGraph.prototype.delNode = function(u) {
  this._strictGetNode(u);
  this.incidentEdges(u).forEach(function(e) { this.delEdge(e); }, this);
  delete this._nodes[u];
};

// inMap and outMap are opposite sides of an incidence map. For example, for
// Graph these would both come from the _incidentEdges map, while for Digraph
// they would come from _inEdges and _outEdges.
BaseGraph.prototype._addEdge = function(e, u, v, value, inMap, outMap) {
  this._strictGetNode(u);
  this._strictGetNode(v);

  if (e === undefined || e === null) {
    do {
      e = "_" + (++this._nextId);
    } while (this.hasEdge(e));
  }
  else if (this.hasEdge(e)) {
    throw new Error("Graph already has edge '" + e + "'");
  }

  this._edges[e] = { id: e, u: u, v: v, value: value };
  addEdgeToMap(inMap[v], u, e);
  addEdgeToMap(outMap[u], v, e);

  return e;
};

// See note for _addEdge regarding inMap and outMap.
BaseGraph.prototype._delEdge = function(e, inMap, outMap) {
  var edge = this._strictGetEdge(e);
  delEdgeFromMap(inMap[edge.v], edge.u, e);
  delEdgeFromMap(outMap[edge.u], edge.v, e);
  delete this._edges[e];
};

BaseGraph.prototype.copy = function() {
  var copy = new this.constructor();
  copy.graph(this.graph());
  this.eachNode(function(u, value) { copy.addNode(u, value); });
  this.eachEdge(function(e, u, v, value) { copy.addEdge(e, u, v, value); });
  copy._nextId = this._nextId;
  return copy;
};

BaseGraph.prototype.filterNodes = function(filter) {
  var copy = new this.constructor();
  copy.graph(this.graph());
  this.eachNode(function(u, value) {
    if (filter(u)) {
      copy.addNode(u, value);
    }
  });
  this.eachEdge(function(e, u, v, value) {
    if (copy.hasNode(u) && copy.hasNode(v)) {
      copy.addEdge(e, u, v, value);
    }
  });
  return copy;
};

BaseGraph.prototype._strictGetNode = function(u) {
  var node = this._nodes[u];
  if (node === undefined) {
    throw new Error("Node '" + u + "' is not in graph");
  }
  return node;
};

BaseGraph.prototype._strictGetEdge = function(e) {
  var edge = this._edges[e];
  if (edge === undefined) {
    throw new Error("Edge '" + e + "' is not in graph");
  }
  return edge;
};

function addEdgeToMap(map, v, e) {
  (map[v] || (map[v] = new Set())).add(e);
}

function delEdgeFromMap(map, v, e) {
  var vEntry = map[v];
  vEntry.remove(e);
  if (vEntry.size() === 0) {
    delete map[v];
  }
}


},{"cp-data":29}],36:[function(require,module,exports){
var Digraph = require("./Digraph"),
    compoundify = require("./compoundify");

var CDigraph = compoundify(Digraph);

module.exports = CDigraph;

CDigraph.fromDigraph = function(src) {
  var g = new CDigraph(),
      graphValue = src.graph();

  if (graphValue !== undefined) {
    g.graph(graphValue);
  }

  src.eachNode(function(u, value) {
    if (value === undefined) {
      g.addNode(u);
    } else {
      g.addNode(u, value);
    }
  });
  src.eachEdge(function(e, u, v, value) {
    if (value === undefined) {
      g.addEdge(null, u, v);
    } else {
      g.addEdge(null, u, v, value);
    }
  });
  return g;
};

CDigraph.prototype.toString = function() {
  return "CDigraph " + JSON.stringify(this, null, 2);
};

},{"./Digraph":38,"./compoundify":51}],37:[function(require,module,exports){
var Graph = require("./Graph"),
    compoundify = require("./compoundify");

var CGraph = compoundify(Graph);

module.exports = CGraph;

CGraph.fromGraph = function(src) {
  var g = new CGraph(),
      graphValue = src.graph();

  if (graphValue !== undefined) {
    g.graph(graphValue);
  }

  src.eachNode(function(u, value) {
    if (value === undefined) {
      g.addNode(u);
    } else {
      g.addNode(u, value);
    }
  });
  src.eachEdge(function(e, u, v, value) {
    if (value === undefined) {
      g.addEdge(null, u, v);
    } else {
      g.addEdge(null, u, v, value);
    }
  });
  return g;
};

CGraph.prototype.toString = function() {
  return "CGraph " + JSON.stringify(this, null, 2);
};

},{"./Graph":39,"./compoundify":51}],38:[function(require,module,exports){
/*
 * This file is organized with in the following order:
 *
 * Exports
 * Graph constructors
 * Graph queries (e.g. nodes(), edges()
 * Graph mutators
 * Helper functions
 */

var util = require("./util"),
    BaseGraph = require("./BaseGraph"),
/* jshint -W079 */
    Set = require("cp-data").Set;
/* jshint +W079 */

module.exports = Digraph;

/*
 * Constructor to create a new directed multi-graph.
 */
function Digraph() {
  BaseGraph.call(this);

  /*! Map of sourceId -> {targetId -> Set of edge ids} */
  this._inEdges = {};

  /*! Map of targetId -> {sourceId -> Set of edge ids} */
  this._outEdges = {};
}

Digraph.prototype = new BaseGraph();
Digraph.prototype.constructor = Digraph;

/*
 * Always returns `true`.
 */
Digraph.prototype.isDirected = function() {
  return true;
};

/*
 * Returns all successors of the node with the id `u`. That is, all nodes
 * that have the node `u` as their source are returned.
 * 
 * If no node `u` exists in the graph this function throws an Error.
 *
 * @param {String} u a node id
 */
Digraph.prototype.successors = function(u) {
  this._strictGetNode(u);
  return Object.keys(this._outEdges[u])
               .map(function(v) { return this._nodes[v].id; }, this);
};

/*
 * Returns all predecessors of the node with the id `u`. That is, all nodes
 * that have the node `u` as their target are returned.
 * 
 * If no node `u` exists in the graph this function throws an Error.
 *
 * @param {String} u a node id
 */
Digraph.prototype.predecessors = function(u) {
  this._strictGetNode(u);
  return Object.keys(this._inEdges[u])
               .map(function(v) { return this._nodes[v].id; }, this);
};

/*
 * Returns all nodes that are adjacent to the node with the id `u`. In other
 * words, this function returns the set of all successors and predecessors of
 * node `u`.
 *
 * @param {String} u a node id
 */
Digraph.prototype.neighbors = function(u) {
  return Set.union([this.successors(u), this.predecessors(u)]).keys();
};

/*
 * Returns all nodes in the graph that have no in-edges.
 */
Digraph.prototype.sources = function() {
  var self = this;
  return this._filterNodes(function(u) {
    // This could have better space characteristics if we had an inDegree function.
    return self.inEdges(u).length === 0;
  });
};

/*
 * Returns all nodes in the graph that have no out-edges.
 */
Digraph.prototype.sinks = function() {
  var self = this;
  return this._filterNodes(function(u) {
    // This could have better space characteristics if we have an outDegree function.
    return self.outEdges(u).length === 0;
  });
};

/*
 * Returns the source node incident on the edge identified by the id `e`. If no
 * such edge exists in the graph this function throws an Error.
 *
 * @param {String} e an edge id
 */
Digraph.prototype.source = function(e) {
  return this._strictGetEdge(e).u;
};

/*
 * Returns the target node incident on the edge identified by the id `e`. If no
 * such edge exists in the graph this function throws an Error.
 *
 * @param {String} e an edge id
 */
Digraph.prototype.target = function(e) {
  return this._strictGetEdge(e).v;
};

/*
 * Returns an array of ids for all edges in the graph that have the node
 * `target` as their target. If the node `target` is not in the graph this
 * function raises an Error.
 *
 * Optionally a `source` node can also be specified. This causes the results
 * to be filtered such that only edges from `source` to `target` are included.
 * If the node `source` is specified but is not in the graph then this function
 * raises an Error.
 *
 * @param {String} target the target node id
 * @param {String} [source] an optional source node id
 */
Digraph.prototype.inEdges = function(target, source) {
  this._strictGetNode(target);
  var results = Set.union(util.values(this._inEdges[target])).keys();
  if (arguments.length > 1) {
    this._strictGetNode(source);
    results = results.filter(function(e) { return this.source(e) === source; }, this);
  }
  return results;
};

/*
 * Returns an array of ids for all edges in the graph that have the node
 * `source` as their source. If the node `source` is not in the graph this
 * function raises an Error.
 *
 * Optionally a `target` node may also be specified. This causes the results
 * to be filtered such that only edges from `source` to `target` are included.
 * If the node `target` is specified but is not in the graph then this function
 * raises an Error.
 *
 * @param {String} source the source node id
 * @param {String} [target] an optional target node id
 */
Digraph.prototype.outEdges = function(source, target) {
  this._strictGetNode(source);
  var results = Set.union(util.values(this._outEdges[source])).keys();
  if (arguments.length > 1) {
    this._strictGetNode(target);
    results = results.filter(function(e) { return this.target(e) === target; }, this);
  }
  return results;
};

/*
 * Returns an array of ids for all edges in the graph that have the `u` as
 * their source or their target. If the node `u` is not in the graph this
 * function raises an Error.
 *
 * Optionally a `v` node may also be specified. This causes the results to be
 * filtered such that only edges between `u` and `v` - in either direction -
 * are included. IF the node `v` is specified but not in the graph then this
 * function raises an Error.
 *
 * @param {String} u the node for which to find incident edges
 * @param {String} [v] option node that must be adjacent to `u`
 */
Digraph.prototype.incidentEdges = function(u, v) {
  if (arguments.length > 1) {
    return Set.union([this.outEdges(u, v), this.outEdges(v, u)]).keys();
  } else {
    return Set.union([this.inEdges(u), this.outEdges(u)]).keys();
  }
};

/*
 * Returns a string representation of this graph.
 */
Digraph.prototype.toString = function() {
  return "Digraph " + JSON.stringify(this, null, 2);
};

/*
 * Adds a new node with the id `u` to the graph and assigns it the value
 * `value`. If a node with the id is already a part of the graph this function
 * throws an Error.
 *
 * @param {String} u a node id
 * @param {Object} [value] an optional value to attach to the node
 */
Digraph.prototype.addNode = function(u, value) {
  u = BaseGraph.prototype.addNode.call(this, u, value);
  this._inEdges[u] = {};
  this._outEdges[u] = {};
  return u;
};

/*
 * Removes a node from the graph that has the id `u`. Any edges incident on the
 * node are also removed. If the graph does not contain a node with the id this
 * function will throw an Error.
 *
 * @param {String} u a node id
 */
Digraph.prototype.delNode = function(u) {
  BaseGraph.prototype.delNode.call(this, u);
  delete this._inEdges[u];
  delete this._outEdges[u];
};

/*
 * Adds a new edge to the graph with the id `e` from a node with the id `source`
 * to a node with an id `target` and assigns it the value `value`. This graph
 * allows more than one edge from `source` to `target` as long as the id `e`
 * is unique in the set of edges. If `e` is `null` the graph will assign a
 * unique identifier to the edge.
 *
 * If `source` or `target` are not present in the graph this function will
 * throw an Error.
 *
 * @param {String} [e] an edge id
 * @param {String} source the source node id
 * @param {String} target the target node id
 * @param {Object} [value] an optional value to attach to the edge
 */
Digraph.prototype.addEdge = function(e, source, target, value) {
  return BaseGraph.prototype._addEdge.call(this, e, source, target, value,
                                           this._inEdges, this._outEdges);
};

/*
 * Removes an edge in the graph with the id `e`. If no edge in the graph has
 * the id `e` this function will throw an Error.
 *
 * @param {String} e an edge id
 */
Digraph.prototype.delEdge = function(e) {
  BaseGraph.prototype._delEdge.call(this, e, this._inEdges, this._outEdges);
};

// Unlike BaseGraph.filterNodes, this helper just returns nodes that
// satisfy a predicate.
Digraph.prototype._filterNodes = function(pred) {
  var filtered = [];
  this.eachNode(function(u) {
    if (pred(u)) {
      filtered.push(u);
    }
  });
  return filtered;
};


},{"./BaseGraph":35,"./util":55,"cp-data":29}],39:[function(require,module,exports){
/*
 * This file is organized with in the following order:
 *
 * Exports
 * Graph constructors
 * Graph queries (e.g. nodes(), edges()
 * Graph mutators
 * Helper functions
 */

var util = require("./util"),
    BaseGraph = require("./BaseGraph"),
/* jshint -W079 */
    Set = require("cp-data").Set;
/* jshint +W079 */

module.exports = Graph;

/*
 * Constructor to create a new undirected multi-graph.
 */
function Graph() {
  BaseGraph.call(this);

  /*! Map of nodeId -> { otherNodeId -> Set of edge ids } */
  this._incidentEdges = {};
}

Graph.prototype = new BaseGraph();
Graph.prototype.constructor = Graph;

/*
 * Always returns `false`.
 */
Graph.prototype.isDirected = function() {
  return false;
};

/*
 * Returns all nodes that are adjacent to the node with the id `u`.
 *
 * @param {String} u a node id
 */
Graph.prototype.neighbors = function(u) {
  this._strictGetNode(u);
  return Object.keys(this._incidentEdges[u])
               .map(function(v) { return this._nodes[v].id; }, this);
};

/*
 * Returns an array of ids for all edges in the graph that are incident on `u`.
 * If the node `u` is not in the graph this function raises an Error.
 *
 * Optionally a `v` node may also be specified. This causes the results to be
 * filtered such that only edges between `u` and `v` are included. If the node
 * `v` is specified but not in the graph then this function raises an Error.
 *
 * @param {String} u the node for which to find incident edges
 * @param {String} [v] option node that must be adjacent to `u`
 */
Graph.prototype.incidentEdges = function(u, v) {
  this._strictGetNode(u);
  if (arguments.length > 1) {
    this._strictGetNode(v);
    return v in this._incidentEdges[u] ? this._incidentEdges[u][v].keys() : [];
  } else {
    return Set.union(util.values(this._incidentEdges[u])).keys();
  }
};

/*
 * Returns a string representation of this graph.
 */
Graph.prototype.toString = function() {
  return "Graph " + JSON.stringify(this, null, 2);
};

/*
 * Adds a new node with the id `u` to the graph and assigns it the value
 * `value`. If a node with the id is already a part of the graph this function
 * throws an Error.
 *
 * @param {String} u a node id
 * @param {Object} [value] an optional value to attach to the node
 */
Graph.prototype.addNode = function(u, value) {
  u = BaseGraph.prototype.addNode.call(this, u, value);
  this._incidentEdges[u] = {};
  return u;
};

/*
 * Removes a node from the graph that has the id `u`. Any edges incident on the
 * node are also removed. If the graph does not contain a node with the id this
 * function will throw an Error.
 *
 * @param {String} u a node id
 */
Graph.prototype.delNode = function(u) {
  BaseGraph.prototype.delNode.call(this, u);
  delete this._incidentEdges[u];
};

/*
 * Adds a new edge to the graph with the id `e` between a node with the id `u`
 * and a node with an id `v` and assigns it the value `value`. This graph
 * allows more than one edge between `u` and `v` as long as the id `e`
 * is unique in the set of edges. If `e` is `null` the graph will assign a
 * unique identifier to the edge.
 *
 * If `u` or `v` are not present in the graph this function will throw an
 * Error.
 *
 * @param {String} [e] an edge id
 * @param {String} u the node id of one of the adjacent nodes
 * @param {String} v the node id of the other adjacent node
 * @param {Object} [value] an optional value to attach to the edge
 */
Graph.prototype.addEdge = function(e, u, v, value) {
  return BaseGraph.prototype._addEdge.call(this, e, u, v, value,
                                           this._incidentEdges, this._incidentEdges);
};

/*
 * Removes an edge in the graph with the id `e`. If no edge in the graph has
 * the id `e` this function will throw an Error.
 *
 * @param {String} e an edge id
 */
Graph.prototype.delEdge = function(e) {
  BaseGraph.prototype._delEdge.call(this, e, this._incidentEdges, this._incidentEdges);
};


},{"./BaseGraph":35,"./util":55,"cp-data":29}],40:[function(require,module,exports){
/* jshint -W079 */
var Set = require("cp-data").Set;
/* jshint +W079 */

module.exports = components;

/**
 * Finds all [connected components][] in a graph and returns an array of these
 * components. Each component is itself an array that contains the ids of nodes
 * in the component.
 *
 * This function only works with undirected Graphs.
 *
 * [connected components]: http://en.wikipedia.org/wiki/Connected_component_(graph_theory)
 *
 * @param {Graph} g the graph to search for components
 */
function components(g) {
  var results = [];
  var visited = new Set();

  function dfs(v, component) {
    if (!visited.has(v)) {
      visited.add(v);
      component.push(v);
      g.neighbors(v).forEach(function(w) {
        dfs(w, component);
      });
    }
  }

  g.nodes().forEach(function(v) {
    var component = [];
    dfs(v, component);
    if (component.length > 0) {
      results.push(component);
    }
  });

  return results;
}

},{"cp-data":29}],41:[function(require,module,exports){
var PriorityQueue = require("cp-data").PriorityQueue;

module.exports = dijkstra;

/**
 * This function is an implementation of [Dijkstra's algorithm][] which finds
 * the shortest path from **source** to all other nodes in **g**. This
 * function returns a map of `u -> { distance, predecessor }`. The distance
 * property holds the sum of the weights from **source** to `u` along the
 * shortest path or `Number.POSITIVE_INFINITY` if there is no path from
 * **source**. The predecessor property can be used to walk the individual
 * elements of the path from **source** to **u** in reverse order.
 *
 * This function takes an optional `weightFunc(e)` which returns the
 * weight of the edge `e`. If no weightFunc is supplied then each edge is
 * assumed to have a weight of 1. This function throws an Error if any of
 * the traversed edges have a negative edge weight.
 *
 * This function takes an optional `incidentFunc(u)` which returns the ids of
 * all edges incident to the node `u` for the purposes of shortest path
 * traversal. By default this function uses the `g.outEdges` for Digraphs and
 * `g.incidentEdges` for Graphs.
 *
 * This function takes `O((|E| + |V|) * log |V|)` time.
 *
 * [Dijkstra's algorithm]: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
 *
 * @param {Graph} g the graph to search for shortest paths from **source**
 * @param {Object} source the source from which to start the search
 * @param {Function} [weightFunc] optional weight function
 * @param {Function} [incidentFunc] optional incident function
 */
function dijkstra(g, source, weightFunc, incidentFunc) {
  var results = {},
      pq = new PriorityQueue();

  function updateNeighbors(e) {
    var incidentNodes = g.incidentNodes(e),
        v = incidentNodes[0] !== u ? incidentNodes[0] : incidentNodes[1],
        vEntry = results[v],
        weight = weightFunc(e),
        distance = uEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + e + " Weight: " + weight);
    }

    if (distance < vEntry.distance) {
      vEntry.distance = distance;
      vEntry.predecessor = u;
      pq.decrease(v, distance);
    }
  }

  weightFunc = weightFunc || function() { return 1; };
  incidentFunc = incidentFunc || (g.isDirected()
      ? function(u) { return g.outEdges(u); }
      : function(u) { return g.incidentEdges(u); });

  g.eachNode(function(u) {
    var distance = u === source ? 0 : Number.POSITIVE_INFINITY;
    results[u] = { distance: distance };
    pq.add(u, distance);
  });

  var u, uEntry;
  while (pq.size() > 0) {
    u = pq.removeMin();
    uEntry = results[u];
    if (uEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    incidentFunc(u).forEach(updateNeighbors);
  }

  return results;
}

},{"cp-data":29}],42:[function(require,module,exports){
var dijkstra = require("./dijkstra");

module.exports = dijkstraAll;

/**
 * This function finds the shortest path from each node to every other
 * reachable node in the graph. It is similar to [alg.dijkstra][], but
 * instead of returning a single-source array, it returns a mapping of
 * of `source -> alg.dijksta(g, source, weightFunc, incidentFunc)`.
 *
 * This function takes an optional `weightFunc(e)` which returns the
 * weight of the edge `e`. If no weightFunc is supplied then each edge is
 * assumed to have a weight of 1. This function throws an Error if any of
 * the traversed edges have a negative edge weight.
 *
 * This function takes an optional `incidentFunc(u)` which returns the ids of
 * all edges incident to the node `u` for the purposes of shortest path
 * traversal. By default this function uses the `outEdges` function on the
 * supplied graph.
 *
 * This function takes `O(|V| * (|E| + |V|) * log |V|)` time.
 *
 * [alg.dijkstra]: dijkstra.js.html#dijkstra
 *
 * @param {Graph} g the graph to search for shortest paths from **source**
 * @param {Function} [weightFunc] optional weight function
 * @param {Function} [incidentFunc] optional incident function
 */
function dijkstraAll(g, weightFunc, incidentFunc) {
  var results = {};
  g.eachNode(function(u) {
    results[u] = dijkstra(g, u, weightFunc, incidentFunc);
  });
  return results;
}

},{"./dijkstra":41}],43:[function(require,module,exports){
var tarjan = require("./tarjan");

module.exports = findCycles;

/*
 * Given a Digraph **g** this function returns all nodes that are part of a
 * cycle. Since there may be more than one cycle in a graph this function
 * returns an array of these cycles, where each cycle is itself represented
 * by an array of ids for each node involved in that cycle.
 *
 * [alg.isAcyclic][] is more efficient if you only need to determine whether
 * a graph has a cycle or not.
 *
 * [alg.isAcyclic]: isAcyclic.js.html#isAcyclic
 *
 * @param {Digraph} g the graph to search for cycles.
 */
function findCycles(g) {
  return tarjan(g).filter(function(cmpt) { return cmpt.length > 1; });
}

},{"./tarjan":49}],44:[function(require,module,exports){
module.exports = floydWarshall;

/**
 * This function is an implementation of the [Floyd-Warshall algorithm][],
 * which finds the shortest path from each node to every other reachable node
 * in the graph. It is similar to [alg.dijkstraAll][], but it handles negative
 * edge weights and is more efficient for some types of graphs. This function
 * returns a map of `source -> { target -> { distance, predecessor }`. The
 * distance property holds the sum of the weights from `source` to `target`
 * along the shortest path of `Number.POSITIVE_INFINITY` if there is no path
 * from `source`. The predecessor property can be used to walk the individual
 * elements of the path from `source` to `target` in reverse order.
 *
 * This function takes an optional `weightFunc(e)` which returns the
 * weight of the edge `e`. If no weightFunc is supplied then each edge is
 * assumed to have a weight of 1.
 *
 * This function takes an optional `incidentFunc(u)` which returns the ids of
 * all edges incident to the node `u` for the purposes of shortest path
 * traversal. By default this function uses the `outEdges` function on the
 * supplied graph.
 *
 * This algorithm takes O(|V|^3) time.
 *
 * [Floyd-Warshall algorithm]: https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm
 * [alg.dijkstraAll]: dijkstraAll.js.html#dijkstraAll
 *
 * @param {Graph} g the graph to search for shortest paths from **source**
 * @param {Function} [weightFunc] optional weight function
 * @param {Function} [incidentFunc] optional incident function
 */
function floydWarshall(g, weightFunc, incidentFunc) {
  var results = {},
      nodes = g.nodes();

  weightFunc = weightFunc || function() { return 1; };
  incidentFunc = incidentFunc || (g.isDirected()
      ? function(u) { return g.outEdges(u); }
      : function(u) { return g.incidentEdges(u); });

  nodes.forEach(function(u) {
    results[u] = {};
    results[u][u] = { distance: 0 };
    nodes.forEach(function(v) {
      if (u !== v) {
        results[u][v] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    incidentFunc(u).forEach(function(e) {
      var incidentNodes = g.incidentNodes(e),
          v = incidentNodes[0] !== u ? incidentNodes[0] : incidentNodes[1],
          d = weightFunc(e);
      if (d < results[u][v].distance) {
        results[u][v] = { distance: d, predecessor: u };
      }
    });
  });

  nodes.forEach(function(k) {
    var rowK = results[k];
    nodes.forEach(function(i) {
      var rowI = results[i];
      nodes.forEach(function(j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });

  return results;
}

},{}],45:[function(require,module,exports){
var topsort = require("./topsort");

module.exports = isAcyclic;

/*
 * Given a Digraph **g** this function returns `true` if the graph has no
 * cycles and returns `false` if it does. This algorithm returns as soon as it
 * detects the first cycle.
 *
 * Use [alg.findCycles][] if you need the actual list of cycles in a graph.
 *
 * [alg.findCycles]: findCycles.js.html#findCycles
 *
 * @param {Digraph} g the graph to test for cycles
 */
function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) return false;
    throw e;
  }
  return true;
}

},{"./topsort":50}],46:[function(require,module,exports){
/* jshint -W079 */
var Set = require("cp-data").Set;
/* jshint +W079 */

module.exports = postorder;

// Postorder traversal of g, calling f for each visited node. Assumes the graph
// is a tree.
function postorder(g, root, f) {
  var visited = new Set();
  if (g.isDirected()) {
    throw new Error("This function only works for undirected graphs");
  }
  function dfs(u, prev) {
    if (visited.has(u)) {
      throw new Error("The input graph is not a tree: " + g);
    }
    visited.add(u);
    g.neighbors(u).forEach(function(v) {
      if (v !== prev) dfs(v, u);
    });
    f(u);
  }
  dfs(root);
}

},{"cp-data":29}],47:[function(require,module,exports){
/* jshint -W079 */
var Set = require("cp-data").Set;
/* jshint +W079 */

module.exports = preorder;

// Preorder traversal of g, calling f for each visited node. Assumes the graph
// is a tree.
function preorder(g, root, f) {
  var visited = new Set();
  if (g.isDirected()) {
    throw new Error("This function only works for undirected graphs");
  }
  function dfs(u, prev) {
    if (visited.has(u)) {
      throw new Error("The input graph is not a tree: " + g);
    }
    visited.add(u);
    f(u);
    g.neighbors(u).forEach(function(v) {
      if (v !== prev) dfs(v, u);
    });
  }
  dfs(root);
}

},{"cp-data":29}],48:[function(require,module,exports){
var Graph = require("../Graph"),
    PriorityQueue = require("cp-data").PriorityQueue;

module.exports = prim;

/**
 * [Prim's algorithm][] takes a connected undirected graph and generates a
 * [minimum spanning tree][]. This function returns the minimum spanning
 * tree as an undirected graph. This algorithm is derived from the description
 * in "Introduction to Algorithms", Third Edition, Cormen, et al., Pg 634.
 *
 * This function takes a `weightFunc(e)` which returns the weight of the edge
 * `e`. It throws an Error if the graph is not connected.
 *
 * This function takes `O(|E| log |V|)` time.
 *
 * [Prim's algorithm]: https://en.wikipedia.org/wiki/Prim's_algorithm
 * [minimum spanning tree]: https://en.wikipedia.org/wiki/Minimum_spanning_tree
 *
 * @param {Graph} g the graph used to generate the minimum spanning tree
 * @param {Function} weightFunc the weight function to use
 */
function prim(g, weightFunc) {
  var result = new Graph(),
      parents = {},
      pq = new PriorityQueue(),
      u;

  function updateNeighbors(e) {
    var incidentNodes = g.incidentNodes(e),
        v = incidentNodes[0] !== u ? incidentNodes[0] : incidentNodes[1],
        pri = pq.priority(v);
    if (pri !== undefined) {
      var edgeWeight = weightFunc(e);
      if (edgeWeight < pri) {
        parents[v] = u;
        pq.decrease(v, edgeWeight);
      }
    }
  }

  if (g.order() === 0) {
    return result;
  }

  g.eachNode(function(u) {
    pq.add(u, Number.POSITIVE_INFINITY);
    result.addNode(u);
  });

  // Start from an arbitrary node
  pq.decrease(g.nodes()[0], 0);

  var init = false;
  while (pq.size() > 0) {
    u = pq.removeMin();
    if (u in parents) {
      result.addEdge(null, u, parents[u]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.incidentEdges(u).forEach(updateNeighbors);
  }

  return result;
}

},{"../Graph":39,"cp-data":29}],49:[function(require,module,exports){
module.exports = tarjan;

/**
 * This function is an implementation of [Tarjan's algorithm][] which finds
 * all [strongly connected components][] in the directed graph **g**. Each
 * strongly connected component is composed of nodes that can reach all other
 * nodes in the component via directed edges. A strongly connected component
 * can consist of a single node if that node cannot both reach and be reached
 * by any other specific node in the graph. Components of more than one node
 * are guaranteed to have at least one cycle.
 *
 * This function returns an array of components. Each component is itself an
 * array that contains the ids of all nodes in the component.
 *
 * [Tarjan's algorithm]: http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm
 * [strongly connected components]: http://en.wikipedia.org/wiki/Strongly_connected_component
 *
 * @param {Digraph} g the graph to search for strongly connected components
 */
function tarjan(g) {
  if (!g.isDirected()) {
    throw new Error("tarjan can only be applied to a directed graph. Bad input: " + g);
  }

  var index = 0,
      stack = [],
      visited = {}, // node id -> { onStack, lowlink, index }
      results = [];

  function dfs(u) {
    var entry = visited[u] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(u);

    g.successors(u).forEach(function(v) {
      if (!(v in visited)) {
        dfs(v);
        entry.lowlink = Math.min(entry.lowlink, visited[v].lowlink);
      } else if (visited[v].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[v].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [],
          v;
      do {
        v = stack.pop();
        visited[v].onStack = false;
        cmpt.push(v);
      } while (u !== v);
      results.push(cmpt);
    }
  }

  g.nodes().forEach(function(u) {
    if (!(u in visited)) {
      dfs(u);
    }
  });

  return results;
}

},{}],50:[function(require,module,exports){
module.exports = topsort;
topsort.CycleException = CycleException;

/*
 * Given a graph **g**, this function returns an ordered list of nodes such
 * that for each edge `u -> v`, `u` appears before `v` in the list. If the
 * graph has a cycle it is impossible to generate such a list and
 * **CycleException** is thrown.
 *
 * See [topological sorting](https://en.wikipedia.org/wiki/Topological_sorting)
 * for more details about how this algorithm works.
 *
 * @param {Digraph} g the graph to sort
 */
function topsort(g) {
  if (!g.isDirected()) {
    throw new Error("topsort can only be applied to a directed graph. Bad input: " + g);
  }

  var visited = {};
  var stack = {};
  var results = [];

  function visit(node) {
    if (node in stack) {
      throw new CycleException();
    }

    if (!(node in visited)) {
      stack[node] = true;
      visited[node] = true;
      g.predecessors(node).forEach(function(pred) {
        visit(pred);
      });
      delete stack[node];
      results.push(node);
    }
  }

  var sinks = g.sinks();
  if (g.order() !== 0 && sinks.length === 0) {
    throw new CycleException();
  }

  g.sinks().forEach(function(sink) {
    visit(sink);
  });

  return results;
}

function CycleException() {}

CycleException.prototype.toString = function() {
  return "Graph has at least one cycle";
};

},{}],51:[function(require,module,exports){
// This file provides a helper function that mixes-in Dot behavior to an
// existing graph prototype.

/* jshint -W079 */
var Set = require("cp-data").Set;
/* jshint +W079 */

module.exports = compoundify;

// Extends the given SuperConstructor with the ability for nodes to contain
// other nodes. A special node id `null` is used to indicate the root graph.
function compoundify(SuperConstructor) {
  function Constructor() {
    SuperConstructor.call(this);

    // Map of object id -> parent id (or null for root graph)
    this._parents = {};

    // Map of id (or null) -> children set
    this._children = {};
    this._children[null] = new Set();
  }

  Constructor.prototype = new SuperConstructor();
  Constructor.prototype.constructor = Constructor;

  Constructor.prototype.parent = function(u, parent) {
    this._strictGetNode(u);

    if (arguments.length < 2) {
      return this._parents[u];
    }

    if (u === parent) {
      throw new Error("Cannot make " + u + " a parent of itself");
    }
    if (parent !== null) {
      this._strictGetNode(parent);
    }

    this._children[this._parents[u]].remove(u);
    this._parents[u] = parent;
    this._children[parent].add(u);
  };

  Constructor.prototype.children = function(u) {
    if (u !== null) {
      this._strictGetNode(u);
    }
    return this._children[u].keys();
  };

  Constructor.prototype.addNode = function(u, value) {
    u = SuperConstructor.prototype.addNode.call(this, u, value);
    this._parents[u] = null;
    this._children[u] = new Set();
    this._children[null].add(u);
    return u;
  };

  Constructor.prototype.delNode = function(u) {
    // Promote all children to the parent of the subgraph
    var parent = this.parent(u);
    this._children[u].keys().forEach(function(child) {
      this.parent(child, parent);
    }, this);

    this._children[parent].remove(u);
    delete this._parents[u];
    delete this._children[u];

    return SuperConstructor.prototype.delNode.call(this, u);
  };

  Constructor.prototype.copy = function() {
    var copy = SuperConstructor.prototype.copy.call(this);
    this.nodes().forEach(function(u) {
      copy.parent(u, this.parent(u));
    }, this);
    return copy;
  };

  Constructor.prototype.filterNodes = function(filter) {
    var self = this,
        copy = SuperConstructor.prototype.filterNodes.call(this, filter);

    var parents = {};
    function findParent(u) {
      var parent = self.parent(u);
      if (parent === null || copy.hasNode(parent)) {
        parents[u] = parent;
        return parent;
      } else if (parent in parents) {
        return parents[parent];
      } else {
        return findParent(parent);
      }
    }

    copy.eachNode(function(u) { copy.parent(u, findParent(u)); });

    return copy;
  };

  return Constructor;
}

},{"cp-data":29}],52:[function(require,module,exports){
var Graph = require("../Graph"),
    Digraph = require("../Digraph"),
    CGraph = require("../CGraph"),
    CDigraph = require("../CDigraph");

exports.decode = function(nodes, edges, Ctor) {
  Ctor = Ctor || Digraph;

  if (typeOf(nodes) !== "Array") {
    throw new Error("nodes is not an Array");
  }

  if (typeOf(edges) !== "Array") {
    throw new Error("edges is not an Array");
  }

  if (typeof Ctor === "string") {
    switch(Ctor) {
      case "graph": Ctor = Graph; break;
      case "digraph": Ctor = Digraph; break;
      case "cgraph": Ctor = CGraph; break;
      case "cdigraph": Ctor = CDigraph; break;
      default: throw new Error("Unrecognized graph type: " + Ctor);
    }
  }

  var graph = new Ctor();

  nodes.forEach(function(u) {
    graph.addNode(u.id, u.value);
  });

  // If the graph is compound, set up children...
  if (graph.parent) {
    nodes.forEach(function(u) {
      if (u.children) {
        u.children.forEach(function(v) {
          graph.parent(v, u.id);
        });
      }
    });
  }

  edges.forEach(function(e) {
    graph.addEdge(e.id, e.u, e.v, e.value);
  });

  return graph;
};

exports.encode = function(graph) {
  var nodes = [];
  var edges = [];

  graph.eachNode(function(u, value) {
    var node = {id: u, value: value};
    if (graph.children) {
      var children = graph.children(u);
      if (children.length) {
        node.children = children;
      }
    }
    nodes.push(node);
  });

  graph.eachEdge(function(e, u, v, value) {
    edges.push({id: e, u: u, v: v, value: value});
  });

  var type;
  if (graph instanceof CDigraph) {
    type = "cdigraph";
  } else if (graph instanceof CGraph) {
    type = "cgraph";
  } else if (graph instanceof Digraph) {
    type = "digraph";
  } else if (graph instanceof Graph) {
    type = "graph";
  } else {
    throw new Error("Couldn't determine type of graph: " + graph);
  }

  return { nodes: nodes, edges: edges, type: type };
};

function typeOf(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1);
}

},{"../CDigraph":36,"../CGraph":37,"../Digraph":38,"../Graph":39}],53:[function(require,module,exports){
/* jshint -W079 */
var Set = require("cp-data").Set;
/* jshint +W079 */

exports.all = function() {
  return function() { return true; };
};

exports.nodesFromList = function(nodes) {
  var set = new Set(nodes);
  return function(u) {
    return set.has(u);
  };
};

},{"cp-data":29}],54:[function(require,module,exports){
var Graph = require("./Graph"),
    Digraph = require("./Digraph");

// Side-effect based changes are lousy, but node doesn't seem to resolve the
// requires cycle.

/**
 * Returns a new directed graph using the nodes and edges from this graph. The
 * new graph will have the same nodes, but will have twice the number of edges:
 * each edge is split into two edges with opposite directions. Edge ids,
 * consequently, are not preserved by this transformation.
 */
Graph.prototype.toDigraph =
Graph.prototype.asDirected = function() {
  var g = new Digraph();
  this.eachNode(function(u, value) { g.addNode(u, value); });
  this.eachEdge(function(e, u, v, value) {
    g.addEdge(null, u, v, value);
    g.addEdge(null, v, u, value);
  });
  return g;
};

/**
 * Returns a new undirected graph using the nodes and edges from this graph.
 * The new graph will have the same nodes, but the edges will be made
 * undirected. Edge ids are preserved in this transformation.
 */
Digraph.prototype.toGraph =
Digraph.prototype.asUndirected = function() {
  var g = new Graph();
  this.eachNode(function(u, value) { g.addNode(u, value); });
  this.eachEdge(function(e, u, v, value) {
    g.addEdge(e, u, v, value);
  });
  return g;
};

},{"./Digraph":38,"./Graph":39}],55:[function(require,module,exports){
// Returns an array of all values for properties of **o**.
exports.values = function(o) {
  var ks = Object.keys(o),
      len = ks.length,
      result = new Array(len),
      i;
  for (i = 0; i < len; ++i) {
    result[i] = o[ks[i]];
  }
  return result;
};

},{}],56:[function(require,module,exports){
module.exports = '0.7.4';

},{}],57:[function(require,module,exports){
void function(){
  'use strict'
  module.exports = function(fn){
    return function(){
      return fn.bind(null, this).apply(null, arguments)
   }
  }
}()

},{}],58:[function(require,module,exports){
var domify = require('domify');

module.exports = hyperglue;
function hyperglue (src, updates) {
    if (!updates) updates = {};

    var dom = typeof src === 'object'
        ? [ src ]
        : domify(src)
    ;
    forEach(objectKeys(updates), function (selector) {
        var value = updates[selector];
        forEach(dom, function (d) {
            if (selector === ':first') {
                bind(d, value);
            }
            else if (/:first$/.test(selector)) {
                var k = selector.replace(/:first$/, '');
                var elem = d.querySelector(k);
                if (elem) bind(elem, value);
            }
            else {
                var nodes = d.querySelectorAll(selector);
                if (nodes.length === 0) return;
                for (var i = 0; i < nodes.length; i++) {
                    bind(nodes[i], value);
                }
            }
        });
    });

    return dom.length === 1
        ? dom[0]
        : dom
    ;
}

function bind (node, value) {
    if (isElement(value)) {
        node.innerHTML = '';
        node.appendChild(value);
    }
    else if (isArray(value)) {
        for (var i = 0; i < value.length; i++) {
            var e = hyperglue(node.cloneNode(true), value[i]);
            node.parentNode.insertBefore(e, node);
        }
        node.parentNode.removeChild(node);
    }
    else if (value && typeof value === 'object') {
        forEach(objectKeys(value), function (key) {
            if (key === '_text') {
                setText(node, value[key]);
            }
            else if (key === '_html' && isElement(value[key])) {
                node.innerHTML = '';
                node.appendChild(value[key]);
            }
            else if (key === '_html') {
                node.innerHTML = value[key];
            }
            else node.setAttribute(key, value[key]);
        });
    }
    else setText(node, value);
}

function forEach(xs, f) {
    if (xs.forEach) return xs.forEach(f);
    for (var i = 0; i < xs.length; i++) f(xs[i], i)
}

var objectKeys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

function isElement (e) {
    return e && typeof e === 'object' && e.childNodes
        && (typeof e.appendChild === 'function'
        || typeof e.appendChild === 'object')
    ;
}

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

function setText (e, s) {
    e.innerHTML = '';
    var txt = document.createTextNode(String(s));
    e.appendChild(txt);
}

},{"domify":59}],59:[function(require,module,exports){

/**
 * Expose `parse`.
 */

module.exports = parse;

/**
 * Wrap map from jquery.
 */

var map = {
  option: [1, '<select multiple="multiple">', '</select>'],
  optgroup: [1, '<select multiple="multiple">', '</select>'],
  legend: [1, '<fieldset>', '</fieldset>'],
  thead: [1, '<table>', '</table>'],
  tbody: [1, '<table>', '</table>'],
  tfoot: [1, '<table>', '</table>'],
  colgroup: [1, '<table>', '</table>'],
  caption: [1, '<table>', '</table>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],
  th: [3, '<table><tbody><tr>', '</tr></tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  _default: [0, '', '']
};

/**
 * Parse `html` and return the children.
 *
 * @param {String} html
 * @return {Array}
 * @api private
 */

function parse(html) {
  if ('string' != typeof html) throw new TypeError('String expected');
  
  // tag name
  var m = /<([\w:]+)/.exec(html);
  if (!m) throw new Error('No elements were generated.');
  var tag = m[1];
  
  // body support
  if (tag == 'body') {
    var el = document.createElement('html');
    el.innerHTML = html;
    return [el.removeChild(el.lastChild)];
  }
  
  // wrap map
  var wrap = map[tag] || map._default;
  var depth = wrap[0];
  var prefix = wrap[1];
  var suffix = wrap[2];
  var el = document.createElement('div');
  el.innerHTML = prefix + html + suffix;
  while (depth--) el = el.lastChild;

  return orphan(el.children);
}

/**
 * Orphan `els` and return an array.
 *
 * @param {NodeList} els
 * @return {Array}
 * @api private
 */

function orphan(els) {
  var ret = [];

  while (els.length) {
    ret.push(els[0].parentNode.removeChild(els[0]));
  }

  return ret;
}

},{}],60:[function(require,module,exports){
var dictionary = {
  words: [
    'ad',
    'adipisicing',
    'aliqua',
    'aliquip',
    'amet',
    'anim',
    'aute',
    'cillum',
    'commodo',
    'consectetur',
    'consequat',
    'culpa',
    'cupidatat',
    'deserunt',
    'do',
    'dolor',
    'dolore',
    'duis',
    'ea',
    'eiusmod',
    'elit',
    'enim',
    'esse',
    'est',
    'et',
    'eu',
    'ex',
    'excepteur',
    'exercitation',
    'fugiat',
    'id',
    'in',
    'incididunt',
    'ipsum',
    'irure',
    'labore',
    'laboris',
    'laborum',
    'Lorem',
    'magna',
    'minim',
    'mollit',
    'nisi',
    'non',
    'nostrud',
    'nulla',
    'occaecat',
    'officia',
    'pariatur',
    'proident',
    'qui',
    'quis',
    'reprehenderit',
    'sint',
    'sit',
    'sunt',
    'tempor',
    'ullamco',
    'ut',
    'velit',
    'veniam',
    'voluptate'  
  ]
};

module.exports = dictionary;
},{}],61:[function(require,module,exports){
var generator = function() {
  var options = (arguments.length) ? arguments[0] : {}
    , count = options.count || 1
    , units = options.units || 'sentences'
    , sentenceLowerBound = options.sentenceLowerBound || 5
    , sentenceUpperBound = options.sentenceUpperBound || 15
	  , paragraphLowerBound = options.paragraphLowerBound || 3
	  , paragraphUpperBound = options.paragraphUpperBound || 7
	  , format = options.format || 'plain'
    , words = options.words || require('./dictionary').words
    , random = options.random || Math.random;

  units = simplePluralize(units.toLowerCase());

  var randomInteger = function(min, max) {
    return Math.floor(random() * (max - min + 1) + min);
  };
  
  var randomWord = function(words) {
    return words[randomInteger(0, words.length - 1)];
  };
  
  var randomSentence = function(words, lowerBound, upperBound) {
    var sentence = ''
      , bounds = {min: 0, max: randomInteger(lowerBound, upperBound)};
    
    while (bounds.min < bounds.max) {
      sentence = sentence + ' ' + randomWord(words);
      bounds.min = bounds.min + 1;
    }
    
    if (sentence.length) {
      sentence = sentence.slice(1);
      sentence = sentence.charAt(0).toUpperCase() + sentence.slice(1);
    }
  
    return sentence;
  };

  var randomParagraph = function(words, lowerBound, upperBound, sentenceLowerBound, sentenceUpperBound) {
    var paragraph = ''
      , bounds = {min: 0, max: randomInteger(lowerBound, upperBound)};
      
    while (bounds.min < bounds.max) {
      paragraph = paragraph + '. ' + randomSentence(words, sentenceLowerBound, sentenceUpperBound);
      bounds.min = bounds.min + 1;
    }
    
    if (paragraph.length) {
      paragraph = paragraph.slice(2);
      paragraph = paragraph + '.';
    }
    
    return paragraph;
  }
  
  var iter = 0
    , bounds = {min: 0, max: count}
    , string = ''
    , prefix = ''
    , suffix = "\r\n";

  if (format == 'html') {
    prefix = '<p>';
    suffix = '</p>';
  }
      
  while (bounds.min < bounds.max) {
    switch (units.toLowerCase()) {
      case 'words':
        string = string + ' ' + randomWord(words);
        break;
      case 'sentences':
        string = string + '. ' + randomSentence(words, sentenceLowerBound, sentenceUpperBound);
        break;
      case 'paragraphs':
        string = string + prefix + randomParagraph(words, paragraphLowerBound, paragraphUpperBound, sentenceLowerBound, sentenceUpperBound) + suffix;
        break;
    }
    bounds.min = bounds.min + 1;
  }
    
  if (string.length) {
    var pos = 0;
    
    if (string.indexOf('. ') == 0) {
      pos = 2;
    } else if (string.indexOf('.') == 0 || string.indexOf(' ') == 0) {
      pos = 1;
    }
    
    string = string.slice(pos);
    
    if (units == 'sentences') {
      string = string + '.';
    }
  }  
  
  return string;
};

function simplePluralize(string) {
  if (string.indexOf('s', string.length - 1) === -1) {
    return string + 's';
  }
  return string;
}

module.exports = generator;

},{"./dictionary":60}],62:[function(require,module,exports){
void function(root){

  function defaults(options){
    var options = options || {}
    var min = options.min
    var max = options.max
    var integer = options.integer || false
    if ( min == null && max == null ) {
      min = 0
      max = 1
    } else if ( min == null ) {
      min = max - 1
    } else if ( max == null ) {
      max = min + 1
    }
    if ( max < min ) throw new Error('invalid options, max must be >= min')
    return {
      min:     min
    , max:     max
    , integer: integer
    }
  }

  function random(options){
    options = defaults(options)
    if ( options.max === options.min ) return options.min
    var r = Math.random() * (options.max - options.min + Number(!!options.integer)) + options.min
    return options.integer ? Math.floor(r) : r
  }

  function generator(options){
    options = defaults(options)
    return function(min, max, integer){
      options.min     = min     || options.min
      options.max     = max     || options.max
      options.integer = integer != null ? integer : options.integer
      return random(options)
    }
  }

  module.exports =  random
  module.exports.generator = generator
  module.exports.defaults = defaults
}(this)

},{}],63:[function(require,module,exports){
void function(root){

    // return a number between 0 and max-1
    function r(max){ return Math.floor(Math.random()*max) }

    function generate(salt, size){
        var key = ''
        var sl = salt.length
        while ( size -- ) {
            var rnd = r(sl)
            key += salt[rnd]
        }
        return key
    }

    var rndtok = function(salt, size){
        return isNaN(size) ? undefined :
               size < 1    ? undefined : generate(salt, size)

    }

    rndtok.gen = createGenerator

    function createGenerator(salt){
        salt = typeof salt  == 'string' && salt.length > 0 ? salt :  'abcdefghijklmnopqrstuvwxzy0123456789'
        var temp = rndtok.bind(rndtok, salt)
        temp.salt = function(){ return salt }
        temp.create = createGenerator
        temp.gen = createGenerator
        return temp
    }

    module.exports = createGenerator()

}(this)

},{}],64:[function(require,module,exports){
// Snap.svg 0.2.0
//
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// build: 2014-02-08
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\

(function (glob) {
    var version = "0.4.2",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners
    \*/
        eve = function (name, scope) {
			name = String(name);
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out.length ? out : null;
        };
		// Undocumented. Debug only.
		eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };

    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt()` function will be called before `eatIt()`.
	 *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
    \*/
    eve.on = function (name, f) {
		name = String(name);
		if (typeof f != "function") {
			return function () {};
		}
        var names = name.split(separator),
            e = events;
        for (var i = 0, ii = names.length; i < ii; i++) {
            e = e.n;
            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
        }
        e.f = e.f || [];
        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
            return fun;
        }
        e.f.push(f);
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
	 * Arguments that will be passed to the result function will be also
	 * concated to the list of final arguments.
 	 | el.onclick = eve.f("click", 1, 2);
 	 | eve.on("click", function (a, b, c) {
 	 |     console.log(a, b, c); // 1, 2, [event object]
 	 | });
     > Arguments
	 - event (string) event name
	 - varargs (…) and any other arguments
	 = (function) possible event handler function
    \*/
	eve.f = function (event) {
		var attrs = [].slice.call(arguments, 1);
		return function () {
			eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
		};
	};
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
    \*/
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
	 * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
		if (!name) {
		    eve._events = events = {n: {}};
			return;
		}
        var names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.unbind(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : (typeof define != "undefined" ? (define("eve", [], function() { return eve; })) : (glob.eve = eve));
})(this);

(function (glob, factory) {
    // AMD support
    if (typeof define === "function" && define.amd) {
        // Define as an anonymous module
        define(["eve"], function( eve ) {
            return factory(glob, eve);
        });
    } else if (typeof exports !== 'undefined') {
        // Next for Node.js or CommonJS
        var eve = require('eve');
        module.exports = factory(glob, eve);
    } else {
        // Browser globals (glob is window)
        // Snap adds itself to window
        factory(glob, glob.eve);
    }
}(window || this, function (window, eve) {

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var mina = (function (eve) {
    var animations = {},
    requestAnimFrame = window.requestAnimationFrame       ||
                       window.webkitRequestAnimationFrame ||
                       window.mozRequestAnimationFrame    ||
                       window.oRequestAnimationFrame      ||
                       window.msRequestAnimationFrame     ||
                       function (callback) {
                           setTimeout(callback, 16);
                       },
    isArray = Array.isArray || function (a) {
        return a instanceof Array ||
            Object.prototype.toString.call(a) == "[object Array]";
    },
    idgen = 0,
    idprefix = "M" + (+new Date).toString(36),
    ID = function () {
        return idprefix + (idgen++).toString(36);
    },
    diff = function (a, b, A, B) {
        if (isArray(a)) {
            res = [];
            for (var i = 0, ii = a.length; i < ii; i++) {
                res[i] = diff(a[i], b, A[i], B);
            }
            return res;
        }
        var dif = (A - a) / (B - b);
        return function (bb) {
            return a + dif * (bb - b);
        };
    },
    timer = Date.now || function () {
        return +new Date;
    },
    sta = function (val) {
        var a = this;
        if (val == null) {
            return a.s;
        }
        var ds = a.s - val;
        a.b += a.dur * ds;
        a.B += a.dur * ds;
        a.s = val;
    },
    speed = function (val) {
        var a = this;
        if (val == null) {
            return a.spd;
        }
        a.spd = val;
    },
    duration = function (val) {
        var a = this;
        if (val == null) {
            return a.dur;
        }
        a.s = a.s * val / a.dur;
        a.dur = val;
    },
    stopit = function () {
        var a = this;
        delete animations[a.id];
        eve("mina.stop." + a.id, a);
    },
    pause = function () {
        var a = this;
        if (a.pdif) {
            return;
        }
        delete animations[a.id];
        a.pdif = a.get() - a.b;
    },
    resume = function () {
        var a = this;
        if (!a.pdif) {
            return;
        }
        a.b = a.get() - a.pdif;
        delete a.pdif;
        animations[a.id] = a;
    },
    frame = function () {
        var len = 0;
        for (var i in animations) if (animations.hasOwnProperty(i)) {
            var a = animations[i],
                b = a.get(),
                res;
            len++;
            a.s = (b - a.b) / (a.dur / a.spd);
            if (a.s >= 1) {
                delete animations[i];
                a.s = 1;
                len--;
                (function (a) {
                    setTimeout(function () {
                        eve("mina.finish." + a.id, a);
                    });
                }(a));
            }
            if (isArray(a.start)) {
                res = [];
                for (var j = 0, jj = a.start.length; j < jj; j++) {
                    res[j] = +a.start[j] +
                        (a.end[j] - a.start[j]) * a.easing(a.s);
                }
            } else {
                res = +a.start + (a.end - a.start) * a.easing(a.s);
            }
            a.set(res);
        }
        len && requestAnimFrame(frame);
    },
    // SIERRA Unfamiliar with the word _slave_ in this context. Also, I don't know what _gereal_ means. Do you mean _general_?
    /*\
     * mina
     [ method ]
     **
     * Generic animation of numbers
     **
     - a (number) start _slave_ number
     - A (number) end _slave_ number
     - b (number) start _master_ number (start time in general case)
     - B (number) end _master_ number (end time in gereal case)
     - get (function) getter of _master_ number (see @mina.time)
     - set (function) setter of _slave_ number
     - easing (function) #optional easing function, default is @mina.linear
     = (object) animation descriptor
     o {
     o         id (string) animation id,
     o         start (number) start _slave_ number,
     o         end (number) end _slave_ number,
     o         b (number) start _master_ number,
     o         s (number) animation status (0..1),
     o         dur (number) animation duration,
     o         spd (number) animation speed,
     o         get (function) getter of _master_ number (see @mina.time),
     o         set (function) setter of _slave_ number,
     o         easing (function) easing function, default is @mina.linear,
     o         status (function) status getter/setter,
     o         speed (function) speed getter/setter,
     o         duration (function) duration getter/setter,
     o         stop (function) animation stopper
     o }
    \*/
    mina = function (a, A, b, B, get, set, easing) {
        var anim = {
            id: ID(),
            start: a,
            end: A,
            b: b,
            s: 0,
            dur: B - b,
            spd: 1,
            get: get,
            set: set,
            easing: easing || mina.linear,
            status: sta,
            speed: speed,
            duration: duration,
            stop: stopit,
            pause: pause,
            resume: resume
        };
        animations[anim.id] = anim;
        var len = 0, i;
        for (i in animations) if (animations.hasOwnProperty(i)) {
            len++;
            if (len == 2) {
                break;
            }
        }
        len == 1 && requestAnimFrame(frame);
        return anim;
    };
    /*\
     * mina.time
     [ method ]
     **
     * Returns the current time. Equivalent to:
     | function () {
     |     return (new Date).getTime();
     | }
    \*/
    mina.time = timer;
    /*\
     * mina.getById
     [ method ]
     **
     * Returns an animation by its id
     - id (string) animation's id
     = (object) See @mina
    \*/
    mina.getById = function (id) {
        return animations[id] || null;
    };

    /*\
     * mina.linear
     [ method ]
     **
     * Default linear easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.linear = function (n) {
        return n;
    };
    /*\
     * mina.easeout
     [ method ]
     **
     * Easeout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easeout = function (n) {
        return Math.pow(n, 1.7);
    };
    /*\
     * mina.easein
     [ method ]
     **
     * Easein easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easein = function (n) {
        return Math.pow(n, .48);
    };
    /*\
     * mina.easeinout
     [ method ]
     **
     * Easeinout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easeinout = function (n) {
        if (n == 1) {
            return 1;
        }
        if (n == 0) {
            return 0;
        }
        var q = .48 - n / 1.04,
            Q = Math.sqrt(.1734 + q * q),
            x = Q - q,
            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
            y = -Q - q,
            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
            t = X + Y + .5;
        return (1 - t) * 3 * t * t + t * t * t;
    };
    /*\
     * mina.backin
     [ method ]
     **
     * Backin easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.backin = function (n) {
        if (n == 1) {
            return 1;
        }
        var s = 1.70158;
        return n * n * ((s + 1) * n - s);
    };
    /*\
     * mina.backout
     [ method ]
     **
     * Backout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.backout = function (n) {
        if (n == 0) {
            return 0;
        }
        n = n - 1;
        var s = 1.70158;
        return n * n * ((s + 1) * n + s) + 1;
    };
    /*\
     * mina.elastic
     [ method ]
     **
     * Elastic easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.elastic = function (n) {
        if (n == !!n) {
            return n;
        }
        return Math.pow(2, -10 * n) * Math.sin((n - .075) *
            (2 * Math.PI) / .3) + 1;
    };
    /*\
     * mina.bounce
     [ method ]
     **
     * Bounce easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.bounce = function (n) {
        var s = 7.5625,
            p = 2.75,
            l;
        if (n < (1 / p)) {
            l = s * n * n;
        } else {
            if (n < (2 / p)) {
                n -= (1.5 / p);
                l = s * n * n + .75;
            } else {
                if (n < (2.5 / p)) {
                    n -= (2.25 / p);
                    l = s * n * n + .9375;
                } else {
                    n -= (2.625 / p);
                    l = s * n * n + .984375;
                }
            }
        }
        return l;
    };
    window.mina = mina;
    return mina;
})(typeof eve == "undefined" ? function () {} : eve);
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var Snap = (function(root) {
Snap.version = "0.2.0";
/*\
 * Snap
 [ method ]
 **
 * Creates a drawing surface or wraps existing SVG element.
 **
 - width (number|string) width of surface
 - height (number|string) height of surface
 * or
 - DOM (SVGElement) element to be wrapped into Snap structure
 * or
 - query (string) CSS query selector
 = (object) @Element
\*/
function Snap(w, h) {
    if (w) {
        if (w.tagName) {
            return wrap(w);
        }
        if (w instanceof Element) {
            return w;
        }
        if (h == null) {
            w = glob.doc.querySelector(w);
            return wrap(w);
        }
    }
    w = w == null ? "100%" : w;
    h = h == null ? "100%" : h;
    return new Paper(w, h);
}
Snap.toString = function () {
    return "Snap v" + this.version;
};
Snap._ = {};
var glob = {
    win: root.window,
    doc: root.window.document
};
Snap._.glob = glob;
var has = "hasOwnProperty",
    Str = String,
    toFloat = parseFloat,
    toInt = parseInt,
    math = Math,
    mmax = math.max,
    mmin = math.min,
    abs = math.abs,
    pow = math.pow,
    PI = math.PI,
    round = math.round,
    E = "",
    S = " ",
    objectToString = Object.prototype.toString,
    ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
    reURLValue = /^url\(#?([^)]+)\)$/,
    spaces = "\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029",
    separator = new RegExp("[," + spaces + "]+"),
    whitespace = new RegExp("[" + spaces + "]", "g"),
    commaSpaces = new RegExp("[" + spaces + "]*,[" + spaces + "]*"),
    hsrg = {hs: 1, rg: 1},
    pathCommand = new RegExp("([a-z])[" + spaces + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + spaces + "]*,?[" + spaces + "]*)+)", "ig"),
    tCommand = new RegExp("([rstm])[" + spaces + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + spaces + "]*,?[" + spaces + "]*)+)", "ig"),
    pathValues = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + spaces + "]*,?[" + spaces + "]*", "ig"),
    idgen = 0,
    idprefix = "S" + (+new Date).toString(36),
    ID = function () {
        return idprefix + (idgen++).toString(36);
    },
    xlink = "http://www.w3.org/1999/xlink",
    xmlns = "http://www.w3.org/2000/svg",
    hub = {},
    URL = Snap.url = function (url) {
        return "url('#" + url + "')";
    };

function $(el, attr) {
    if (attr) {
        if (typeof el == "string") {
            el = $(el);
        }
        if (typeof attr == "string") {
            if (attr.substring(0, 6) == "xlink:") {
                return el.getAttributeNS(xlink, attr.substring(6));
            }
            if (attr.substring(0, 4) == "xml:") {
                return el.getAttributeNS(xmlns, attr.substring(4));
            }
            return el.getAttribute(attr);
        }
        for (var key in attr) if (attr[has](key)) {
            var val = Str(attr[key]);
            if (val) {
                if (key.substring(0, 6) == "xlink:") {
                    el.setAttributeNS(xlink, key.substring(6), val);
                } else if (key.substring(0, 4) == "xml:") {
                    el.setAttributeNS(xmlns, key.substring(4), val);
                } else {
                    el.setAttribute(key, val);
                }
            } else {
                el.removeAttribute(key);
            }
        }
    } else {
        el = glob.doc.createElementNS(xmlns, el);
        // el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
    }
    return el;
}
Snap._.$ = $;
Snap._.id = ID;
function getAttrs(el) {
    var attrs = el.attributes,
        name,
        out = {};
    for (var i = 0; i < attrs.length; i++) {
        if (attrs[i].namespaceURI == xlink) {
            name = "xlink:";
        } else {
            name = "";
        }
        name += attrs[i].name;
        out[name] = attrs[i].textContent;
    }
    return out;
}
function is(o, type) {
    type = Str.prototype.toLowerCase.call(type);
    if (type == "finite") {
        return isFinite(o);
    }
    if (type == "array" &&
        (o instanceof Array || Array.isArray && Array.isArray(o))) {
        return true;
    }
    return  (type == "null" && o === null) ||
            (type == typeof o && o !== null) ||
            (type == "object" && o === Object(o)) ||
            objectToString.call(o).slice(8, -1).toLowerCase() == type;
}
/*\
 * Snap.format
 [ method ]
 **
 * Replaces construction of type `{<name>}` to the corresponding argument
 **
 - token (string) string to format
 - json (object) object which properties are used as a replacement
 = (string) formatted string
 > Usage
 | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
 | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
 |     x: 10,
 |     y: 20,
 |     dim: {
 |         width: 40,
 |         height: 50,
 |         "negative width": -40
 |     }
 | }));
\*/
Snap.format = (function () {
    var tokenRegex = /\{([^\}]+)\}/g,
        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
        replacer = function (all, key, obj) {
            var res = obj;
            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                name = name || quotedName;
                if (res) {
                    if (name in res) {
                        res = res[name];
                    }
                    typeof res == "function" && isFunc && (res = res());
                }
            });
            res = (res == null || res == obj ? all : res) + "";
            return res;
        };
    return function (str, obj) {
        return Str(str).replace(tokenRegex, function (all, key) {
            return replacer(all, key, obj);
        });
    };
})();
var preload = (function () {
    function onerror() {
        this.parentNode.removeChild(this);
    }
    return function (src, f) {
        var img = glob.doc.createElement("img"),
            body = glob.doc.body;
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function () {
            f.call(img);
            img.onload = img.onerror = null;
            body.removeChild(img);
        };
        img.onerror = onerror;
        body.appendChild(img);
        img.src = src;
    };
}());
function clone(obj) {
    if (typeof obj == "function" || Object(obj) !== obj) {
        return obj;
    }
    var res = new obj.constructor;
    for (var key in obj) if (obj[has](key)) {
        res[key] = clone(obj[key]);
    }
    return res;
}
Snap._.clone = clone;
function repush(array, item) {
    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
        return array.push(array.splice(i, 1)[0]);
    }
}
function cacher(f, scope, postprocessor) {
    function newf() {
        var arg = Array.prototype.slice.call(arguments, 0),
            args = arg.join("\u2400"),
            cache = newf.cache = newf.cache || {},
            count = newf.count = newf.count || [];
        if (cache[has](args)) {
            repush(count, args);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        count.length >= 1e3 && delete cache[count.shift()];
        count.push(args);
        cache[args] = f.apply(scope, arg);
        return postprocessor ? postprocessor(cache[args]) : cache[args];
    }
    return newf;
}
Snap._.cacher = cacher;
function angle(x1, y1, x2, y2, x3, y3) {
    if (x3 == null) {
        var x = x1 - x2,
            y = y1 - y2;
        if (!x && !y) {
            return 0;
        }
        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
    } else {
        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
    }
}
function rad(deg) {
    return deg % 360 * PI / 180;
}
function deg(rad) {
    return rad * 180 / PI % 360;
}
function x_y() {
    return this.x + S + this.y;
}
function x_y_w_h() {
    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
}

/*\
 * Snap.rad
 [ method ]
 **
 * Transform angle to radians
 - deg (number) angle in degrees
 = (number) angle in radians
\*/
Snap.rad = rad;
/*\
 * Snap.deg
 [ method ]
 **
 * Transform angle to degrees
 - rad (number) angle in radians
 = (number) angle in degrees
\*/
Snap.deg = deg;
// SIERRA for which point is the angle calculated?
/*\
 * Snap.angle
 [ method ]
 **
 * Returns an angle between two or three points
 > Parameters
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 - x3 (number) #optional x coord of third point
 - y3 (number) #optional y coord of third point
 = (number) angle in degrees
\*/
Snap.angle = angle;
/*\
 * Snap.is
 [ method ]
 **
 * Handy replacement for the `typeof` operator
 - o (…) any object or primitive
 - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
 = (boolean) `true` if given value is of given type
\*/
Snap.is = is;
/*\
 * Snap.snapTo
 [ method ]
 **
 * Snaps given value to given grid
 - values (array|number) given array of values or step of the grid
 - value (number) value to adjust
 - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
 = (number) adjusted value
\*/
Snap.snapTo = function (values, value, tolerance) {
    tolerance = is(tolerance, "finite") ? tolerance : 10;
    if (is(values, "array")) {
        var i = values.length;
        while (i--) if (abs(values[i] - value) <= tolerance) {
            return values[i];
        }
    } else {
        values = +values;
        var rem = value % values;
        if (rem < tolerance) {
            return value - rem;
        }
        if (rem > values - tolerance) {
            return value - rem + values;
        }
    }
    return value;
};

// MATRIX
function Matrix(a, b, c, d, e, f) {
    if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
        this.a = a.a;
        this.b = a.b;
        this.c = a.c;
        this.d = a.d;
        this.e = a.e;
        this.f = a.f;
        return;
    }
    if (a != null) {
        this.a = +a;
        this.b = +b;
        this.c = +c;
        this.d = +d;
        this.e = +e;
        this.f = +f;
    } else {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.e = 0;
        this.f = 0;
    }
}
(function (matrixproto) {
    /*\
     * Matrix.add
     [ method ]
     **
     * Adds the given matrix to existing one
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     * or
     - matrix (object) @Matrix
    \*/
    matrixproto.add = function (a, b, c, d, e, f) {
        var out = [[], [], []],
            m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
            matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
            x, y, z, res;

        if (a && a instanceof Matrix) {
            matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
        }

        for (x = 0; x < 3; x++) {
            for (y = 0; y < 3; y++) {
                res = 0;
                for (z = 0; z < 3; z++) {
                    res += m[x][z] * matrix[z][y];
                }
                out[x][y] = res;
            }
        }
        this.a = out[0][0];
        this.b = out[1][0];
        this.c = out[0][1];
        this.d = out[1][1];
        this.e = out[0][2];
        this.f = out[1][2];
        return this;
    };
    /*\
     * Matrix.invert
     [ method ]
     **
     * Returns an inverted version of the matrix
     = (object) @Matrix
    \*/
    matrixproto.invert = function () {
        var me = this,
            x = me.a * me.d - me.b * me.c;
        return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
    };
    /*\
     * Matrix.clone
     [ method ]
     **
     * Returns a copy of the matrix
     = (object) @Matrix
    \*/
    matrixproto.clone = function () {
        return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
    };
    /*\
     * Matrix.translate
     [ method ]
     **
     * Translate the matrix
     - x (number) horizontal offset distance
     - y (number) vertical offset distance
    \*/
    matrixproto.translate = function (x, y) {
        return this.add(1, 0, 0, 1, x, y);
    };
    /*\
     * Matrix.scale
     [ method ]
     **
     * Scales the matrix
     - x (number) amount to be scaled, with `1` resulting in no change
     - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
     - cx (number) #optional horizontal origin point from which to scale
     - cy (number) #optional vertical origin point from which to scale
     * Default cx, cy is the middle point of the element.
    \*/
    matrixproto.scale = function (x, y, cx, cy) {
        y == null && (y = x);
        (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
        this.add(x, 0, 0, y, 0, 0);
        (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        return this;
    };
    /*\
     * Matrix.rotate
     [ method ]
     **
     * Rotates the matrix
     - a (number) angle of rotation, in degrees
     - x (number) horizontal origin point from which to rotate
     - y (number) vertical origin point from which to rotate
    \*/
    matrixproto.rotate = function (a, x, y) {
        a = rad(a);
        x = x || 0;
        y = y || 0;
        var cos = +math.cos(a).toFixed(9),
            sin = +math.sin(a).toFixed(9);
        this.add(cos, sin, -sin, cos, x, y);
        return this.add(1, 0, 0, 1, -x, -y);
    };
    /*\
     * Matrix.x
     [ method ]
     **
     * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
     - x (number)
     - y (number)
     = (number) x
    \*/
    matrixproto.x = function (x, y) {
        return x * this.a + y * this.c + this.e;
    };
    /*\
     * Matrix.y
     [ method ]
     **
     * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
     - x (number)
     - y (number)
     = (number) y
    \*/
    matrixproto.y = function (x, y) {
        return x * this.b + y * this.d + this.f;
    };
    matrixproto.get = function (i) {
        return +this[Str.fromCharCode(97 + i)].toFixed(4);
    };
    matrixproto.toString = function () {
        return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
    };
    matrixproto.offset = function () {
        return [this.e.toFixed(4), this.f.toFixed(4)];
    };
    function norm(a) {
        return a[0] * a[0] + a[1] * a[1];
    }
    function normalize(a) {
        var mag = math.sqrt(norm(a));
        a[0] && (a[0] /= mag);
        a[1] && (a[1] /= mag);
    }
    /*\
     * Matrix.split
     [ method ]
     **
     * Splits matrix into primitive transformations
     = (object) in format:
     o dx (number) translation by x
     o dy (number) translation by y
     o scalex (number) scale by x
     o scaley (number) scale by y
     o shear (number) shear
     o rotate (number) rotation in deg
     o isSimple (boolean) could it be represented via simple transformations
    \*/
    matrixproto.split = function () {
        var out = {};
        // translation
        out.dx = this.e;
        out.dy = this.f;

        // scale and shear
        var row = [[this.a, this.c], [this.b, this.d]];
        out.scalex = math.sqrt(norm(row[0]));
        normalize(row[0]);

        out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
        row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

        out.scaley = math.sqrt(norm(row[1]));
        normalize(row[1]);
        out.shear /= out.scaley;

        // rotation
        var sin = -row[0][1],
            cos = row[1][1];
        if (cos < 0) {
            out.rotate = deg(math.acos(cos));
            if (sin < 0) {
                out.rotate = 360 - out.rotate;
            }
        } else {
            out.rotate = deg(math.asin(sin));
        }

        out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
        out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
        out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
        return out;
    };
    /*\
     * Matrix.toTransformString
     [ method ]
     **
     * Returns transform string that represents given matrix
     = (string) transform string
    \*/
    matrixproto.toTransformString = function (shorter) {
        var s = shorter || this.split();
        if (s.isSimple) {
            s.scalex = +s.scalex.toFixed(4);
            s.scaley = +s.scaley.toFixed(4);
            s.rotate = +s.rotate.toFixed(4);
            return  (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +
                    (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                    (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E);
        } else {
            return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
        }
    };
})(Matrix.prototype);
/*\
 * Snap.Matrix
 [ method ]
 **
 * Utility method
 **
 * Returns a matrix based on the given parameters
 - a (number)
 - b (number)
 - c (number)
 - d (number)
 - e (number)
 - f (number)
 * or
 - svgMatrix (SVGMatrix)
 = (object) @Matrix
\*/
Snap.Matrix = Matrix;
// Colour
/*\
 * Snap.getRGB
 [ method ]
 **
 * Parses color string as RGB object
 - color (string) color string in one of the following formats:
 # <ul>
 #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
 #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
 #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
 #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
 #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>
 #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
 #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>
 #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
 #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>
 #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
 #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>
 #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
 #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>
 #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
 #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>
 # </ul>
 * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••,
 o     error (boolean) true if string can't be parsed
 o }
\*/
Snap.getRGB = cacher(function (colour) {
    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
    }
    if (colour == "none") {
        return {r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString};
    }
    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
    if (!colour) {
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
    }
    var res,
        red,
        green,
        blue,
        opacity,
        t,
        values,
        rgb = colour.match(colourRegExp);
    if (rgb) {
        if (rgb[2]) {
            blue = toInt(rgb[2].substring(5), 16);
            green = toInt(rgb[2].substring(3, 5), 16);
            red = toInt(rgb[2].substring(1, 3), 16);
        }
        if (rgb[3]) {
            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
            green = toInt((t = rgb[3].charAt(2)) + t, 16);
            red = toInt((t = rgb[3].charAt(1)) + t, 16);
        }
        if (rgb[4]) {
            values = rgb[4].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red *= 2.55);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green *= 2.55);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue *= 2.55);
            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        }
        if (rgb[5]) {
            values = rgb[5].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red /= 100);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green /= 100);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue /= 100);
            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            return Snap.hsb2rgb(red, green, blue, opacity);
        }
        if (rgb[6]) {
            values = rgb[6].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red /= 100);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green /= 100);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue /= 100);
            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            return Snap.hsl2rgb(red, green, blue, opacity);
        }
        red = mmin(math.round(red), 255);
        green = mmin(math.round(green), 255);
        blue = mmin(math.round(blue), 255);
        opacity = mmin(mmax(opacity, 0), 1);
        rgb = {r: red, g: green, b: blue, toString: rgbtoString};
        rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
        rgb.opacity = is(opacity, "finite") ? opacity : 1;
        return rgb;
    }
    return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
}, Snap);
// SIERRA It seems odd that the following 3 conversion methods are not expressed as .this2that(), like the others.
/*\
 * Snap.hsb
 [ method ]
 **
 * Converts HSB values to a hex representation of the color
 - h (number) hue
 - s (number) saturation
 - b (number) value or brightness
 = (string) hex representation of the color
\*/
Snap.hsb = cacher(function (h, s, b) {
    return Snap.hsb2rgb(h, s, b).hex;
});
/*\
 * Snap.hsl
 [ method ]
 **
 * Converts HSL values to a hex representation of the color
 - h (number) hue
 - s (number) saturation
 - l (number) luminosity
 = (string) hex representation of the color
\*/
Snap.hsl = cacher(function (h, s, l) {
    return Snap.hsl2rgb(h, s, l).hex;
});
/*\
 * Snap.rgb
 [ method ]
 **
 * Converts RGB values to a hex representation of the color
 - r (number) red
 - g (number) green
 - b (number) blue
 = (string) hex representation of the color
\*/
Snap.rgb = cacher(function (r, g, b, o) {
    if (is(o, "finite")) {
        var round = math.round;
        return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
    }
    return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
});
var toHex = function (color) {
    var i = glob.doc.getElementsByTagName("head")[0],
        red = "rgb(255, 0, 0)";
    toHex = cacher(function (color) {
        if (color.toLowerCase() == "red") {
            return red;
        }
        i.style.color = red;
        i.style.color = color;
        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
        return out == red ? null : out;
    });
    return toHex(color);
},
hsbtoString = function () {
    return "hsb(" + [this.h, this.s, this.b] + ")";
},
hsltoString = function () {
    return "hsl(" + [this.h, this.s, this.l] + ")";
},
rgbtoString = function () {
    return this.opacity == 1 || this.opacity == null ?
            this.hex :
            "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
},
prepareRGB = function (r, g, b) {
    if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
        b = r.b;
        g = r.g;
        r = r.r;
    }
    if (g == null && is(r, string)) {
        var clr = Snap.getRGB(r);
        r = clr.r;
        g = clr.g;
        b = clr.b;
    }
    if (r > 1 || g > 1 || b > 1) {
        r /= 255;
        g /= 255;
        b /= 255;
    }

    return [r, g, b];
},
packageRGB = function (r, g, b, o) {
    r = math.round(r * 255);
    g = math.round(g * 255);
    b = math.round(b * 255);
    var rgb = {
        r: r,
        g: g,
        b: b,
        opacity: is(o, "finite") ? o : 1,
        hex: Snap.rgb(r, g, b),
        toString: rgbtoString
    };
    is(o, "finite") && (rgb.opacity = o);
    return rgb;
};
// SIERRA Clarify if Snap does not support consolidated HSLA/RGBA colors. E.g., can you specify a semi-transparent value for Snap.filter.shadow()?
/*\
 * Snap.color
 [ method ]
 **
 * Parses the color string and returns an object featuring the color's component values
 - clr (string) color string in one of the supported formats (see @Snap.getRGB)
 = (object) Combined RGB/HSB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••,
 o     error (boolean) `true` if string can't be parsed,
 o     h (number) hue,
 o     s (number) saturation,
 o     v (number) value (brightness),
 o     l (number) lightness
 o }
\*/
Snap.color = function (clr) {
    var rgb;
    if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
        rgb = Snap.hsb2rgb(clr);
        clr.r = rgb.r;
        clr.g = rgb.g;
        clr.b = rgb.b;
        clr.opacity = 1;
        clr.hex = rgb.hex;
    } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
        rgb = Snap.hsl2rgb(clr);
        clr.r = rgb.r;
        clr.g = rgb.g;
        clr.b = rgb.b;
        clr.opacity = 1;
        clr.hex = rgb.hex;
    } else {
        if (is(clr, "string")) {
            clr = Snap.getRGB(clr);
        }
        if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
            rgb = Snap.rgb2hsl(clr);
            clr.h = rgb.h;
            clr.s = rgb.s;
            clr.l = rgb.l;
            rgb = Snap.rgb2hsb(clr);
            clr.v = rgb.b;
        } else {
            clr = {hex: "none"};
            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            clr.error = 1;
        }
    }
    clr.toString = rgbtoString;
    return clr;
};
/*\
 * Snap.hsb2rgb
 [ method ]
 **
 * Converts HSB values to an RGB object
 - h (number) hue
 - s (number) saturation
 - v (number) value or brightness
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••
 o }
\*/
Snap.hsb2rgb = function (h, s, v, o) {
    if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
        v = h.b;
        s = h.s;
        h = h.h;
        o = h.o;
    }
    h *= 360;
    var R, G, B, X, C;
    h = (h % 360) / 60;
    C = v * s;
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = v - C;

    h = ~~h;
    R += [C, X, 0, 0, X, C][h];
    G += [X, C, C, X, 0, 0][h];
    B += [0, 0, X, C, C, X][h];
    return packageRGB(R, G, B, o);
};
/*\
 * Snap.hsl2rgb
 [ method ]
 **
 * Converts HSL values to an RGB object
 - h (number) hue
 - s (number) saturation
 - l (number) luminosity
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••
 o }
\*/
Snap.hsl2rgb = function (h, s, l, o) {
    if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
        l = h.l;
        s = h.s;
        h = h.h;
    }
    if (h > 1 || s > 1 || l > 1) {
        h /= 360;
        s /= 100;
        l /= 100;
    }
    h *= 360;
    var R, G, B, X, C;
    h = (h % 360) / 60;
    C = 2 * s * (l < .5 ? l : 1 - l);
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = l - C / 2;

    h = ~~h;
    R += [C, X, 0, 0, X, C][h];
    G += [X, C, C, X, 0, 0][h];
    B += [0, 0, X, C, C, X][h];
    return packageRGB(R, G, B, o);
};
/*\
 * Snap.rgb2hsb
 [ method ]
 **
 * Converts RGB values to an HSB object
 - r (number) red
 - g (number) green
 - b (number) blue
 = (object) HSB object in the following format:
 o {
 o     h (number) hue,
 o     s (number) saturation,
 o     b (number) brightness
 o }
\*/
Snap.rgb2hsb = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];

    var H, S, V, C;
    V = mmax(r, g, b);
    C = V - mmin(r, g, b);
    H = (C == 0 ? null :
         V == r ? (g - b) / C :
         V == g ? (b - r) / C + 2 :
                  (r - g) / C + 4
        );
    H = ((H + 360) % 6) * 60 / 360;
    S = C == 0 ? 0 : C / V;
    return {h: H, s: S, b: V, toString: hsbtoString};
};
/*\
 * Snap.rgb2hsl
 [ method ]
 **
 * Converts RGB values to an HSL object
 - r (number) red
 - g (number) green
 - b (number) blue
 = (object) HSL object in the following format:
 o {
 o     h (number) hue,
 o     s (number) saturation,
 o     l (number) luminosity
 o }
\*/
Snap.rgb2hsl = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];

    var H, S, L, M, m, C;
    M = mmax(r, g, b);
    m = mmin(r, g, b);
    C = M - m;
    H = (C == 0 ? null :
         M == r ? (g - b) / C :
         M == g ? (b - r) / C + 2 :
                  (r - g) / C + 4);
    H = ((H + 360) % 6) * 60 / 360;
    L = (M + m) / 2;
    S = (C == 0 ? 0 :
         L < .5 ? C / (2 * L) :
                  C / (2 - 2 * L));
    return {h: H, s: S, l: L, toString: hsltoString};
};

// Transformations
// SIERRA Snap.parsePathString(): By _array of arrays,_ I assume you mean a format like this for two separate segments? [ ["M10,10","L90,90"], ["M90,10","L10,90"] ] Otherwise how is each command structured?
/*\
 * Snap.parsePathString
 [ method ]
 **
 * Utility method
 **
 * Parses given path string into an array of arrays of path segments
 - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
 = (array) array of segments
\*/
Snap.parsePathString = function (pathString) {
    if (!pathString) {
        return null;
    }
    var pth = Snap.path(pathString);
    if (pth.arr) {
        return Snap.path.clone(pth.arr);
    }

    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},
        data = [];
    if (is(pathString, "array") && is(pathString[0], "array")) { // rough assumption
        data = Snap.path.clone(pathString);
    }
    if (!data.length) {
        Str(pathString).replace(pathCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            if (name == "m" && params.length > 2) {
                data.push([b].concat(params.splice(0, 2)));
                name = "l";
                b = b == "m" ? "l" : "L";
            }
            if (name == "o" && params.length == 1) {
                data.push([b, params[0]]);
            }
            if (name == "r") {
                data.push([b].concat(params));
            } else while (params.length >= paramCounts[name]) {
                data.push([b].concat(params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        });
    }
    data.toString = Snap.path.toString;
    pth.arr = Snap.path.clone(data);
    return data;
};
/*\
 * Snap.parseTransformString
 [ method ]
 **
 * Utility method
 **
 * Parses given transform string into an array of transformations
 - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
 = (array) array of transformations
\*/
var parseTransformString = Snap.parseTransformString = function (TString) {
    if (!TString) {
        return null;
    }
    var paramCounts = {r: 3, s: 4, t: 2, m: 6},
        data = [];
    if (is(TString, "array") && is(TString[0], "array")) { // rough assumption
        data = Snap.path.clone(TString);
    }
    if (!data.length) {
        Str(TString).replace(tCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            data.push([b].concat(params));
        });
    }
    data.toString = Snap.path.toString;
    return data;
};
function svgTransform2string(tstr) {
    var res = [];
    tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
        params = params.split(/\s*,\s*|\s+/);
        if (name == "rotate" && params.length == 1) {
            params.push(0, 0);
        }
        if (name == "scale") {
            if (params.length == 2) {
                params.push(0, 0);
            }
            if (params.length == 1) {
                params.push(params[0], 0, 0);
            }
        }
        if (name == "skewX") {
            res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
        } else if (name == "skewY") {
            res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
        } else {
            res.push([name.charAt(0)].concat(params));
        }
        return all;
    });
    return res;
}
Snap._.svgTransform2string = svgTransform2string;
Snap._.rgTransform = new RegExp("^[a-z][" + spaces + "]*-?\\.?\\d", "i");
function transform2matrix(tstr, bbox) {
    var tdata = parseTransformString(tstr),
        m = new Matrix;
    if (tdata) {
        for (var i = 0, ii = tdata.length; i < ii; i++) {
            var t = tdata[i],
                tlen = t.length,
                command = Str(t[0]).toLowerCase(),
                absolute = t[0] != command,
                inver = absolute ? m.invert() : 0,
                x1,
                y1,
                x2,
                y2,
                bb;
            if (command == "t" && tlen == 2){
                m.translate(t[1], 0);
            } else if (command == "t" && tlen == 3) {
                if (absolute) {
                    x1 = inver.x(0, 0);
                    y1 = inver.y(0, 0);
                    x2 = inver.x(t[1], t[2]);
                    y2 = inver.y(t[1], t[2]);
                    m.translate(x2 - x1, y2 - y1);
                } else {
                    m.translate(t[1], t[2]);
                }
            } else if (command == "r") {
                if (tlen == 2) {
                    bb = bb || bbox;
                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.rotate(t[1], x2, y2);
                    } else {
                        m.rotate(t[1], t[2], t[3]);
                    }
                }
            } else if (command == "s") {
                if (tlen == 2 || tlen == 3) {
                    bb = bb || bbox;
                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.scale(t[1], t[1], x2, y2);
                    } else {
                        m.scale(t[1], t[1], t[2], t[3]);
                    }
                } else if (tlen == 5) {
                    if (absolute) {
                        x2 = inver.x(t[3], t[4]);
                        y2 = inver.y(t[3], t[4]);
                        m.scale(t[1], t[2], x2, y2);
                    } else {
                        m.scale(t[1], t[2], t[3], t[4]);
                    }
                }
            } else if (command == "m" && tlen == 7) {
                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
            }
        }
    }
    return m;
}
Snap._.transform2matrix = transform2matrix;
function extractTransform(el, tstr) {
    if (tstr == null) {
        var doReturn = true;
        if (el.type == "linearGradient" || el.type == "radialGradient") {
            tstr = el.node.getAttribute("gradientTransform");
        } else if (el.type == "pattern") {
            tstr = el.node.getAttribute("patternTransform");
        } else {
            tstr = el.node.getAttribute("transform");
        }
        if (!tstr) {
            return new Matrix;
        }
        tstr = svgTransform2string(tstr);
    } else {
        if (!Snap._.rgTransform.test(tstr)) {
            tstr = svgTransform2string(tstr);
        } else {
            tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
        }
        if (is(tstr, "array")) {
            tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
        }
        el._.transform = tstr;
    }
    var m = transform2matrix(tstr, el.getBBox(1));
    if (doReturn) {
        return m;
    } else {
        el.matrix = m;
    }
}
Snap._unit2px = unit2px;
var contains = glob.doc.contains || glob.doc.compareDocumentPosition ?
    function (a, b) {
        var adown = a.nodeType == 9 ? a.documentElement : a,
            bup = b && b.parentNode;
            return a == bup || !!(bup && bup.nodeType == 1 && (
                adown.contains ?
                    adown.contains(bup) :
                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
            ));
    } :
    function (a, b) {
        if (b) {
            while (b) {
                b = b.parentNode;
                if (b == a) {
                    return true;
                }
            }
        }
        return false;
    };
function getSomeDefs(el) {
    var cache = Snap._.someDefs;
    if (cache && contains(cache.ownerDocument.documentElement, cache)) {
        return cache;
    }
    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||
            (el.node.parentNode && wrap(el.node.parentNode)) ||
            Snap.select("svg") ||
            Snap(0, 0),
        pdefs = p.select("defs"),
        defs  = pdefs == null ? false : pdefs.node;
    if (!defs) {
        defs = make("defs", p.node).node;
    }
    Snap._.someDefs = defs;
    return defs;
}
Snap._.getSomeDefs = getSomeDefs;
function unit2px(el, name, value) {
    var defs = getSomeDefs(el),
        out = {},
        mgr = defs.querySelector(".svg---mgr");
    if (!mgr) {
        mgr = $("rect");
        $(mgr, {width: 10, height: 10, "class": "svg---mgr"});
        defs.appendChild(mgr);
    }
    function getW(val) {
        if (val == null) {
            return E;
        }
        if (val == +val) {
            return val;
        }
        $(mgr, {width: val});
        return mgr.getBBox().width;
    }
    function getH(val) {
        if (val == null) {
            return E;
        }
        if (val == +val) {
            return val;
        }
        $(mgr, {height: val});
        return mgr.getBBox().height;
    }
    function set(nam, f) {
        if (name == null) {
            out[nam] = f(el.attr(nam));
        } else if (nam == name) {
            out = f(value == null ? el.attr(nam) : value);
        }
    }
    switch (el.type) {
        case "rect":
            set("rx", getW);
            set("ry", getH);
        case "image":
            set("width", getW);
            set("height", getH);
        case "text":
            set("x", getW);
            set("y", getH);
        break;
        case "circle":
            set("cx", getW);
            set("cy", getH);
            set("r", getW);
        break;
        case "ellipse":
            set("cx", getW);
            set("cy", getH);
            set("rx", getW);
            set("ry", getH);
        break;
        case "line":
            set("x1", getW);
            set("x2", getW);
            set("y1", getH);
            set("y2", getH);
        break;
        case "marker":
            set("refX", getW);
            set("markerWidth", getW);
            set("refY", getH);
            set("markerHeight", getH);
        break;
        case "radialGradient":
            set("fx", getW);
            set("fy", getH);
        break;
        case "tspan":
            set("dx", getW);
            set("dy", getH);
        break;
        default:
            set(name, getW);
    }
    return out;
}
/*\
 * Snap.select
 [ method ]
 **
 * Wraps a DOM element specified by CSS selector as @Element
 - query (string) CSS selector of the element
 = (Element) the current element
\*/
Snap.select = function (query) {
    return wrap(glob.doc.querySelector(query));
};
/*\
 * Snap.selectAll
 [ method ]
 **
 * Wraps DOM elements specified by CSS selector as set or array of @Element
 - query (string) CSS selector of the element
 = (Element) the current element
\*/
Snap.selectAll = function (query) {
    var nodelist = glob.doc.querySelectorAll(query),
        set = (Snap.set || Array)();
    for (var i = 0; i < nodelist.length; i++) {
        set.push(wrap(nodelist[i]));
    }
    return set;
};

function add2group(list) {
    if (!is(list, "array")) {
        list = Array.prototype.slice.call(arguments, 0);
    }
    var i = 0,
        j = 0,
        node = this.node;
    while (this[i]) delete this[i++];
    for (i = 0; i < list.length; i++) {
        if (list[i].type == "set") {
            list[i].forEach(function (el) {
                node.appendChild(el.node);
            });
        } else {
            node.appendChild(list[i].node);
        }
    }
    var children = node.childNodes;
    for (i = 0; i < children.length; i++) {
        this[j++] = wrap(children[i]);
    }
    return this;
}
function Element(el) {
    if (el.snap in hub) {
        return hub[el.snap];
    }
    var id = this.id = ID(),
        svg;
    try {
        svg = el.ownerSVGElement;
    } catch(e) {}
    this.node = el;
    if (svg) {
        this.paper = new Paper(svg);
    }
    this.type = el.tagName;
    this.anims = {};
    this._ = {
        transform: []
    };
    el.snap = id;
    hub[id] = this;
    if (this.type == "g") {
        this.add = add2group;
        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {
            this[method] = Paper.prototype[method];
        }
    }
}
function arrayFirstValue(arr) {
    var res;
    for (var i = 0, ii = arr.length; i < ii; i++) {
        res = res || arr[i];
        if (res) {
            return res;
        }
    }
}
(function (elproto) {
    /*\
     * Element.attr
     [ method ]
     **
     * Gets or sets given attributes of the element
     **
     - params (object) contains key-value pairs of attributes you want to set
     * or
     - param (string) name of the attribute
     = (Element) the current element
     * or
     = (string) value of attribute
     > Usage
     | el.attr({
     |     fill: "#fc0",
     |     stroke: "#000",
     |     strokeWidth: 2, // CamelCase...
     |     "fill-opacity": 0.5 // or dash-separated names
     | });
     | console.log(el.attr("fill")); // #fc0
    \*/
    elproto.attr = function (params, value) {
        var el = this,
            node = el.node;
        if (!params) {
            return el;
        }
        if (is(params, "string")) {
            if (arguments.length > 1) {
                var json = {};
                json[params] = value;
                params = json;
            } else {
                return arrayFirstValue(eve("snap.util.getattr."+params, el));
            }
        }
        for (var att in params) {
            if (params[has](att)) {
                eve("snap.util.attr." + att, el, params[att]);
            }
        }
        return el;
    };
// SIERRA Element.getBBox(): Unclear why you would want to express the dimension of the box as a path.
// SIERRA Element.getBBox(): Unclear why you would want to use r0/r1/r2. Also, basic definitions: wouldn't the _smallest circle that can be enclosed_ be a zero-radius point?
    /*\
     * Element.getBBox
     [ method ]
     **
     * Returns the bounding box descriptor for the given element
     **
     = (object) bounding box descriptor:
     o {
     o     cx: (number) x of the center,
     o     cy: (number) x of the center,
     o     h: (number) height,
     o     height: (number) height,
     o     path: (string) path command for the box,
     o     r0: (number) radius of a circle that fully encloses the box,
     o     r1: (number) radius of the smallest circle that can be enclosed,
     o     r2: (number) radius of the largest circle that can be enclosed,
     o     vb: (string) box as a viewbox command,
     o     w: (number) width,
     o     width: (number) width,
     o     x2: (number) x of the right side,
     o     x: (number) x of the left side,
     o     y2: (number) y of the bottom edge,
     o     y: (number) y of the top edge
     o }
    \*/
    elproto.getBBox = function (isWithoutTransform) {
        var el = this;
        if (el.type == "use") {
            el = el.original;
        }
        if (el.removed) {
            return {};
        }
        var _ = el._;
        if (isWithoutTransform) {
            _.bboxwt = Snap.path.get[el.type] ? Snap.path.getBBox(el.realPath = Snap.path.get[el.type](el)) : Snap._.box(el.node.getBBox());
            return Snap._.box(_.bboxwt);
        } else {
            el.realPath = (Snap.path.get[el.type] || Snap.path.get.deflt)(el);
            _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, el.matrix));
        }
        return Snap._.box(_.bbox);
    };
    var propString = function () {
        return this.string;
    };
// SIERRA Element.transform(): seems to allow two return values, one of which (_Element_) is undefined.
// SIERRA Element.transform(): if this only accepts one argument, it's unclear how it can both _get_ and _set_ a transform.
// SIERRA Element.transform(): Unclear how Snap transform string format differs from SVG's.
    /*\
     * Element.transform
     [ method ]
     **
     * Gets or sets transformation of the element
     **
     - tstr (string) transform string in Snap or SVG format
     = (Element) the current element
     * or
     = (object) transformation descriptor:
     o {
     o     string (string) transform string,
     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
     o     localMatrix (Matrix) matrix of transformations applied only to the element,
     o     diffMatrix (Matrix) matrix of difference between global and local transformations,
     o     global (string) global transformation as string,
     o     local (string) local transformation as string,
     o     toString (function) returns `string` property
     o }
    \*/
    elproto.transform = function (tstr) {
        var _ = this._;
        if (tstr == null) {
            var global = new Matrix(this.node.getCTM()),
                local = extractTransform(this),
                localString = local.toTransformString(),
                string = Str(local) == Str(this.matrix) ?
                            _.transform : localString;
            return {
                string: string,
                globalMatrix: global,
                localMatrix: local,
                diffMatrix: global.clone().add(local.invert()),
                global: global.toTransformString(),
                local: localString,
                toString: propString
            };
        }
        if (tstr instanceof Matrix) {
            // may be need to apply it directly
            // TODO: investigate
            tstr = tstr.toTransformString();
        }
        extractTransform(this, tstr);

        if (this.node) {
            if (this.type == "linearGradient" || this.type == "radialGradient") {
                $(this.node, {gradientTransform: this.matrix});
            } else if (this.type == "pattern") {
                $(this.node, {patternTransform: this.matrix});
            } else {
                $(this.node, {transform: this.matrix});
            }
        }

        return this;
    };
    /*\
     * Element.parent
     [ method ]
     **
     * Returns the element's parent
     **
     = (Element) the parent element
    \*/
    elproto.parent = function () {
        return wrap(this.node.parentNode);
    };
    /*\
     * Element.append
     [ method ]
     **
     * Appends the given element to current one
     **
     - el (Element|Set) element to append
     = (Element) the parent element
    \*/
    /*\
     * Element.add
     [ method ]
     **
     * See @Element.append
    \*/
    elproto.append = elproto.add = function (el) {
        if (el) {
            if (el.type == "set") {
                var it = this;
                el.forEach(function (el) {
                    it.add(el);
                });
                return this;
            }
            el = wrap(el);
            this.node.appendChild(el.node);
            el.paper = this.paper;
        }
        return this;
    };
    /*\
     * Element.appendTo
     [ method ]
     **
     * Appends the current element to the given one
     **
     - el (Element) parent element to append to
     = (Element) the child element
    \*/
    elproto.appendTo = function (el) {
        if (el) {
            el = wrap(el);
            el.append(this);
        }
        return this;
    };
    /*\
     * Element.prepend
     [ method ]
     **
     * Prepends the given element to the current one
     **
     - el (Element) element to prepend
     = (Element) the parent element
    \*/
    elproto.prepend = function (el) {
        if (el) {
            el = wrap(el);
            var parent = el.parent();
            this.node.insertBefore(el.node, this.node.firstChild);
            this.add && this.add();
            el.paper = this.paper;
            this.parent() && this.parent().add();
            parent && parent.add();
        }
        return this;
    };
    /*\
     * Element.prependTo
     [ method ]
     **
     * Prepends the current element to the given one
     **
     - el (Element) parent element to prepend to
     = (Element) the child element
    \*/
    elproto.prependTo = function (el) {
        el = wrap(el);
        el.prepend(this);
        return this;
    };
    /*\
     * Element.before
     [ method ]
     **
     * Inserts given element before the current one
     **
     - el (Element) element to insert
     = (Element) the parent element
    \*/
    elproto.before = function (el) {
        if (el.type == "set") {
            var it = this;
            el.forEach(function (el) {
                var parent = el.parent();
                it.node.parentNode.insertBefore(el.node, it.node);
                parent && parent.add();
            });
            this.parent().add();
            return this;
        }
        el = wrap(el);
        var parent = el.parent();
        this.node.parentNode.insertBefore(el.node, this.node);
        this.parent() && this.parent().add();
        parent && parent.add();
        el.paper = this.paper;
        return this;
    };
    /*\
     * Element.after
     [ method ]
     **
     * Inserts given element after the current one
     **
     - el (Element) element to insert
     = (Element) the parent element
    \*/
    elproto.after = function (el) {
        el = wrap(el);
        var parent = el.parent();
        if (this.node.nextSibling) {
            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
        } else {
            this.node.parentNode.appendChild(el.node);
        }
        this.parent() && this.parent().add();
        parent && parent.add();
        el.paper = this.paper;
        return this;
    };
    /*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts the element after the given one
     **
     - el (Element) element next to whom insert to
     = (Element) the parent element
    \*/
    elproto.insertBefore = function (el) {
        el = wrap(el);
        var parent = this.parent();
        el.node.parentNode.insertBefore(this.node, el.node);
        this.paper = el.paper;
        parent && parent.add();
        el.parent() && el.parent().add();
        return this;
    };
    /*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts the element after the given one
     **
     - el (Element) element next to whom insert to
     = (Element) the parent element
    \*/
    elproto.insertAfter = function (el) {
        el = wrap(el);
        var parent = this.parent();
        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
        this.paper = el.paper;
        parent && parent.add();
        el.parent() && el.parent().add();
        return this;
    };
    /*\
     * Element.remove
     [ method ]
     **
     * Removes element from the DOM
     = (Element) the detached element
    \*/
    elproto.remove = function () {
        var parent = this.parent();
        this.node.parentNode && this.node.parentNode.removeChild(this.node);
        delete this.paper;
        this.removed = true;
        parent && parent.add();
        return this;
    };
    /*\
     * Element.select
     [ method ]
     **
     * Gathers the nested @Element matching the given set of CSS selectors
     **
     - query (string) CSS selector
     = (Element) result of query selection
    \*/
    elproto.select = function (query) {
        return wrap(this.node.querySelector(query));
    };
    /*\
     * Element.selectAll
     [ method ]
     **
     * Gathers nested @Element objects matching the given set of CSS selectors
     **
     - query (string) CSS selector
     = (Set|array) result of query selection
    \*/
    elproto.selectAll = function (query) {
        var nodelist = this.node.querySelectorAll(query),
            set = (Snap.set || Array)();
        for (var i = 0; i < nodelist.length; i++) {
            set.push(wrap(nodelist[i]));
        }
        return set;
    };
    /*\
     * Element.asPX
     [ method ]
     **
     * Returns given attribute of the element as a `px` value (not %, em, etc.)
     **
     - attr (string) attribute name
     - value (string) #optional attribute value
     = (Element) result of query selection
    \*/
    elproto.asPX = function (attr, value) {
        if (value == null) {
            value = this.attr(attr);
        }
        return +unit2px(this, attr, value);
    };
    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
    /*\
     * Element.use
     [ method ]
     **
     * Creates a `<use>` element linked to the current element
     **
     = (Element) the `<use>` element
    \*/
    elproto.use = function () {
        var use,
            id = this.node.id;
        if (!id) {
            id = this.id;
            $(this.node, {
                id: id
            });
        }
        if (this.type == "linearGradient" || this.type == "radialGradient" ||
            this.type == "pattern") {
            use = make(this.type, this.node.parentNode);
        } else {
            use = make("use", this.node.parentNode);
        }
        $(use.node, {
            "xlink:href": "#" + id
        });
        use.original = this;
        return use;
    };
    /*\
     * Element.clone
     [ method ]
     **
     * Creates a clone of the element and inserts it after the element
     **
     = (Element) the clone
    \*/
    function fixids(el) {
        var els = el.selectAll("*"),
            it,
            url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
            ids = [],
            uses = {};
        function urltest(it, name) {
            var val = $(it.node, name);
            val = val && val.match(url);
            val = val && val[2];
            if (val && val.charAt() == "#") {
                val = val.substring(1);
            } else {
                return;
            }
            if (val) {
                uses[val] = (uses[val] || []).concat(function (id) {
                    var attr = {};
                    attr[name] = URL(id);
                    $(it.node, attr);
                });
            }
        }
        function linktest(it) {
            var val = $(it.node, "xlink:href");
            if (val && val.charAt() == "#") {
                val = val.substring(1);
            } else {
                return;
            }
            if (val) {
                uses[val] = (uses[val] || []).concat(function (id) {
                    it.attr("xlink:href", "#" + id);
                });
            }
        }
        for (var i = 0, ii = els.length; i < ii; i++) {
            it = els[i];
            urltest(it, "fill");
            urltest(it, "stroke");
            urltest(it, "filter");
            urltest(it, "mask");
            urltest(it, "clip-path");
            linktest(it);
            var oldid = $(it.node, "id");
            if (oldid) {
                $(it.node, {id: it.id});
                ids.push({
                    old: oldid,
                    id: it.id
                });
            }
        }
        for (i = 0, ii = ids.length; i < ii; i++) {
            var fs = uses[ids[i].old];
            if (fs) {
                for (var j = 0, jj = fs.length; j < jj; j++) {
                    fs[j](ids[i].id);
                }
            }
        }
    }
    elproto.clone = function () {
        var clone = wrap(this.node.cloneNode(true));
        if ($(clone.node, "id")) {
            $(clone.node, {id: clone.id});
        }
        fixids(clone);
        clone.insertAfter(this);
        return clone;
    };
// SIERRA Element.toDefs(): If this _moves_ an element to the <defs> region, why is the return value a _clone_? Also unclear why it's called the _relative_ <defs> section. Perhaps _shared_?
    /*\
     * Element.toDefs
     [ method ]
     **
     * Moves element to the shared `<defs>` area
     **
     = (Element) the clone
    \*/
    elproto.toDefs = function () {
        var defs = getSomeDefs(this);
        defs.appendChild(this.node);
        return this;
    };
// SIERRA Element.pattern(): x/y/width/height data types are listed as both String and Number. Is that an error, or does it mean strings are coerced?
// SIERRA Element.pattern(): clarify that x/y are offsets that e.g., may add gutters between the tiles.
    /*\
     * Element.pattern
     [ method ]
     **
     * Creates a `<pattern>` element from the current element
     **
     * To create a pattern you have to specify the pattern rect:
     - x (string|number)
     - y (string|number)
     - width (string|number)
     - height (string|number)
     = (Element) the `<pattern>` element
     * You can use pattern later on as an argument for `fill` attribute:
     | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
     |         fill: "none",
     |         stroke: "#bada55",
     |         strokeWidth: 5
     |     }).pattern(0, 0, 10, 10),
     |     c = paper.circle(200, 200, 100);
     | c.attr({
     |     fill: p
     | });
    \*/
    elproto.pattern = function (x, y, width, height) {
        var p = make("pattern", getSomeDefs(this));
        if (x == null) {
            x = this.getBBox();
        }
        if (is(x, "object") && "x" in x) {
            y = x.y;
            width = x.width;
            height = x.height;
            x = x.x;
        }
        $(p.node, {
            x: x,
            y: y,
            width: width,
            height: height,
            patternUnits: "userSpaceOnUse",
            id: p.id,
            viewBox: [x, y, width, height].join(" ")
        });
        p.node.appendChild(this.node);
        return p;
    };
// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
    /*\
     * Element.marker
     [ method ]
     **
     * Creates a `<marker>` element from the current element
     **
     * To create a marker you have to specify the bounding rect and reference point:
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - refX (number)
     - refY (number)
     = (Element) the `<marker>` element
     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
    \*/
    // TODO add usage for markers
    elproto.marker = function (x, y, width, height, refX, refY) {
        var p = make("marker", getSomeDefs(this));
        if (x == null) {
            x = this.getBBox();
        }
        if (is(x, "object") && "x" in x) {
            y = x.y;
            width = x.width;
            height = x.height;
            refX = x.refX || x.cx;
            refY = x.refY || x.cy;
            x = x.x;
        }
        $(p.node, {
            viewBox: [x, y, width, height].join(S),
            markerWidth: width,
            markerHeight: height,
            orient: "auto",
            refX: refX || 0,
            refY: refY || 0,
            id: p.id
        });
        p.node.appendChild(this.node);
        return p;
    };
    // animation
    function slice(from, to, f) {
        return function (arr) {
            var res = arr.slice(from, to);
            if (res.length == 1) {
                res = res[0];
            }
            return f ? f(res) : res;
        };
    }
    var Animation = function (attr, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        this.attr = attr;
        this.dur = ms;
        easing && (this.easing = easing);
        callback && (this.callback = callback);
    };
    // SIERRA All object methods should feature sample code. This is just one instance.
    /*\
     * Snap.animation
     [ method ]
     **
     * Creates an animation object
     **
     - attr (object) attributes of final destination
     - duration (number) duration of the animation, in milliseconds
     - easing (function) #optional one of easing functions of @mina or custom one
     - callback (function) #optional callback function that fires when animation ends
     = (object) animation object
    \*/
    Snap.animation = function (attr, ms, easing, callback) {
        return new Animation(attr, ms, easing, callback);
    };
    /*\
     * Element.inAnim
     [ method ]
     **
     * Returns a set of animations that may be able to manipulate the current element
     **
     = (object) in format:
     o {
     o     anim (object) animation object,
     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,
     o     status (function) gets or sets the status of the animation,
     o     stop (function) stops the animation
     o }
    \*/
    elproto.inAnim = function () {
        var el = this,
            res = [];
        for (var id in el.anims) if (el.anims[has](id)) {
            (function (a) {
                res.push({
                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
                    curStatus: a.status(),
                    status: function (val) {
                        return a.status(val);
                    },
                    stop: function () {
                        a.stop();
                    }
                });
            }(el.anims[id]));
        }
        return res;
    };
    /*\
     * Snap.animate
     [ method ]
     **
     * Runs generic animation of one number into another with a caring function
     **
     - from (number|array) number or array of numbers
     - to (number|array) number or array of numbers
     - setter (function) caring function that accepts one number argument
     - duration (number) duration, in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function to execute when animation ends
     = (object) animation object in @mina format
     o {
     o     id (string) animation id, consider it read-only,
     o     duration (function) gets or sets the duration of the animation,
     o     easing (function) easing,
     o     speed (function) gets or sets the speed of the animation,
     o     status (function) gets or sets the status of the animation,
     o     stop (function) stops the animation
     o }
     | var rect = Snap().rect(0, 0, 10, 10);
     | Snap.animate(0, 10, function (val) {
     |     rect.attr({
     |         x: val
     |     });
     | }, 1000);
     | // in given context is equivalent to
     | rect.animate({x: 10}, 1000);
    \*/
    Snap.animate = function (from, to, setter, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        var now = mina.time(),
            anim = mina(from, to, now, now + ms, mina.time, setter, easing);
        callback && eve.once("mina.finish." + anim.id, callback);
        return anim;
    };
    /*\
     * Element.stop
     [ method ]
     **
     * Stops all the animations for the current element
     **
     = (Element) the current element
    \*/
    elproto.stop = function () {
        var anims = this.inAnim();
        for (var i = 0, ii = anims.length; i < ii; i++) {
            anims[i].stop();
        }
        return this;
    };
    // SIERRA Element.animate(): For _attrs_, clarify if they represent the destination values, and if the animation executes relative to the element's current attribute values.
    // SIERRA would a _custom_ animation function be an SVG keySplines value?
    /*\
     * Element.animate
     [ method ]
     **
     * Animates the given attributes of the element
     **
     - attrs (object) key-value pairs of destination attributes
     - duration (number) duration of the animation in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function that executes when the animation ends
     = (Element) the current element
    \*/
    elproto.animate = function (attrs, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        if (attrs instanceof Animation) {
            callback = attrs.callback;
            easing = attrs.easing;
            ms = easing.dur;
            attrs = attrs.attr;
        }
        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,
            el = this;
        for (var key in attrs) if (attrs[has](key)) {
            if (el.equal) {
                eq = el.equal(key, Str(attrs[key]));
                from = eq.from;
                to = eq.to;
                f = eq.f;
            } else {
                from = +el.attr(key);
                to = +attrs[key];
            }
            var len = is(from, "array") ? from.length : 1;
            keys[key] = slice(fkeys.length, fkeys.length + len, f);
            fkeys = fkeys.concat(from);
            tkeys = tkeys.concat(to);
        }
        var now = mina.time(),
            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
                var attr = {};
                for (var key in keys) if (keys[has](key)) {
                    attr[key] = keys[key](val);
                }
                el.attr(attr);
            }, easing);
        el.anims[anim.id] = anim;
        anim._attrs = attrs;
        anim._callback = callback;
        eve.once("mina.finish." + anim.id, function () {
            delete el.anims[anim.id];
            callback && callback.call(el);
        });
        eve.once("mina.stop." + anim.id, function () {
            delete el.anims[anim.id];
        });
        return el;
    };
    var eldata = {};
    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value associated with given key. (Don’t confuse
     * with `data-` attributes)
     *
     * See also @Element.removeData
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0){
            eve("snap.data.get." + this.id, this, data, null);
            return data;
        }
        if (arguments.length == 1) {
            if (Snap.is(key, "object")) {
                for (var i in key) if (key[has](i)) {
                    this.data(i, key[i]);
                }
                return this;
            }
            eve("snap.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("snap.data.set." + this.id, this, value, key);
        return this;
    };
    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     - key (string) #optional key
     = (object) @Element
    \*/
    elproto.removeData = function (key) {
        if (key == null) {
            eldata[this.id] = {};
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
    /*\
     * Element.outerSVG
     [ method ]
     **
     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
     *
     * See also @Element.innerSVG
     = (string) SVG code for the element
    \*/
    /*\
     * Element.toString
     [ method ]
     **
     * See @Element.outerSVG
    \*/
    elproto.outerSVG = elproto.toString = toString(1);
    /*\
     * Element.innerSVG
     [ method ]
     **
     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
     = (string) SVG code for the element
    \*/
    elproto.innerSVG = toString();
    function toString(type) {
        return function () {
            var res = type ? "<" + this.type : "",
                attr = this.node.attributes,
                chld = this.node.childNodes;
            if (type) {
                for (var i = 0, ii = attr.length; i < ii; i++) {
                    res += " " + attr[i].name + '="' +
                            attr[i].value.replace(/"/g, '\\"') + '"';
                }
            }
            if (chld.length) {
                type && (res += ">");
                for (i = 0, ii = chld.length; i < ii; i++) {
                    if (chld[i].nodeType == 3) {
                        res += chld[i].nodeValue;
                    } else if (chld[i].nodeType == 1) {
                        res += wrap(chld[i]).toString();
                    }
                }
                type && (res += "</" + this.type + ">");
            } else {
                type && (res += "/>");
            }
            return res;
        };
    }
}(Element.prototype));
// SIERRA Snap.parse() accepts & returns a fragment, but there's no info on what it does in between. What if it doesn't parse?
/*\
 * Snap.parse
 [ method ]
 **
 * Parses SVG fragment and converts it into a @Fragment
 **
 - svg (string) SVG string
 = (Fragment) the @Fragment
\*/
Snap.parse = function (svg) {
    var f = glob.doc.createDocumentFragment(),
        full = true,
        div = glob.doc.createElement("div");
    svg = Str(svg);
    if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
        svg = "<svg>" + svg + "</svg>";
        full = false;
    }
    div.innerHTML = svg;
    svg = div.getElementsByTagName("svg")[0];
    if (svg) {
        if (full) {
            f = svg;
        } else {
            while (svg.firstChild) {
                f.appendChild(svg.firstChild);
            }
        }
    }
    div.innerHTML = E;
    return new Fragment(f);
};
function Fragment(frag) {
    this.node = frag;
}
/*\
 * Fragment.select
 [ method ]
 **
 * See @Element.select
\*/
Fragment.prototype.select = Element.prototype.select;
/*\
 * Fragment.selectAll
 [ method ]
 **
 * See @Element.selectAll
\*/
Fragment.prototype.selectAll = Element.prototype.selectAll;
// SIERRA Snap.fragment() could especially use a code example
/*\
 * Snap.fragment
 [ method ]
 **
 * Creates a DOM fragment from a given list of elements or strings
 **
 - varargs (…) SVG string
 = (Fragment) the @Fragment
\*/
Snap.fragment = function () {
    var args = Array.prototype.slice.call(arguments, 0),
        f = glob.doc.createDocumentFragment();
    for (var i = 0, ii = args.length; i < ii; i++) {
        var item = args[i];
        if (item.node && item.node.nodeType) {
            f.appendChild(item.node);
        }
        if (item.nodeType) {
            f.appendChild(item);
        }
        if (typeof item == "string") {
            f.appendChild(Snap.parse(item).node);
        }
    }
    return new Fragment(f);
};

function make(name, parent) {
    var res = $(name);
    parent.appendChild(res);
    var el = wrap(res);
    el.type = name;
    return el;
}
function Paper(w, h) {
    var res,
        desc,
        defs,
        proto = Paper.prototype;
    if (w && w.tagName == "svg") {
        if (w.snap in hub) {
            return hub[w.snap];
        }
        res = new Element(w);
        desc = w.getElementsByTagName("desc")[0];
        defs = w.getElementsByTagName("defs")[0];
        if (!desc) {
            desc = $("desc");
            desc.appendChild(glob.doc.createTextNode("Created with Snap"));
            res.node.appendChild(desc);
        }
        if (!defs) {
            defs = $("defs");
            res.node.appendChild(defs);
        }
        res.defs = defs;
        for (var key in proto) if (proto[has](key)) {
            res[key] = proto[key];
        }
        res.paper = res.root = res;
    } else {
        res = make("svg", glob.doc.body);
        $(res.node, {
            height: h,
            version: 1.1,
            width: w,
            xmlns: xmlns
        });
    }
    return res;
}
function wrap(dom) {
    if (!dom) {
        return dom;
    }
    if (dom instanceof Element || dom instanceof Fragment) {
        return dom;
    }
    if (dom.tagName == "svg") {
        return new Paper(dom);
    }
    return new Element(dom);
}
// gradients' helpers
function Gstops() {
    return this.selectAll("stop");
}
function GaddStop(color, offset) {
    var stop = $("stop"),
        attr = {
            offset: +offset + "%"
        };
    color = Snap.color(color);
    attr["stop-color"] = color.hex;
    if (color.opacity < 1) {
        attr["stop-opacity"] = color.opacity;
    }
    $(stop, attr);
    this.node.appendChild(stop);
    return this;
}
function GgetBBox() {
    if (this.type == "linearGradient") {
        var x1 = $(this.node, "x1") || 0,
            x2 = $(this.node, "x2") || 1,
            y1 = $(this.node, "y1") || 0,
            y2 = $(this.node, "y2") || 0;
        return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
    } else {
        var cx = this.node.cx || .5,
            cy = this.node.cy || .5,
            r = this.node.r || 0;
        return Snap._.box(cx - r, cy - r, r * 2, r * 2);
    }
}
function gradient(defs, str) {
    var grad = arrayFirstValue(eve("snap.util.grad.parse", null, str)),
        el;
    if (!grad) {
        return null;
    }
    grad.params.unshift(defs);
    if (grad.type.toLowerCase() == "l") {
        el = gradientLinear.apply(0, grad.params);
    } else {
        el = gradientRadial.apply(0, grad.params);
    }
    if (grad.type != grad.type.toLowerCase()) {
        $(el.node, {
            gradientUnits: "userSpaceOnUse"
        });
    }
    var stops = grad.stops,
        len = stops.length,
        start = 0,
        j = 0;
    function seed(i, end) {
        var step = (end - start) / (i - j);
        for (var k = j; k < i; k++) {
            stops[k].offset = +(+start + step * (k - j)).toFixed(2);
        }
        j = i;
        start = end;
    }
    len--;
    for (var i = 0; i < len; i++) if ("offset" in stops[i]) {
        seed(i, stops[i].offset);
    }
    stops[len].offset = stops[len].offset || 100;
    seed(len, stops[len].offset);
    for (i = 0; i <= len; i++) {
        var stop = stops[i];
        el.addStop(stop.color, stop.offset);
    }
    return el;
}
function gradientLinear(defs, x1, y1, x2, y2) {
    var el = make("linearGradient", defs);
    el.stops = Gstops;
    el.addStop = GaddStop;
    el.getBBox = GgetBBox;
    if (x1 != null) {
        $(el.node, {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
        });
    }
    return el;
}
function gradientRadial(defs, cx, cy, r, fx, fy) {
    var el = make("radialGradient", defs);
    el.stops = Gstops;
    el.addStop = GaddStop;
    el.getBBox = GgetBBox;
    if (cx != null) {
        $(el.node, {
            cx: cx,
            cy: cy,
            r: r
        });
    }
    if (fx != null && fy != null) {
        $(el.node, {
            fx: fx,
            fy: fy
        });
    }
    return el;
}
// Paper prototype methods
(function (proto) {
    /*\
     * Paper.el
     [ method ]
     **
     * Creates an element on paper with a given name and no attributes
     **
     - name (string) tag name
     - attr (object) attributes
     = (Element) the current element
     > Usage
     | var c = paper.circle(10, 10, 10); // is the same as...
     | var c = paper.el("circle").attr({
     |     cx: 10,
     |     cy: 10,
     |     r: 10
     | });
     | // and the same as
     | var c = paper.el("circle", {
     |     cx: 10,
     |     cy: 10,
     |     r: 10
     | });
    \*/
    proto.el = function (name, attr) {
        return make(name, this.node).attr(attr);
    };
    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - rx (number) #optional horizontal radius for rounded corners, default is 0
     - ry (number) #optional vertical radius for rounded corners, default is rx or 0
     = (object) the `rect` element
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
    proto.rect = function (x, y, w, h, rx, ry) {
        var attr;
        if (ry == null) {
            ry = rx;
        }
        if (is(x, "object") && "x" in x) {
            attr = x;
        } else if (x != null) {
            attr = {
                x: x,
                y: y,
                width: w,
                height: h
            };
            if (rx != null) {
                attr.rx = rx;
                attr.ry = ry;
            }
        }
        return this.el("rect", attr);
    };
    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) the `circle` element
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
    proto.circle = function (cx, cy, r) {
        var attr;
        if (is(cx, "object") && "cx" in cx) {
            attr = cx;
        } else if (cx != null) {
            attr = {
                cx: cx,
                cy: cy,
                r: r
            };
        }
        return this.el("circle", attr);
    };

    /*\
     * Paper.image
     [ method ]
     **
     * Places an image on the surface
     **
     - src (string) URI of the source image
     - x (number) x offset position
     - y (number) y offset position
     - width (number) width of the image
     - height (number) height of the image
     = (object) the `image` element
     * or
     = (object) Snap element object with type `image`
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
    proto.image = function (src, x, y, width, height) {
        var el = make("image", this.node);
        if (is(src, "object") && "src" in src) {
            el.attr(src);
        } else if (src != null) {
            var set = {
                "xlink:href": src,
                preserveAspectRatio: "none"
            };
            if (x != null && y != null) {
                set.x = x;
                set.y = y;
            }
            if (width != null && height != null) {
                set.width = width;
                set.height = height;
            } else {
                preload(src, function () {
                    $(el.node, {
                        width: this.offsetWidth,
                        height: this.offsetHeight
                    });
                });
            }
            $(el.node, set);
        }
        return el;
    };
    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) the `ellipse` element
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
    proto.ellipse = function (cx, cy, rx, ry) {
        var el = make("ellipse", this.node);
        if (is(cx, "object") && "cx" in cx) {
            el.attr(cx);
        } else if (cx != null) {
            el.attr({
                cx: cx,
                cy: cy,
                rx: rx,
                ry: ry
            });
        }
        return el;
    };
    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
    /*\
     * Paper.path
     [ method ]
     **
     * Creates a `<path>` element using the given string as the path's definition
     - pathString (string) #optional path string in SVG format
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
     | "M10,20L30,40"
     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
    \*/
    proto.path = function (d) {
        var el = make("path", this.node);
        if (is(d, "object") && !is(d, "array")) {
            el.attr(d);
        } else if (d) {
            el.attr({
                d: d
            });
        }
        return el;
    };
// SIERRA Paper.g(): Don't understand the code comment about the order being _different._ Wouldn't it be a rect followed by a circle?
    /*\
     * Paper.g
     [ method ]
     **
     * Creates a group element
     **
     - varargs (…) #optional elements to nest within the group
     = (object) the `g` element
     **
     > Usage
     | var c1 = paper.circle(),
     |     c2 = paper.rect(),
     |     g = paper.g(c2, c1); // note that the order of elements is different
     * or
     | var c1 = paper.circle(),
     |     c2 = paper.rect(),
     |     g = paper.g();
     | g.add(c2, c1);
    \*/
    /*\
     * Paper.group
     [ method ]
     **
     * See @Paper.g
    \*/
    proto.group = proto.g = function (first) {
        var el = make("g", this.node);
        el.add = add2group;
        for (var method in proto) if (proto[has](method)) {
            el[method] = proto[method];
        }
        if (arguments.length == 1 && first && !first.type) {
            el.attr(first);
        } else if (arguments.length) {
            el.add(Array.prototype.slice.call(arguments, 0));
        }
        return el;
    };
    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
     = (object) the `text` element
     **
     > Usage
     | var t1 = paper.text(50, 50, "Snap");
     | var t2 = paper.text(50, 50, ["S","n","a","p"]);
     | // Text path usage
     | t1.attr({textpath: "M10,10L100,100"});
     | // or
     | var pth = paper.path("M10,10L100,100");
     | t1.attr({textpath: pth});
    \*/
    proto.text = function (x, y, text) {
        var el = make("text", this.node);
        if (is(x, "object")) {
            el.attr(x);
        } else if (x != null) {
            el.attr({
                x: x,
                y: y,
                text: text || ""
            });
        }
        return el;
    };
    /*\
     * Paper.line
     [ method ]
     **
     * Draws a line
     **
     - x1 (number) x coordinate position of the start
     - y1 (number) y coordinate position of the start
     - x2 (number) x coordinate position of the end
     - y2 (number) y coordinate position of the end
     = (object) the `line` element
     **
     > Usage
     | var t1 = paper.line(50, 50, 100, 100);
    \*/
    proto.line = function (x1, y1, x2, y2) {
        var el = make("line", this.node);
        if (is(x1, "object")) {
            el.attr(x1);
        } else if (x1 != null) {
            el.attr({
                x1: x1,
                x2: x2,
                y1: y1,
                y2: y2
            });
        }
        return el;
    };
    /*\
     * Paper.polyline
     [ method ]
     **
     * Draws a polyline
     **
     - points (array) array of points
     * or
     - varargs (…) points
     = (object) the `polyline` element
     **
     > Usage
     | var p1 = paper.polyline([10, 10, 100, 100]);
     | var p2 = paper.polyline(10, 10, 100, 100);
    \*/
    proto.polyline = function (points) {
        if (arguments.length > 1) {
            points = Array.prototype.slice.call(arguments, 0);
        }
        var el = make("polyline", this.node);
        if (is(points, "object") && !is(points, "array")) {
            el.attr(points);
        } else if (points != null) {
            el.attr({
                points: points
            });
        }
        return el;
    };
    /*\
     * Paper.polygon
     [ method ]
     **
     * Draws a polygon. See @Paper.polyline
    \*/
    proto.polygon = function (points) {
        if (arguments.length > 1) {
            points = Array.prototype.slice.call(arguments, 0);
        }
        var el = make("polygon", this.node);
        if (is(points, "object") && !is(points, "array")) {
            el.attr(points);
        } else if (points != null) {
            el.attr({
                points: points
            });
        }
        return el;
    };
    // gradients
    (function () {
        /*\
         * Paper.gradient
         [ method ]
         **
         * Creates a gradient element
         **
         - gradient (string) gradient descriptor
         > Gradient Descriptor
         * The gradient descriptor is an expression formatted as
         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
         * either linear or radial.  The uppercase `L` or `R` letters
         * indicate absolute coordinates offset from the SVG surface.
         * Lowercase `l` or `r` letters indicate coordinates
         * calculated relative to the element to which the gradient is
         * applied.  Coordinates specify a linear gradient vector as
         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
         * `r` and optional `fx`, `fy` specifying a focal point away
         * from the center of the circle. Specify `<colors>` as a list
         * of dash-separated CSS color values.  Each color may be
         * followed by a custom offset value, separated with a colon
         * character.
         > Examples
         * Linear gradient, relative from top-left corner to bottom-right
         * corner, from black through red to white:
         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
         * Linear gradient, absolute from (0, 0) to (100, 100), from black
         * through red at 25% to white:
         | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25%-#fff");
         * Radial gradient, relative from the center of the element with radius
         * half the width, from black to white:
         | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
         * To apply the gradient:
         | paper.circle(50, 50, 40).attr({
         |     fill: g
         | });
         = (object) the `gradient` element
        \*/
        proto.gradient = function (str) {
            return gradient(this.defs, str);
        };
        proto.gradientLinear = function (x1, y1, x2, y2) {
            return gradientLinear(this.defs, x1, y1, x2, y2);
        };
        proto.gradientRadial = function (cx, cy, r, fx, fy) {
            return gradientRadial(this.defs, cx, cy, r, fx, fy);
        };
        /*\
         * Paper.toString
         [ method ]
         **
         * Returns SVG code for the @Paper
         = (string) SVG code for the @Paper
        \*/
        proto.toString = function () {
            var f = glob.doc.createDocumentFragment(),
                d = glob.doc.createElement("div"),
                svg = this.node.cloneNode(true),
                res;
            f.appendChild(d);
            d.appendChild(svg);
            $(svg, {xmlns: xmlns});
            res = d.innerHTML;
            f.removeChild(f.firstChild);
            return res;
        };
        /*\
         * Paper.clear
         [ method ]
         **
         * Removes all child nodes of the paper, except <defs>.
        \*/
        proto.clear = function () {
            var node = this.node.firstChild,
                next;
            while (node) {
                next = node.nextSibling;
                if (node.tagName != "defs") {
                    node.parentNode.removeChild(node);
                }
                node = next;
            }
        };
    }());
}(Paper.prototype));

// simple ajax
/*\
 * Snap.ajax
 [ method ]
 **
 * Simple implementation of Ajax
 **
 - url (string) URL
 - postData (object|string) data for post request
 - callback (function) callback
 - scope (object) #optional scope of callback
 * or
 - url (string) URL
 - callback (function) callback
 - scope (object) #optional scope of callback
 = (XMLHttpRequest) the XMLHttpRequest object, just in case
\*/
Snap.ajax = function (url, postData, callback, scope){
    var req = new XMLHttpRequest,
        id = ID();
    if (req) {
        if (is(postData, "function")) {
            scope = callback;
            callback = postData;
            postData = null;
        } else if (is(postData, "object")) {
            var pd = [];
            for (var key in postData) if (postData.hasOwnProperty(key)) {
                pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
            }
            postData = pd.join("&");
        }
        req.open((postData ? "POST" : "GET"), url, true);
        req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
        if (postData) {
            req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        }
        if (callback) {
            eve.once("snap.ajax." + id + ".0", callback);
            eve.once("snap.ajax." + id + ".200", callback);
            eve.once("snap.ajax." + id + ".304", callback);
        }
        req.onreadystatechange = function() {
            if (req.readyState != 4) return;
            eve("snap.ajax." + id + "." + req.status, scope, req);
        };
        if (req.readyState == 4) {
            return req;
        }
        req.send(postData);
        return req;
    }
};
/*\
 * Snap.load
 [ method ]
 **
 * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
 **
 - url (string) URL
 - callback (function) callback
 - scope (object) #optional scope of callback
\*/
Snap.load = function (url, callback, scope) {
    Snap.ajax(url, function (req) {
        var f = Snap.parse(req.responseText);
        scope ? callback.call(scope, f) : callback(f);
    });
};

// Attributes event handlers
eve.on("snap.util.attr.mask", function (value) {
    if (value instanceof Element || value instanceof Fragment) {
        eve.stop();
        if (value instanceof Fragment && value.node.childNodes.length == 1) {
            value = value.node.firstChild;
            getSomeDefs(this).appendChild(value);
            value = wrap(value);
        }
        if (value.type == "mask") {
            var mask = value;
        } else {
            mask = make("mask", getSomeDefs(this));
            mask.node.appendChild(value.node);
            !mask.node.id && $(mask.node, {
                id: mask.id
            });
        }
        $(this.node, {
            mask: URL(mask.id)
        });
    }
});
(function (clipIt) {
    eve.on("snap.util.attr.clip", clipIt);
    eve.on("snap.util.attr.clip-path", clipIt);
    eve.on("snap.util.attr.clipPath", clipIt);
}(function (value) {
    if (value instanceof Element || value instanceof Fragment) {
        eve.stop();
        if (value.type == "clipPath") {
            var clip = value;
        } else {
            clip = make("clipPath", getSomeDefs(this));
            clip.node.appendChild(value.node);
            !clip.node.id && $(clip.node, {
                id: clip.id
            });
        }
        $(this.node, {
            "clip-path": URL(clip.id)
        });
    }
}));
function fillStroke(name) {
    return function (value) {
        eve.stop();
        if (value instanceof Fragment && value.node.childNodes.length == 1 &&
            (value.node.firstChild.tagName == "radialGradient" ||
            value.node.firstChild.tagName == "linearGradient" ||
            value.node.firstChild.tagName == "pattern")) {
            value = value.node.firstChild;
            getSomeDefs(this).appendChild(value);
            value = wrap(value);
        }
        if (value instanceof Element) {
            if (value.type == "radialGradient" || value.type == "linearGradient"
               || value.type == "pattern") {
                if (!value.node.id) {
                    $(value.node, {
                        id: value.id
                    });
                }
                var fill = URL(value.node.id);
            } else {
                fill = value.attr(name);
            }
        } else {
            fill = Snap.color(value);
            if (fill.error) {
                var grad = gradient(getSomeDefs(this), value);
                if (grad) {
                    if (!grad.node.id) {
                        $(grad.node, {
                            id: grad.id
                        });
                    }
                    fill = URL(grad.node.id);
                } else {
                    fill = value;
                }
            } else {
                fill = Str(fill);
            }
        }
        var attrs = {};
        attrs[name] = fill;
        $(this.node, attrs);
        this.node.style[name] = E;
    };
}
eve.on("snap.util.attr.fill", fillStroke("fill"));
eve.on("snap.util.attr.stroke", fillStroke("stroke"));
var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
eve.on("snap.util.grad.parse", function parseGrad(string) {
    string = Str(string);
    var tokens = string.match(gradrg);
    if (!tokens) {
        return null;
    }
    var type = tokens[1],
        params = tokens[2],
        stops = tokens[3];
    params = params.split(/\s*,\s*/).map(function (el) {
        return +el == el ? +el : el;
    });
    if (params.length == 1 && params[0] == 0) {
        params = [];
    }
    stops = stops.split("-");
    stops = stops.map(function (el) {
        el = el.split(":");
        var out = {
            color: el[0]
        };
        if (el[1]) {
            out.offset = el[1];
        }
        return out;
    });
    return {
        type: type,
        params: params,
        stops: stops
    };
});

eve.on("snap.util.attr.d", function (value) {
    eve.stop();
    if (is(value, "array") && is(value[0], "array")) {
        value = Snap.path.toString.call(value);
    }
    value = Str(value);
    if (value.match(/[ruo]/i)) {
        value = Snap.path.toAbsolute(value);
    }
    $(this.node, {d: value});
})(-1);
eve.on("snap.util.attr.#text", function (value) {
    eve.stop();
    value = Str(value);
    var txt = glob.doc.createTextNode(value);
    while (this.node.firstChild) {
        this.node.removeChild(this.node.firstChild);
    }
    this.node.appendChild(txt);
})(-1);
eve.on("snap.util.attr.path", function (value) {
    eve.stop();
    this.attr({d: value});
})(-1);
eve.on("snap.util.attr.viewBox", function (value) {
    var vb;
    if (is(value, "object") && "x" in value) {
        vb = [value.x, value.y, value.width, value.height].join(" ");
    } else if (is(value, "array")) {
        vb = value.join(" ");
    } else {
        vb = value;
    }
    $(this.node, {
        viewBox: vb
    });
    eve.stop();
})(-1);
eve.on("snap.util.attr.transform", function (value) {
    this.transform(value);
    eve.stop();
})(-1);
eve.on("snap.util.attr.r", function (value) {
    if (this.type == "rect") {
        eve.stop();
        $(this.node, {
            rx: value,
            ry: value
        });
    }
})(-1);
eve.on("snap.util.attr.textpath", function (value) {
    eve.stop();
    if (this.type == "text") {
        var id, tp, node;
        if (!value && this.textPath) {
            tp = this.textPath;
            while (tp.node.firstChild) {
                this.node.appendChild(tp.node.firstChild);
            }
            tp.remove();
            delete this.textPath;
            return;
        }
        if (is(value, "string")) {
            var defs = getSomeDefs(this),
                path = wrap(defs.parentNode).path(value);
            defs.appendChild(path.node);
            id = path.id;
            path.attr({id: id});
        } else {
            value = wrap(value);
            if (value instanceof Element) {
                id = value.attr("id");
                if (!id) {
                    id = value.id;
                    value.attr({id: id});
                }
            }
        }
        if (id) {
            tp = this.textPath;
            node = this.node;
            if (tp) {
                tp.attr({"xlink:href": "#" + id});
            } else {
                tp = $("textPath", {
                    "xlink:href": "#" + id
                });
                while (node.firstChild) {
                    tp.appendChild(node.firstChild);
                }
                node.appendChild(tp);
                this.textPath = wrap(tp);
            }
        }
    }
})(-1);
eve.on("snap.util.attr.text", function (value) {
    if (this.type == "text") {
        var i = 0,
            node = this.node,
            tuner = function (chunk) {
                var out = $("tspan");
                if (is(chunk, "array")) {
                    for (var i = 0; i < chunk.length; i++) {
                        out.appendChild(tuner(chunk[i]));
                    }
                } else {
                    out.appendChild(glob.doc.createTextNode(chunk));
                }
                out.normalize && out.normalize();
                return out;
            };
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
        var tuned = tuner(value);
        while (tuned.firstChild) {
            node.appendChild(tuned.firstChild);
        }
    }
    eve.stop();
})(-1);
// default
var cssAttr = {
    "alignment-baseline": 0,
    "baseline-shift": 0,
    "clip": 0,
    "clip-path": 0,
    "clip-rule": 0,
    "color": 0,
    "color-interpolation": 0,
    "color-interpolation-filters": 0,
    "color-profile": 0,
    "color-rendering": 0,
    "cursor": 0,
    "direction": 0,
    "display": 0,
    "dominant-baseline": 0,
    "enable-background": 0,
    "fill": 0,
    "fill-opacity": 0,
    "fill-rule": 0,
    "filter": 0,
    "flood-color": 0,
    "flood-opacity": 0,
    "font": 0,
    "font-family": 0,
    "font-size": 0,
    "font-size-adjust": 0,
    "font-stretch": 0,
    "font-style": 0,
    "font-variant": 0,
    "font-weight": 0,
    "glyph-orientation-horizontal": 0,
    "glyph-orientation-vertical": 0,
    "image-rendering": 0,
    "kerning": 0,
    "letter-spacing": 0,
    "lighting-color": 0,
    "marker": 0,
    "marker-end": 0,
    "marker-mid": 0,
    "marker-start": 0,
    "mask": 0,
    "opacity": 0,
    "overflow": 0,
    "pointer-events": 0,
    "shape-rendering": 0,
    "stop-color": 0,
    "stop-opacity": 0,
    "stroke": 0,
    "stroke-dasharray": 0,
    "stroke-dashoffset": 0,
    "stroke-linecap": 0,
    "stroke-linejoin": 0,
    "stroke-miterlimit": 0,
    "stroke-opacity": 0,
    "stroke-width": 0,
    "text-anchor": 0,
    "text-decoration": 0,
    "text-rendering": 0,
    "unicode-bidi": 0,
    "visibility": 0,
    "word-spacing": 0,
    "writing-mode": 0
};

eve.on("snap.util.attr", function (value) {
    var att = eve.nt(),
        attr = {};
    att = att.substring(att.lastIndexOf(".") + 1);
    attr[att] = value;
    var style = att.replace(/-(\w)/gi, function (all, letter) {
            return letter.toUpperCase();
        }),
        css = att.replace(/[A-Z]/g, function (letter) {
            return "-" + letter.toLowerCase();
        });
    if (cssAttr[has](css)) {
        this.node.style[style] = value == null ? E : value;
    } else {
        $(this.node, attr);
    }
});
eve.on("snap.util.getattr.transform", function () {
    eve.stop();
    return this.transform();
})(-1);
eve.on("snap.util.getattr.textpath", function () {
    eve.stop();
    return this.textPath;
})(-1);
// Markers
(function () {
    function getter(end) {
        return function () {
            eve.stop();
            var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
            if (style == "none") {
                return style;
            } else {
                return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
            }
        };
    }
    function setter(end) {
        return function (value) {
            eve.stop();
            var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
            if (value == "" || !value) {
                this.node.style[name] = "none";
                return;
            }
            if (value.type == "marker") {
                var id = value.node.id;
                if (!id) {
                    $(value.node, {id: value.id});
                }
                this.node.style[name] = URL(id);
                return;
            }
        };
    }
    eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
    eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
    eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
    eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
    eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
    eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
    eve.on("snap.util.attr.marker-end", setter("end"))(-1);
    eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
    eve.on("snap.util.attr.marker-start", setter("start"))(-1);
    eve.on("snap.util.attr.markerStart", setter("start"))(-1);
    eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
    eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
}());
eve.on("snap.util.getattr.r", function () {
    if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
        eve.stop();
        return $(this.node, "rx");
    }
})(-1);
function textExtract(node) {
    var out = [];
    var children = node.childNodes;
    for (var i = 0, ii = children.length; i < ii; i++) {
        var chi = children[i];
        if (chi.nodeType == 3) {
            out.push(chi.nodeValue);
        }
        if (chi.tagName == "tspan") {
            if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
                out.push(chi.firstChild.nodeValue);
            } else {
                out.push(textExtract(chi));
            }
        }
    }
    return out;
}
eve.on("snap.util.getattr.text", function () {
    if (this.type == "text" || this.type == "tspan") {
        eve.stop();
        var out = textExtract(this.node);
        return out.length == 1 ? out[0] : out;
    }
})(-1);
eve.on("snap.util.getattr.#text", function () {
    return this.node.textContent;
})(-1);
eve.on("snap.util.getattr.viewBox", function () {
    eve.stop();
    var vb = $(this.node, "viewBox").split(separator);
    return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
    // TODO: investigate why I need to z-index it
})(-1);
eve.on("snap.util.getattr.points", function () {
    var p = $(this.node, "points");
    eve.stop();
    return p.split(separator);
});
eve.on("snap.util.getattr.path", function () {
    var p = $(this.node, "d");
    eve.stop();
    return p;
});
// default
eve.on("snap.util.getattr", function () {
    var att = eve.nt();
    att = att.substring(att.lastIndexOf(".") + 1);
    var css = att.replace(/[A-Z]/g, function (letter) {
        return "-" + letter.toLowerCase();
    });
    if (cssAttr[has](css)) {
        return glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
    } else {
        return $(this.node, att);
    }
});
var getOffset = function (elem) {
    var box = elem.getBoundingClientRect(),
        doc = elem.ownerDocument,
        body = doc.body,
        docElem = doc.documentElement,
        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
    return {
        y: top,
        x: left
    };
};
/*\
 * Snap.getElementByPoint
 [ method ]
 **
 * Returns you topmost element under given point.
 **
 = (object) Snap element object
 - x (number) x coordinate from the top left corner of the window
 - y (number) y coordinate from the top left corner of the window
 > Usage
 | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
\*/
Snap.getElementByPoint = function (x, y) {
    var paper = this,
        svg = paper.canvas,
        target = glob.doc.elementFromPoint(x, y);
    if (glob.win.opera && target.tagName == "svg") {
        var so = getOffset(target),
            sr = target.createSVGRect();
        sr.x = x - so.x;
        sr.y = y - so.y;
        sr.width = sr.height = 1;
        var hits = target.getIntersectionList(sr, null);
        if (hits.length) {
            target = hits[hits.length - 1];
        }
    }
    if (!target) {
        return null;
    }
    return wrap(target);
};
/*\
 * Snap.plugin
 [ method ]
 **
 * Let you write plugins. You pass in a function with four arguments, like this:
 | Snap.plugin(function (Snap, Element, Paper, global) {
 |     Snap.newmethod = function () {};
 |     Element.prototype.newmethod = function () {};
 |     Paper.prototype.newmethod = function () {};
 | });
 * Inside the function you have access to all main objects (and their
 * prototypes). This allow you to extend anything you want.
 **
 - f (function) your plugin body
\*/
Snap.plugin = function (f) {
    f(Snap, Element, Paper, glob);
};
glob.win.Snap = Snap;
return Snap;
}(window || this));

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        is = Snap.is,
        clone = Snap._.clone,
        has = "hasOwnProperty",
        p2s = /,?([a-z]),?/gi,
        toFloat = parseFloat,
        math = Math,
        PI = math.PI,
        mmin = math.min,
        mmax = math.max,
        pow = math.pow,
        abs = math.abs;
    function paths(ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function () {
            for (var key in p) if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    }
    function box(x, y, width, height) {
        if (x == null) {
            x = y = width = height = 0;
        }
        if (y == null) {
            y = x.y;
            width = x.width;
            height = x.height;
            x = x.x;
        }
        return {
            x: x,
            y: y,
            width: width,
            w: width,
            height: height,
            h: height,
            x2: x + width,
            y2: y + height,
            cx: x + width / 2,
            cy: y + height / 2,
            r1: math.min(width, height) / 2,
            r2: math.max(width, height) / 2,
            r0: math.sqrt(width * width + height * height) / 2,
            path: rectPath(x, y, width, height),
            vb: [x, y, width, height].join(" ")
        };
    }
    function toString() {
        return this.join(",").replace(p2s, "$1");
    }
    function pathClone(pathArray) {
        var res = clone(pathArray);
        res.toString = toString;
        return res;
    }
    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) {
            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } else {
            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,
                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    }
    function getLengthFactory(istotal, subpath) {
        function O(val) {
            return +(+val).toFixed(3);
        }
        return Snap._.cacher(function (path, length, onlystart) {
            if (path instanceof Element) {
                path = path.attr("d");
            }
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
                len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += [
                                "C" + O(point.start.x),
                                O(point.start.y),
                                O(point.m.x),
                                O(point.m.y),
                                O(point.x),
                                O(point.y)
                            ];
                            if (onlystart) {return sp;}
                            subpaths.start = sp;
                            sp = [
                                "M" + O(point.x),
                                O(point.y) + "C" + O(point.n.x),
                                O(point.n.y),
                                O(point.end.x),
                                O(point.end.y),
                                O(p[5]),
                                O(p[6])
                            ].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return point;
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            return point;
        }, null, Snap._.clone);
    }
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
        // (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: {x: mx, y: my},
            n: {x: nx, y: ny},
            start: {x: ax, y: ay},
            end: {x: cx, y: cy},
            alpha: alpha
        };
    }
    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!Snap.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return box(
            bbox.min.x,
            bbox.min.y,
            bbox.max.x - bbox.min.x,
            bbox.max.y - bbox.min.y
        );
    }
    function isPointInsideBBox(bbox, x, y) {
        return  x >= bbox.x &&
                x <= bbox.x + bbox.width &&
                y >= bbox.y &&
                y <= bbox.y + bbox.height;
    }
    function isBBoxIntersect(bbox1, bbox2) {
        bbox1 = box(bbox1);
        bbox2 = box(bbox2);
        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    }
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],
            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
        ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
        ) {
            return;
        }
        return {x: px, y: py};
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = bezierBBox(bez1),
            bbox2 = bezierBBox(bez2);
        if (!isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = ~~(l1 / 5),
            n2 = ~~(l2 / 5),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
            dots1.push({x: p.x, y: p.y, t: i / n1});
        }
        for (i = 0; i < n2 + 1; i++) {
            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
            dots2.push({x: p.x, y: p.y, t: i / n2});
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: t1,
                                t2: t2
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    function pathIntersection(path1, path2) {
        return interPathHelper(path1, path2);
    }
    function pathIntersectionNumber(path1, path2) {
        return interPathHelper(path1, path2, 1);
    }
    function interPathHelper(path1, path2, justCount) {
        path1 = path2curve(path1);
        path2 = path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    function isPointInsidePath(path, x, y) {
        var bbox = pathBBox(path);
        return isPointInsideBBox(bbox, x, y) &&
               interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    }
    function pathBBox(path) {
        var pth = paths(path);
        if (pth.bbox) {
            return clone(pth.bbox);
        }
        if (!path) {
            return box();
        }
        path = path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X.concat(dim.min.x, dim.max.x);
                Y = Y.concat(dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin.apply(0, X),
            ymin = mmin.apply(0, Y),
            xmax = mmax.apply(0, X),
            ymax = mmax.apply(0, Y),
            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
        pth.bbox = clone(bb);
        return bb;
    }
    function rectPath(x, y, w, h, r) {
        if (r) {
            return [
                ["M", x + r, y],
                ["l", w - r * 2, 0],
                ["a", r, r, 0, 0, 1, r, r],
                ["l", 0, h - r * 2],
                ["a", r, r, 0, 0, 1, -r, r],
                ["l", r * 2 - w, 0],
                ["a", r, r, 0, 0, 1, -r, -r],
                ["l", 0, r * 2 - h],
                ["a", r, r, 0, 0, 1, r, -r],
                ["z"]
            ];
        }
        var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        res.toString = toString;
        return res;
    }
    function ellipsePath(x, y, rx, ry, a) {
        if (a == null && ry == null) {
            ry = rx;
        }
        if (a != null) {
            var rad = Math.PI / 180,
                x1 = x + rx * Math.cos(-ry * rad),
                x2 = x + rx * Math.cos(-a * rad),
                y1 = y + rx * Math.sin(-ry * rad),
                y2 = y + rx * Math.sin(-a * rad),
                res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
        } else {
            res = [
                ["M", x, y],
                ["m", 0, -ry],
                ["a", rx, ry, 0, 1, 1, 0, 2 * ry],
                ["a", rx, ry, 0, 1, 1, 0, -2 * ry],
                ["z"]
            ];
        }
        res.toString = toString;
        return res;
    }
    var unit2px = Snap._unit2px,
        getPath = {
        path: function (el) {
            return el.attr("path");
        },
        circle: function (el) {
            var attr = unit2px(el);
            return ellipsePath(attr.cx, attr.cy, attr.r);
        },
        ellipse: function (el) {
            var attr = unit2px(el);
            return ellipsePath(attr.cx, attr.cy, attr.rx, attr.ry);
        },
        rect: function (el) {
            var attr = unit2px(el);
            return rectPath(attr.x, attr.y, attr.width, attr.height, attr.rx, attr.ry);
        },
        image: function (el) {
            var attr = unit2px(el);
            return rectPath(attr.x, attr.y, attr.width, attr.height);
        },
        text: function (el) {
            var bbox = el.node.getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        },
        g: function (el) {
            var bbox = el.node.getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        },
        symbol: function (el) {
            var bbox = el.getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        },
        line: function (el) {
            return "M" + [el.attr("x1"), el.attr("y1"), el.attr("x2"), el.attr("y2")];
        },
        polyline: function (el) {
            return "M" + el.attr("points");
        },
        polygon: function (el) {
            return "M" + el.attr("points") + "z";
        },
        svg: function (el) {
            var bbox = el.node.getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        },
        deflt: function (el) {
            var bbox = el.node.getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        }
    };
    function pathToRelative(pathArray) {
        var pth = paths(pathArray),
            lowerCase = String.prototype.toLowerCase;
        if (pth.rel) {
            return pathClone(pth.rel);
        }
        if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
            pathArray = Snap.parsePathString(pathArray);
        }
        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        if (pathArray[0][0] == "M") {
            x = pathArray[0][1];
            y = pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res.push(["M", x, y]);
        }
        for (var i = start, ii = pathArray.length; i < ii; i++) {
            var r = res[i] = [],
                pa = pathArray[i];
            if (pa[0] != lowerCase.call(pa[0])) {
                r[0] = lowerCase.call(pa[0]);
                switch (r[0]) {
                    case "a":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] - x).toFixed(3);
                        r[7] = +(pa[7] - y).toFixed(3);
                        break;
                    case "v":
                        r[1] = +(pa[1] - y).toFixed(3);
                        break;
                    case "m":
                        mx = pa[1];
                        my = pa[2];
                    default:
                        for (var j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                        }
                }
            } else {
                r = res[i] = [];
                if (pa[0] == "m") {
                    mx = pa[1] + x;
                    my = pa[2] + y;
                }
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    res[i][k] = pa[k];
                }
            }
            var len = res[i].length;
            switch (res[i][0]) {
                case "z":
                    x = mx;
                    y = my;
                    break;
                case "h":
                    x += +res[i][len - 1];
                    break;
                case "v":
                    y += +res[i][len - 1];
                    break;
                default:
                    x += +res[i][len - 2];
                    y += +res[i][len - 1];
            }
        }
        res.toString = toString;
        pth.rel = pathClone(res);
        return res;
    }
    function pathToAbsolute(pathArray) {
        var pth = paths(pathArray);
        if (pth.abs) {
            return pathClone(pth.abs);
        }
        if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) { // rough assumption
            pathArray = Snap.parsePathString(pathArray);
        }
        if (!pathArray || !pathArray.length) {
            return [["M", 0, 0]];
        }
        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0,
            pa0;
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length == 3 &&
            pathArray[0][0] == "M" &&
            pathArray[1][0].toUpperCase() == "R" &&
            pathArray[2][0].toUpperCase() == "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            pa0 = pa[0];
            if (pa0 != pa0.toUpperCase()) {
                r[0] = pa0.toUpperCase();
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] + x);
                        r[7] = +(pa[7] + y);
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y].concat(pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res.concat(catmullRom2bezier(dots, crz));
                        break;
                    case "O":
                        res.pop();
                        dots = ellipsePath(x, y, pa[1], pa[2]);
                        dots.push(dots[0]);
                        res = res.concat(dots);
                        break;
                    case "U":
                        res.pop();
                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                        r = ["U"].concat(res[res.length - 1].slice(-2));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + ((j % 2) ? x : y);
                        }
                }
            } else if (pa0 == "R") {
                dots = [x, y].concat(pa.slice(1));
                res.pop();
                res = res.concat(catmullRom2bezier(dots, crz));
                r = ["R"].concat(pa.slice(-2));
            } else if (pa0 == "O") {
                res.pop();
                dots = ellipsePath(x, y, pa[1], pa[2]);
                dots.push(dots[0]);
                res = res.concat(dots);
            } else if (pa0 == "U") {
                res.pop();
                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                r = ["U"].concat(res[res.length - 1].slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            pa0 = pa0.toUpperCase();
            if (pa0 != "O") {
                switch (r[0]) {
                    case "Z":
                        x = mx;
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
        }
        res.toString = toString;
        pth.abs = pathClone(res);
        return res;
    }
    function l2c(x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    }
    function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
            _23 = 2 / 3;
        return [
                _13 * x1 + _23 * ax,
                _13 * y1 + _23 * ay,
                _13 * x2 + _23 * ax,
                _13 * y2 + _23 * ay,
                x2,
                y2
            ];
    }
    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
            rad = PI / 180 * (+angle || 0),
            res = [],
            xy,
            rotate = Snap._.cacher(function (x, y, rad) {
                var X = x * math.cos(rad) - y * math.sin(rad),
                    Y = x * math.sin(rad) + y * math.cos(rad);
                return {x: X, y: Y};
            });
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = math.cos(PI / 180 * angle),
                sin = math.sin(PI / 180 * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2;
            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
                ry2 = ry * ry,
                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
                x2old = x2,
                y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = math.cos(f1),
            s1 = math.sin(f1),
            c2 = math.cos(f2),
            s2 = math.sin(f2),
            t = math.tan(df / 4),
            hx = 4 / 3 * rx * t,
            hy = 4 / 3 * ry * t,
            m1 = [x1, y1],
            m2 = [x1 + hx * s1, y1 - hy * c1],
            m3 = [x2 + hx * s2, y2 - hy * c2],
            m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4].concat(res);
        } else {
            res = [m2, m3, m4].concat(res).join().split(",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    }
    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t;
        return {
            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
        };
    }
    function curveDim(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
            b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
            c = p1x - c1x,
            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
            y = [p1y, p2y],
            x = [p1x, p2x],
            dot;
        abs(t1) > "1e12" && (t1 = .5);
        abs(t2) > "1e12" && (t2 = .5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
        b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
        c = p1y - c1y;
        t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
        t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
        abs(t1) > "1e12" && (t1 = .5);
        abs(t2) > "1e12" && (t2 = .5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        return {
            min: {x: mmin.apply(0, x), y: mmin.apply(0, y)},
            max: {x: mmax.apply(0, x), y: mmax.apply(0, y)}
        };
    }
    function path2curve(path, path2) {
        var pth = !path2 && paths(path);
        if (!path2 && pth.curve) {
            return pathClone(pth.curve);
        }
        var p = pathToAbsolute(path),
            p2 = path2 && pathToAbsolute(path2),
            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            processPath = function (path, d) {
                var nx, ny;
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in {T:1, Q:1}) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                        break;
                    case "S":
                        nx = d.x + (d.x - (d.bx || d.x));
                        ny = d.y + (d.y - (d.by || d.y));
                        path = ["C", nx, ny].concat(path.slice(1));
                        break;
                    case "T":
                        d.qx = d.x + (d.x - (d.qx || d.x));
                        d.qy = d.y + (d.y - (d.qy || d.y));
                        path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
            fixArc = function (pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            fixM = function (path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            };
        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] = processPath(p[i], attrs);
            fixArc(p, i);
            p2 && (p2[i] = processPath(p2[i], attrs2));
            p2 && fixArc(p2, i);
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
                seg2 = p2 && p2[i],
                seglen = seg.length,
                seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }
        if (!p2) {
            pth.curve = pathClone(p);
        }
        return p2 ? [p, p2] : p;
    }
    function mapPath(path, matrix) {
        if (!matrix) {
            return path;
        }
        var x, y, i, j, ii, jj, pathi;
        path = path2curve(path);
        for (i = 0, ii = path.length; i < ii; i++) {
            pathi = path[i];
            for (j = 1, jj = pathi.length; j < jj; j += 2) {
                x = matrix.x(pathi[j], pathi[j + 1]);
                y = matrix.y(pathi[j], pathi[j + 1]);
                pathi[j] = x;
                pathi[j + 1] = y;
            }
        }
        return path;
    }

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                        {x: +crp[i - 2], y: +crp[i - 1]},
                        {x: +crp[i],     y: +crp[i + 1]},
                        {x: +crp[i + 2], y: +crp[i + 3]},
                        {x: +crp[i + 4], y: +crp[i + 5]}
                    ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                  (p[1].x + 6 * p[2].x - p[3].x) / 6,
                  (p[1].y + 6*p[2].y - p[3].y) / 6,
                  p[2].x,
                  p[2].y
            ]);
        }

        return d;
    }

    // export
    Snap.path = paths;

    /*\
     * Snap.path.getTotalLength
     [ method ]
     **
     * Returns the length of the given path in pixels
     **
     - path (string) SVG path string
     **
     = (number) length
    \*/
    Snap.path.getTotalLength = getTotalLength;
    /*\
     * Snap.path.getPointAtLength
     [ method ]
     **
     * Returns the coordinates of the point located at the given length along the given path
     **
     - path (string) SVG path string
     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate,
     o     y: (number) y coordinate,
     o     alpha: (number) angle of derivative
     o }
    \*/
    Snap.path.getPointAtLength = getPointAtLength;
    /*\
     * Snap.path.getSubpath
     [ method ]
     **
     * Returns the subpath of a given path between given start and end lengths
     **
     - path (string) SVG path string
     - from (number) length, in pixels, from the start of the path to the start of the segment
     - to (number) length, in pixels, from the start of the path to the end of the segment
     **
     = (string) path string definition for the segment
    \*/
    Snap.path.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns the length of the path in pixels (only works for `path` elements)
     = (number) length
    \*/
    elproto.getTotalLength = function () {
        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }
    };
    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
    /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
     **
     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate,
     o     y: (number) y coordinate,
     o     alpha: (number) angle of derivative
     o }
    \*/
    elproto.getPointAtLength = function (length) {
        return getPointAtLength(this.attr("d"), length);
    };
    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
    /*\
     * Element.getSubpath
     [ method ]
     **
     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
     **
     - from (number) length, in pixels, from the start of the path to the start of the segment
     - to (number) length, in pixels, from the start of the path to the end of the segment
     **
     = (string) path string definition for the segment
    \*/
    elproto.getSubpath = function (from, to) {
        return Snap.path.getSubpath(this.attr("d"), from, to);
    };
    Snap._.box = box;
    /*\
     * Snap.path.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Finds dot coordinates on the given cubic beziér curve at the given t
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point,
     o     y: (number) y coordinate of the point,
     o     m: {
     o         x: (number) x coordinate of the left anchor,
     o         y: (number) y coordinate of the left anchor
     o     },
     o     n: {
     o         x: (number) x coordinate of the right anchor,
     o         y: (number) y coordinate of the right anchor
     o     },
     o     start: {
     o         x: (number) x coordinate of the start of the curve,
     o         y: (number) y coordinate of the start of the curve
     o     },
     o     end: {
     o         x: (number) x coordinate of the end of the curve,
     o         y: (number) y coordinate of the end of the curve
     o     },
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
    Snap.path.findDotsAtSegment = findDotsAtSegment;
    /*\
     * Snap.path.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Returns the bounding box of a given cubic beziér curve
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for beziér curve
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box,
     o     y: (number) y coordinate of the left top point of the box,
     o     x2: (number) x coordinate of the right bottom point of the box,
     o     y2: (number) y coordinate of the right bottom point of the box,
     o     width: (number) width of the box,
     o     height: (number) height of the box
     o }
    \*/
    Snap.path.bezierBBox = bezierBBox;
    /*\
     * Snap.path.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding box
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point is inside
    \*/
    Snap.path.isPointInsideBBox = isPointInsideBBox;
    /*\
     * Snap.path.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if bounding boxes intersect
    \*/
    Snap.path.isBBoxIntersect = isBBoxIntersect;
    /*\
     * Snap.path.intersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point,
     o         y: (number) y coordinate of the point,
     o         t1: (number) t value for segment of path1,
     o         t2: (number) t value for segment of path2,
     o         segment1: (number) order number for segment of path1,
     o         segment2: (number) order number for segment of path2,
     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,
     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
     o     }
     o ]
    \*/
    Snap.path.intersection = pathIntersection;
    Snap.path.intersectionNumber = pathIntersectionNumber;
    /*\
     * Snap.path.isPointInside
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     *
     * Note: fill mode doesn’t affect the result of this method.
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) `true` if point is inside the path
    \*/
    Snap.path.isPointInside = isPointInsidePath;
    /*\
     * Snap.path.getBBox
     [ method ]
     **
     * Utility method
     **
     * Returns the bounding box of a given path
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box,
     o     y: (number) y coordinate of the left top point of the box,
     o     x2: (number) x coordinate of the right bottom point of the box,
     o     y2: (number) y coordinate of the right bottom point of the box,
     o     width: (number) width of the box,
     o     height: (number) height of the box
     o }
    \*/
    Snap.path.getBBox = pathBBox;
    Snap.path.get = getPath;
    /*\
     * Snap.path.toRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path coordinates into relative values
     - path (string) path string
     = (array) path string
    \*/
    Snap.path.toRelative = pathToRelative;
    /*\
     * Snap.path.toAbsolute
     [ method ]
     **
     * Utility method
     **
     * Converts path coordinates into absolute values
     - path (string) path string
     = (array) path string
    \*/
    Snap.path.toAbsolute = pathToAbsolute;
    /*\
     * Snap.path.toCubic
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic beziér curves
     - pathString (string|array) path string or array of segments
     = (array) array of segments
    \*/
    Snap.path.toCubic = path2curve;
    /*\
     * Snap.path.map
     [ method ]
     **
     * Transform the path string with the given matrix
     - path (string) path string
     - matrix (object) see @Matrix
     = (string) transformed path string
    \*/
    Snap.path.map = mapPath;
    Snap.path.toString = toString;
    Snap.path.clone = pathClone;
});
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var mmax = Math.max,
        mmin = Math.min;

    // Set
    var Set = function (items) {
        this.items = [];
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i]) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    },
    setproto = Set.prototype;
    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set
     = (object) original element
    \*/
    setproto.push = function () {
        var item,
            len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it
     = (object) element
    \*/
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set
     *
     * If the function returns `false`, the loop stops running.
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    setproto.remove = function () {
        while (this.length) {
            this.pop().remove();
        }
        return this;
    };
    setproto.attr = function (value) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            this.items[i].attr(value);
        }
        return this;
    };
    /*\
     * Set.clear
     [ method ]
     **
     * Removes all elements from the set
    \*/
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    /*\
     * Set.splice
     [ method ]
     **
     * Removes range of elements from the set
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion… (object) #optional elements to insert
     = (object) set elements that were deleted
    \*/
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     - element (object) element to remove
     = (boolean) `true` if object was found and removed from the set
    \*/
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
        return false;
    };
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    setproto.getBBox = function () {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
            var box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin.apply(0, x);
        y = mmin.apply(0, y);
        x2 = mmax.apply(0, x2);
        y2 = mmax.apply(0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y,
            cx: x + (x2 - x) / 2,
            cy: y + (y2 - y) / 2
        };
    };
    setproto.clone = function (s) {
        s = new Set;
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Snap\u2018s set";
    };
    setproto.type = "set";
    // export
    Snap.set = function () {
        var set = new Set;
        if (arguments.length) {
            set.push.apply(set, Array.prototype.slice.call(arguments, 0));
        }
        return set;
    };
});
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var names = {},
        reUnit = /[a-z]+$/i,
        Str = String;
    names.stroke = names.fill = "colour";
    function getEmpty(item) {
        var l = item[0];
        switch (l.toLowerCase()) {
            case "t": return [l, 0, 0];
            case "m": return [l, 1, 0, 0, 1, 0, 0];
            case "r": if (item.length == 4) {
                return [l, 0, item[2], item[3]];
            } else {
                return [l, 0];
            }
            case "s": if (item.length == 5) {
                return [l, 1, 1, item[3], item[4]];
            } else if (item.length == 3) {
                return [l, 1, 1];
            } else {
                return [l, 1];
            }
        }
    }
    function equaliseTransform(t1, t2, getBBox) {
        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
        t1 = Snap.parseTransformString(t1) || [];
        t2 = Snap.parseTransformString(t2) || [];
        var maxlength = Math.max(t1.length, t2.length),
            from = [],
            to = [],
            i = 0, j, jj,
            tt1, tt2;
        for (; i < maxlength; i++) {
            tt1 = t1[i] || getEmpty(t2[i]);
            tt2 = t2[i] || getEmpty(tt1);
            if ((tt1[0] != tt2[0]) ||
                (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                ) {
                    t1 = Snap._.transform2matrix(t1, getBBox());
                    t2 = Snap._.transform2matrix(t2, getBBox());
                    from = [["m", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];
                    to = [["m", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];
                    break;
            }
            from[i] = [];
            to[i] = [];
            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {
                j in tt1 && (from[i][j] = tt1[j]);
                j in tt2 && (to[i][j] = tt2[j]);
            }
        }
        return {
            from: path2array(from),
            to: path2array(to),
            f: getPath(from)
        };
    }
    function getNumber(val) {
        return val;
    }
    function getUnit(unit) {
        return function (val) {
            return +val.toFixed(3) + unit;
        };
    }
    function getColour(clr) {
        return Snap.rgb(clr[0], clr[1], clr[2]);
    }
    function getPath(path) {
        var k = 0, i, ii, j, jj, out, a, b = [];
        for (i = 0, ii = path.length; i < ii; i++) {
            out = "[";
            a = ['"' + path[i][0] + '"'];
            for (j = 1, jj = path[i].length; j < jj; j++) {
                a[j] = "val[" + (k++) + "]";
            }
            out += a + "]";
            b[i] = out;
        }
        return Function("val", "return Snap.path.toString.call([" + b + "])");
    }
    function path2array(path) {
        var out = [];
        for (var i = 0, ii = path.length; i < ii; i++) {
            for (var j = 1, jj = path[i].length; j < jj; j++) {
                out.push(path[i][j]);
            }
        }
        return out;
    }
    Element.prototype.equal = function (name, b) {
        var A, B, a = Str(this.attr(name) || ""),
            el = this;
        if (a == +a && b == +b) {
            return {
                from: +a,
                to: +b,
                f: getNumber
            };
        }
        if (names[name] == "colour") {
            A = Snap.color(a);
            B = Snap.color(b);
            return {
                from: [A.r, A.g, A.b, A.opacity],
                to: [B.r, B.g, B.b, B.opacity],
                f: getColour
            };
        }
        if (name == "transform" || name == "gradientTransform" || name == "patternTransform") {
            if (b instanceof Snap.Matrix) {
                b = b.toTransformString();
            }
            if (!Snap._.rgTransform.test(b)) {
                b = Snap._.svgTransform2string(b);
            }
            return equaliseTransform(a, b, function () {
                return el.getBBox(1);
            });
        }
        if (name == "d" || name == "path") {
            A = Snap.path.toCubic(a, b);
            return {
                from: path2array(A[0]),
                to: path2array(A[1]),
                f: getPath(A[0])
            };
        }
        if (name == "points") {
            A = Str(a).split(",");
            B = Str(b).split(",");
            return {
                from: A,
                to: B,
                f: function (val) { return val; }
            };
        }
        var aUnit = a.match(reUnit),
            bUnit = Str(b).match(reUnit);
        if (aUnit && aUnit == bUnit) {
            return {
                from: parseFloat(a),
                to: parseFloat(b),
                f: getUnit(aUnit)
            };
        } else {
            return {
                from: this.asPX(name),
                to: this.asPX(name, b),
                f: getNumber
            };
        }
    };
});
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
    has = "hasOwnProperty",
    supportsTouch = "createTouch" in glob.doc,
    events = [
        "click", "dblclick", "mousedown", "mousemove", "mouseout",
        "mouseover", "mouseup", "touchstart", "touchmove", "touchend",
        "touchcancel"
    ],
    touchMap = {
        mousedown: "touchstart",
        mousemove: "touchmove",
        mouseup: "touchend"
    },
    getScroll = function (xy) {
        var name = xy == "y" ? "scrollTop" : "scrollLeft";
        return glob.doc.documentElement[name] || glob.doc.body[name];
    },
    preventDefault = function () {
        this.returnValue = false;
    },
    preventTouch = function () {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function () {
        this.cancelBubble = true;
    },
    stopTouch = function () {
        return this.originalEvent.stopPropagation();
    },
    addEvent = (function () {
        if (glob.doc.addEventListener) {
            return function (obj, type, fn, element) {
                var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
                    f = function (e) {
                        var scrollY = getScroll("y"),
                            scrollX = getScroll("x");
                        if (supportsTouch && touchMap[has](type)) {
                            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                                if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
                                    var olde = e;
                                    e = e.targetTouches[i];
                                    e.originalEvent = olde;
                                    e.preventDefault = preventTouch;
                                    e.stopPropagation = stopTouch;
                                    break;
                                }
                            }
                        }
                        var x = e.clientX + scrollX,
                            y = e.clientY + scrollY;
                        return fn.call(element, e, x, y);
                    };

                if (type !== realName) {
                    obj.addEventListener(type, f, false);
                }

                obj.addEventListener(realName, f, false);

                return function () {
                    if (type !== realName) {
                        obj.removeEventListener(type, f, false);
                    }

                    obj.removeEventListener(realName, f, false);
                    return true;
                };
            };
        } else if (glob.doc.attachEvent) {
            return function (obj, type, fn, element) {
                var f = function (e) {
                    e = e || glob.win.event;
                    var scrollY = getScroll("y"),
                        scrollX = getScroll("x"),
                        x = e.clientX + scrollX,
                        y = e.clientY + scrollY;
                    e.preventDefault = e.preventDefault || preventDefault;
                    e.stopPropagation = e.stopPropagation || stopPropagation;
                    return fn.call(element, e, x, y);
                };
                obj.attachEvent("on" + type, f);
                var detacher = function () {
                    obj.detachEvent("on" + type, f);
                    return true;
                };
                return detacher;
            };
        }
    })(),
    drag = [],
    dragMove = function (e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = getScroll("y"),
            scrollX = getScroll("x"),
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches && e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }
            var node = dragi.el.node,
                o,
                glob = Snap._.glob,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;
            // glob.win.opera && parent.removeChild(node);
            // node.style.display = "none";
            // o = dragi.el.paper.getElementByPoint(x, y);
            // node.style.display = display;
            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function (e) {
        Snap.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    };
    /*\
     * Element.click
     [ method ]
     **
     * Adds a click event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes a click event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds a double click event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes a double click event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds a mousedown event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes a mousedown event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds a mousemove event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes a mousemove event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds a mouseout event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes a mouseout event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds a mouseover event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes a mouseover event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds a mouseup event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes a mouseup event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds a touchstart event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes a touchstart event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds a touchmove event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes a touchmove event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchend
     [ method ]
     **
     * Adds a touchend event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes a touchend event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds a touchcancel event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes a touchcancel event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    for (var i = events.length; i--;) {
        (function (eventName) {
            Snap[eventName] = elproto[eventName] = function (fn, scope) {
                if (Snap.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({
                        name: eventName,
                        f: fn,
                        unbind: addEvent(this.shape || this.node || glob.doc, eventName, fn, scope || this)
                    });
                }
                return this;
            };
            Snap["un" + eventName] =
            elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--) if (events[l].name == eventName &&
                               (events[l].f == fn || !fn)) {
                    events[l].unbind();
                    events.splice(l, 1);
                    !events.length && delete this.events;
                    return this;
                }
                return this;
            };
        })(events[i]);
    }
    /*\
     * Element.hover
     [ method ]
     **
     * Adds hover event handlers to the element
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /*\
     * Element.unhover
     [ method ]
     **
     * Removes hover event handlers from the element
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for an element's drag gesture
     **
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start,
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element
     * `drag.over.<id>` fires as well.
     *
     * Start event and start handler are called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler are called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler are called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        if (!arguments.length) {
            var origTransform;
            return this.drag(function (dx, dy) {
                this.attr({
                    transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
                });
            }, function () {
                origTransform = this.transform().local;
            });
        }
        function start(e, x, y) {
            (e.originalEvent || e).preventDefault();
            this._drag.x = x;
            this._drag.y = y;
            this._drag.id = e.identifier;
            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
            onstart && eve.on("snap.drag.start." + this.id, onstart);
            onmove && eve.on("snap.drag.move." + this.id, onmove);
            onend && eve.on("snap.drag.end." + this.id, onend);
            eve("snap.drag.start." + this.id, start_scope || move_scope || this, x, y, e);
        }
        this._drag = {};
        draggable.push({el: this, start: start});
        this.mousedown(start);
        return this;
    };
    /*
     * Element.onDragOver
     [ method ]
     **
     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
    // elproto.onDragOver = function (f) {
    //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
    // };
    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from the given element
    \*/
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            eve.unbind("snap.drag.*." + this.id);
        }
        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
        return this;
    };
});
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        pproto = Paper.prototype,
        rgurl = /^\s*url\((.+)\)/,
        Str = String,
        $ = Snap._.$;
    Snap.filter = {};
// SIERRA Paper.filter(): I don't understand the note. Does that mean an HTML should dedicate a separate SVG region for a filter definition? What's the advantage over a DEFS?
    /*\
     * Paper.filter
     [ method ]
     **
     * Creates a `<filter>` element
     **
     - filstr (string) SVG fragment of filter provided as a string
     = (object) @Element
     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
     > Usage
     | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    pproto.filter = function (filstr) {
        var paper = this;
        if (paper.type != "svg") {
            paper = paper.paper;
        }
        var f = Snap.parse(Str(filstr)),
            id = Snap._.id(),
            width = paper.node.offsetWidth,
            height = paper.node.offsetHeight,
            filter = $("filter");
        $(filter, {
            id: id,
            filterUnits: "userSpaceOnUse"
        });
        filter.appendChild(f.node);
        paper.defs.appendChild(filter);
        return new Element(filter);
    };

    eve.on("snap.util.getattr.filter", function () {
        eve.stop();
        var p = $(this.node, "filter");
        if (p) {
            var match = Str(p).match(rgurl);
            return match && Snap.select(match[1]);
        }
    });
    eve.on("snap.util.attr.filter", function (value) {
        if (value instanceof Element && value.type == "filter") {
            eve.stop();
            var id = value.node.id;
            if (!id) {
                $(value.node, {id: value.id});
                id = value.id;
            }
            $(this.node, {
                filter: Snap.url(id)
            });
        }
        if (!value || value == "none") {
            eve.stop();
            this.node.removeAttribute("filter");
        }
    });
    /*\
     * Snap.filter.blur
     [ method ]
     **
     * Returns an SVG markup string for the blur filter
     **
     - x (number) amount of horizontal blur, in pixels
     - y (number) #optional amount of vertical blur, in pixels
     = (string) filter representation
     > Usage
     | var f = paper.filter(Snap.filter.blur(5, 10)),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    Snap.filter.blur = function (x, y) {
        if (x == null) {
            x = 2;
        }
        var def = y == null ? x : [x, y];
        return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
            def: def
        });
    };
    Snap.filter.blur.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.shadow
     [ method ]
     **
     * Returns an SVG markup string for the shadow filter
     **
     - dx (number) horizontal shift of the shadow, in pixels
     - dy (number) vertical shift of the shadow, in pixels
     - blur (number) #optional amount of blur
     - color (string) #optional color of the shadow
     = (string) filter representation
     > Usage
     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    Snap.filter.shadow = function (dx, dy, blur, color) {
        color = color || "#000";
        if (blur == null) {
            blur = 4;
        }
        if (typeof blur == "string") {
            color = blur;
            blur = 4;
        }
        if (dx == null) {
            dx = 0;
            dy = 2;
        }
        if (dy == null) {
            dy = dx;
        }
        color = Snap.color(color);
        return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
            color: color,
            dx: dx,
            dy: dy,
            blur: blur
        });
    };
    Snap.filter.shadow.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.grayscale
     [ method ]
     **
     * Returns an SVG markup string for the grayscale filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.grayscale = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
            a: 0.2126 + 0.7874 * (1 - amount),
            b: 0.7152 - 0.7152 * (1 - amount),
            c: 0.0722 - 0.0722 * (1 - amount),
            d: 0.2126 - 0.2126 * (1 - amount),
            e: 0.7152 + 0.2848 * (1 - amount),
            f: 0.0722 - 0.0722 * (1 - amount),
            g: 0.2126 - 0.2126 * (1 - amount),
            h: 0.0722 + 0.9278 * (1 - amount)
        });
    };
    Snap.filter.grayscale.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.sepia
     [ method ]
     **
     * Returns an SVG markup string for the sepia filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.sepia = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
            a: 0.393 + 0.607 * (1 - amount),
            b: 0.769 - 0.769 * (1 - amount),
            c: 0.189 - 0.189 * (1 - amount),
            d: 0.349 - 0.349 * (1 - amount),
            e: 0.686 + 0.314 * (1 - amount),
            f: 0.168 - 0.168 * (1 - amount),
            g: 0.272 - 0.272 * (1 - amount),
            h: 0.534 - 0.534 * (1 - amount),
            i: 0.131 + 0.869 * (1 - amount)
        });
    };
    Snap.filter.sepia.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.saturate
     [ method ]
     **
     * Returns an SVG markup string for the saturate filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.saturate = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
            amount: 1 - amount
        });
    };
    Snap.filter.saturate.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.hueRotate
     [ method ]
     **
     * Returns an SVG markup string for the hue-rotate filter
     **
     - angle (number) angle of rotation
     = (string) filter representation
    \*/
    Snap.filter.hueRotate = function (angle) {
        angle = angle || 0;
        return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
            angle: angle
        });
    };
    Snap.filter.hueRotate.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.invert
     [ method ]
     **
     * Returns an SVG markup string for the invert filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.invert = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
            amount: amount,
            amount2: 1 - amount
        });
    };
    Snap.filter.invert.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.brightness
     [ method ]
     **
     * Returns an SVG markup string for the brightness filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.brightness = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
            amount: amount
        });
    };
    Snap.filter.brightness.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.contrast
     [ method ]
     **
     * Returns an SVG markup string for the contrast filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.contrast = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
            amount: amount,
            amount2: .5 - amount / 2
        });
    };
    Snap.filter.contrast.toString = function () {
        return this();
    };
});
return Snap;
}));

},{"eve":65}],65:[function(require,module,exports){
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\

(function (glob) {
    var version = "0.4.2",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners
    \*/
        eve = function (name, scope) {
			name = String(name);
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out.length ? out : null;
        };
		// Undocumented. Debug only.
		eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    
    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt()` function will be called before `eatIt()`.
	 *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
    \*/
    eve.on = function (name, f) {
		name = String(name);
		if (typeof f != "function") {
			return function () {};
		}
        var names = name.split(separator),
            e = events;
        for (var i = 0, ii = names.length; i < ii; i++) {
            e = e.n;
            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
        }
        e.f = e.f || [];
        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
            return fun;
        }
        e.f.push(f);
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
	 * Arguments that will be passed to the result function will be also
	 * concated to the list of final arguments.
 	 | el.onclick = eve.f("click", 1, 2);
 	 | eve.on("click", function (a, b, c) {
 	 |     console.log(a, b, c); // 1, 2, [event object]
 	 | });
     > Arguments
	 - event (string) event name
	 - varargs (…) and any other arguments
	 = (function) possible event handler function
    \*/
	eve.f = function (event) {
		var attrs = [].slice.call(arguments, 1);
		return function () {
			eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
		};
	};
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
    \*/
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
	 * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
		if (!name) {
		    eve._events = events = {n: {}};
			return;
		}
        var names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.unbind(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : (typeof define != "undefined" ? (define("eve", [], function() { return eve; })) : (glob.eve = eve));
})(this);

},{}],66:[function(require,module,exports){
void function(root){

	'use strict'

	var create = Object.create || function(o){
		var F = function(){}
		F.prototype = o
		return new F()
	}

	var extend = function(to, from){
		for ( var p in from ) to[p] = from[p]
		return to
	}

	// Library object - a base object to be extended
	var Viral = {

		// create an inheriting object, with added or changed methods or properties
		extend: function(props){
			return extend(create(this), props)
		},

		// create a new instance of an object, calling an init method if available
		make: function(){
			var obj = create(this)
			if ( typeof obj.init === 'function' ) obj.init.apply(obj, arguments)
			return obj
		}
	}

	// module dance
	if ( typeof module !== 'undefined' && module.exports ) module.exports = Viral
	else if ( typeof define === 'function' && define.amd ) define(Viral)
	else                                                   root.Viral = Viral

}(this)

},{}],67:[function(require,module,exports){
void function(){
  var viral = require('viral')
  var Set = require('./set.js')
  var enslave = require('enslave')

  function clone(A){
    return Pathway.make(A.sources, A.edges, A.targets)
  }

  function union(A, B){

    return Pathway.make(A.sources.union(B.sources)
                      , A.edges.union(B.edges)
                      , A.targets.union(B.targets))
  }

  function same(A, B){

    return A.sources.joint(B.sources) ||
           A.edges.joint(B.edges) ||
           A.targets.joint(B.targets)
  }

  var Pathway = viral.extend({
    init: function(sources, edges, targets){
      this.sources = sources != null ? sources : Set.make()
      this.edges = edges != null ? edges : Set.make()
      this.targets = targets != null ? targets : Set.make()
    }
  , same: enslave(same)
  , clone: enslave(clone)
  , union: enslave(union)
  })

  function indexOf(P, p){
    for ( var i = 0; i < P.values.length; i++ ) {
      if ( same(P.values[i], p) ) return i
    }
    return -1
  }

  function size(pathways){
    return pathways.values.length
  }


  function forEach(pathways, fn){
    pathways.values.forEach(fn)
  }

  function add(pathways, source, edge, target){

    var n = Pathway.make(Set.make().add(source), Set.make().add(edge), Set.make().add(target))

    var h = indexOf(pathways, n)
    if ( h > -1  ) {
      pathways.values[h] = pathways.values[h].union(n)
    } else {
      pathways.values.push(n)
    }

    return pathways
  }

  var Pathways = Set.extend({
    add: enslave(add)
  , indexOf: enslave(indexOf)
  })


  module.exports = Pathways


}()

},{"./set.js":68,"enslave":57,"viral":66}],68:[function(require,module,exports){
void function(){
  var viral = require('viral')
  var enslave = require('enslave')
  var Arr = require('./arr.js')


  function has(set, value){
    return set.indexOf(value) > -1
  }

  function add(set, value){
    if ( ! has(set, value) ) {
      set.values.push(value)
    }
    return set
  }

  function remove(set, value){
    var idx = indexOf(set, value)
    if ( idx > -1 ) {
      set.values.splice(idx, 1)
    }
    return set
  }

  function same(set, other){
    return set.values.length != other.values.length ? false
         : set.values.every(function(a){ return other.has(a) })
  }

  function union(set, other){
    var result = set.clone()
    other.forEach(function(v){
      result.add(v)
    })
    return result
  }

  function joint(set, other){
    return set.some(function(a){ return other.has(a) })
  }

  function clone(set){
    return Set.make(set)
  }

  var Set = Arr.extend({
    union: enslave(union)
  , has: enslave(has)
  , add: enslave(add)
  , remove: enslave(remove)
  , same: enslave(same)
  , joint: enslave(joint)
  , clone: enslave(clone)
  })

  module.exports = Set

}()

},{"./arr.js":1,"enslave":57,"viral":66}],69:[function(require,module,exports){
void function(){
  "use strict"
  var rt = require('random-token')
  var rnd = require('random-number')
  var fs = require('fs')
  var wt = require('../index.js')
  var dom = require('../util/dom.js')
  var uid = require('../util/unique_id.js')
  var rand_int = rnd.generator({integer: true})
  var print = console.log.bind(console)

  var lipscfg = {
      count: 1                      // Number of words, sentences, or paragraphs to generate.
    , units: 'sentences'            // Generate words, sentences, or paragraphs.
    , sentenceLowerBound: 1         // Minimum words per sentence.
    , sentenceUpperBound: 2        // Maximum words per sentence.
    , format: 'plain'               // Plain text or html
  }

  var lipsum = require('lorem-ipsum').bind(null, lipscfg)

  function isNumber(n){ return typeof n == 'number' }

  var config = wt.config({
    padding: 21
  , rank_detection_error_margin: 2
  , edgeWidth: 5
  , edgeClass: 'FCHLine'
  , edgeEndClass: 'FCHLine-witharrow'
  , intersectionClass: 'FCHLine-intersection'
  })

  var graph = wt.graph({
    rankDir: 'LR'
  , universalSep: 29
  , edgeSep: 0
  , rankSep: 150
  })

  var nodes = Array(12)
  var ranks = ['same_first','same_second','same_second','same_second','same_third','same_third','same_third','same_third','same_third','same_fourth','same_fourth','same_fourth']
  for ( var i = 0; i < nodes.length ; i++ ) {
    nodes[i] = graph.add_node(
      'FCHBox'
    , function (node, values){
// these lines shouldn't be here
        node.attr('x', values.x)
        node.attr('y', values.y)
        var x = values.x - values.width / 2
        var y = values.y - values.height / 2
        node.add_attr(':first', 'transform', 'translate(' + x + ',' + y + ')')
        node.add_attr('.FCHBox-Text-bg', 'width', values.width )
        node.add_attr('.FCHBox-Text-bg', 'height', values.height)
    }
    , {
        ".FCHBox-Text-title": {_text: (i+1) +' ' +lipsum()}
      , ".FCHBox-Text-type" : {_text: 'Type: ' + lipsum()}
    }, ranks[i])
  }

  // var rnd_node = rnd.generator({min: 0, max: nodes.length - 1, integer: true})
  // var links= Array(rand_int(1, Math.pow(rand_int(1, nodes.length), 2) - 1))
  var connections = [
    [0,1]
  , [0,2]
  , [0,3]
  , [1,4]
  , [1,5]
  , [1,6]
  , [3,9]
  , [2,7]
  , [2,8]
  , [4,9]
  , [6,9]
  , [5,10]
  , [7,11]
  , [8,11]
  , [9,7]
  , [9,8]
  , [9,11]
  , [10,7]
  , [10,8]
  , [10,11]
  ]
  var links = Array(connections.length)


  function but(gen, x){
    var r = gen()
    while ( r == x ) { r = gen() }
    return r
  }


  for ( var i = connections.length - 1; i >= 0 ; i-- ) {
    //var link1 = rnd_node()

    links[i] = graph.connect(
      'FCHLine'
    // , nodes[link1]
    // , nodes[but(rnd_node, link1)]
    , nodes[connections[i][0]]
    , nodes[connections[i][1]]
  )

  }

  var diagram = wt.diagram(config, graph)
  diagram.to_defs("<font horiz-adv-x=\"2048\">\n  <!-- Open Sans is a trademark of Google and may be registered in certain jurisdictions. -->\n  <!-- Copyright: Copyright 2014 Adobe System Incorporated. All rights reserved. -->\n  <font-face font-family=\"OpenSans-Semibold\" units-per-em=\"2048\" underline-position=\"-154\" underline-thickness=\"102\"/>\n  <missing-glyph horiz-adv-x=\"1229\" d=\"M193,1462l841,0l0,-1462l-841,0M297,104l633,0l0,1254l-633,0z\"/>\n  <glyph unicode=\" \" horiz-adv-x=\"532\"/>\n  <glyph unicode=\"!\" horiz-adv-x=\"565\" d=\"M371,444l-174,0l-52,1018l277,0M133,125C133,174 146,212 172,238C198,263 235,276 283,276C330,276 367,263 392,236C417,209 430,172 430,125C430,78 417,40 392,13C366,-15 330,-29 283,-29C236,-29 199,-16 173,11C146,38 133,76 133,125z\"/>\n  <glyph unicode=\"&quot;\" horiz-adv-x=\"893\" d=\"M365,1462l-41,-528l-150,0l-41,528M760,1462l-41,-528l-150,0l-41,528z\"/>\n  <glyph unicode=\"#\" horiz-adv-x=\"1323\" d=\"M989,870l-55,-284l270,0l0,-168l-303,0l-80,-418l-178,0l80,418l-248,0l-80,-418l-174,0l76,418l-250,0l0,168l283,0l57,284l-264,0l0,168l293,0l80,422l180,0l-80,-422l252,0l80,422l174,0l-80,-422l252,0l0,-168M506,586l250,0l57,284l-250,0z\"/>\n  <glyph unicode=\"$\" horiz-adv-x=\"1169\" d=\"M1063,453C1063,356 1028,277 957,214C886,151 784,113 651,98l0,-217l-133,0l0,211C353,95 217,120 111,168l0,211C168,351 235,328 312,309C389,290 457,280 518,279l0,374l-84,31C325,726 245,776 195,835C144,893 119,965 119,1051C119,1143 155,1219 227,1278C298,1337 395,1373 518,1386l0,168l133,0l0,-165C786,1384 915,1357 1036,1307l-73,-183C858,1165 754,1190 651,1198l0,-364l76,-29C854,756 941,705 990,651C1039,597 1063,531 1063,453M827,438C827,477 814,509 787,534C760,559 714,583 651,606l0,-319C768,305 827,355 827,438M354,1053C354,1015 366,983 390,958C413,933 456,908 518,883l0,311C465,1186 424,1170 396,1145C368,1120 354,1090 354,1053z\"/>\n  <glyph unicode=\"%\" horiz-adv-x=\"1765\" d=\"M279,1024C279,925 289,851 308,802C327,753 359,729 403,729C491,729 535,827 535,1024C535,1221 491,1319 403,1319C359,1319 327,1295 308,1246C289,1197 279,1123 279,1024M729,1026C729,873 702,758 647,681C592,604 510,565 403,565C302,565 223,605 168,685C112,764 84,878 84,1026C84,1331 190,1483 403,1483C508,1483 588,1444 645,1365C701,1286 729,1173 729,1026M1231,440C1231,341 1241,266 1261,217C1280,168 1312,143 1356,143C1443,143 1487,242 1487,440C1487,635 1443,733 1356,733C1312,733 1280,709 1261,661C1241,613 1231,539 1231,440M1681,440C1681,287 1653,172 1598,95C1543,18 1462,-20 1356,-20C1255,-20 1176,20 1120,99C1064,178 1036,291 1036,440C1036,745 1143,897 1356,897C1459,897 1539,858 1596,779C1653,700 1681,587 1681,440M1384,1462l-811,-1462l-194,0l811,1462z\"/>\n  <glyph unicode=\"&amp;\" horiz-adv-x=\"1516\" d=\"M451,1147C451,1105 462,1065 485,1028C507,991 538,951 578,909C653,952 706,992 737,1029C767,1066 782,1107 782,1153C782,1196 768,1231 739,1257C710,1283 671,1296 623,1296C570,1296 529,1283 498,1256C467,1229 451,1192 451,1147M600,182C722,182 826,218 913,289l-383,377C459,621 411,578 384,539C357,499 344,454 344,403C344,338 367,285 414,244C460,203 522,182 600,182M96,387C96,474 117,551 160,616C203,681 280,745 391,809C328,883 285,946 262,997C239,1048 227,1100 227,1155C227,1256 263,1336 336,1395C408,1454 505,1483 627,1483C745,1483 838,1455 905,1398C972,1341 1006,1264 1006,1167C1006,1091 984,1022 939,960C894,898 818,836 713,774l346,-334C1113,511 1158,616 1194,754l242,0C1389,565 1315,410 1212,291l301,-291l-303,0l-149,145C993,90 921,49 844,22C767,-6 681,-20 588,-20C435,-20 314,16 227,89C140,162 96,261 96,387z\"/>\n  <glyph unicode=\"'\" horiz-adv-x=\"498\" d=\"M365,1462l-41,-528l-150,0l-41,528z\"/>\n  <glyph unicode=\"(\" horiz-adv-x=\"649\" d=\"M82,561C82,738 108,903 160,1057C211,1211 286,1346 383,1462l205,0C495,1337 424,1196 375,1041C326,885 301,726 301,563C301,400 326,243 375,90C424,-63 495,-201 586,-324l-203,0C285,-211 210,-78 159,73C108,224 82,387 82,561z\"/>\n  <glyph unicode=\")\" horiz-adv-x=\"649\" d=\"M567,561C567,386 541,222 490,71C438,-80 363,-212 266,-324l-203,0C155,-199 226,-61 275,91C324,243 348,400 348,563C348,726 323,886 274,1041C225,1196 154,1336 61,1462l205,0C364,1345 439,1210 490,1056C541,901 567,736 567,561z\"/>\n  <glyph unicode=\"*\" horiz-adv-x=\"1122\" d=\"M672,1556l-41,-382l385,108l28,-217l-360,-29l236,-311l-199,-107l-166,338l-149,-338l-205,107l231,311l-358,29l35,217l376,-108l-41,382z\"/>\n  <glyph unicode=\"+\" horiz-adv-x=\"1169\" d=\"M494,633l-398,0l0,178l398,0l0,408l180,0l0,-408l399,0l0,-178l-399,0l0,-406l-180,0z\"/>\n  <glyph unicode=\",\" horiz-adv-x=\"547\" d=\"M412,215C380,91 321,-69 236,-264l-173,0C109,-84 143,83 166,238l231,0z\"/>\n  <glyph unicode=\"-\" horiz-adv-x=\"659\" d=\"M72,449l0,200l514,0l0,-200z\"/>\n  <glyph unicode=\".\" horiz-adv-x=\"563\" d=\"M133,125C133,174 146,211 171,237C196,263 233,276 281,276C330,276 367,263 392,236C417,209 430,172 430,125C430,78 417,40 392,13C366,-15 329,-29 281,-29C233,-29 196,-15 171,12C146,39 133,77 133,125z\"/>\n  <glyph unicode=\"/\" horiz-adv-x=\"799\" d=\"M782,1462l-544,-1462l-222,0l545,1462z\"/>\n  <glyph unicode=\"0\" horiz-adv-x=\"1169\" d=\"M1081,731C1081,477 1040,288 959,165C877,42 752,-20 584,-20C421,-20 298,44 214,171C130,298 88,485 88,731C88,989 129,1179 211,1302C292,1424 417,1485 584,1485C747,1485 871,1421 955,1293C1039,1165 1081,978 1081,731M326,731C326,532 347,389 388,304C429,219 494,176 584,176C674,176 740,219 782,306C823,393 844,534 844,731C844,927 823,1069 782,1157C740,1244 674,1288 584,1288C494,1288 429,1245 388,1159C347,1073 326,930 326,731z\"/>\n  <glyph unicode=\"1\" horiz-adv-x=\"1169\" d=\"M780,0l-235,0l0,944C545,1057 548,1146 553,1212C538,1196 519,1178 497,1159C474,1140 399,1078 272,975l-118,149l430,338l196,0z\"/>\n  <glyph unicode=\"2\" horiz-adv-x=\"1169\" d=\"M1081,0l-991,0l0,178l377,379C578,671 652,752 689,800C725,847 751,892 768,934C785,976 793,1021 793,1069C793,1135 773,1187 734,1225C694,1263 639,1282 569,1282C513,1282 459,1272 407,1251C354,1230 294,1193 225,1139l-127,155C179,1363 258,1411 335,1440C412,1469 493,1483 580,1483C716,1483 825,1448 907,1377C989,1306 1030,1210 1030,1090C1030,1024 1018,961 995,902C971,843 935,782 886,719C837,656 755,570 641,463l-254,-246l0,-10l694,0z\"/>\n  <glyph unicode=\"3\" horiz-adv-x=\"1169\" d=\"M1026,1126C1026,1033 999,956 945,895C891,833 815,791 717,770l0,-8C834,747 922,711 981,653C1040,594 1069,517 1069,420C1069,279 1019,171 920,95C821,18 679,-20 496,-20C334,-20 197,6 86,59l0,209C148,237 214,214 283,197C352,180 419,172 483,172C596,172 681,193 737,235C793,277 821,342 821,430C821,508 790,565 728,602C666,639 569,657 436,657l-127,0l0,191l129,0C671,848 788,929 788,1090C788,1153 768,1201 727,1235C686,1269 626,1286 547,1286C492,1286 438,1278 387,1263C336,1247 275,1216 205,1171l-115,164C224,1434 380,1483 557,1483C704,1483 819,1451 902,1388C985,1325 1026,1237 1026,1126z\"/>\n  <glyph unicode=\"4\" horiz-adv-x=\"1169\" d=\"M1133,319l-197,0l0,-319l-229,0l0,319l-668,0l0,181l668,966l229,0l0,-952l197,0M707,514l0,367C707,1012 710,1119 717,1202l-8,0C690,1158 661,1105 621,1042l-363,-528z\"/>\n  <glyph unicode=\"5\" horiz-adv-x=\"1169\" d=\"M586,913C733,913 850,874 936,796C1022,718 1065,612 1065,477C1065,321 1016,199 919,112C821,24 682,-20 502,-20C339,-20 210,6 117,59l0,213C171,241 233,218 303,201C373,184 438,176 498,176C604,176 685,200 740,247C795,294 823,364 823,455C823,630 712,717 489,717C458,717 419,714 373,708C327,701 287,694 252,686l-105,62l56,714l760,0l0,-209l-553,0l-33,-362C400,895 429,900 463,905C496,910 537,913 586,913z\"/>\n  <glyph unicode=\"6\" horiz-adv-x=\"1169\" d=\"M94,623C94,1195 327,1481 793,1481C866,1481 928,1475 979,1464l0,-196C928,1283 870,1290 803,1290C646,1290 529,1248 450,1164C371,1080 329,945 322,760l12,0C365,814 409,856 466,886C523,915 589,930 666,930C799,930 902,889 976,808C1050,727 1087,616 1087,477C1087,324 1044,203 959,114C873,25 756,-20 608,-20C503,-20 412,5 335,56C258,106 198,179 157,276C115,372 94,488 94,623M604,174C685,174 747,200 791,252C834,304 856,378 856,475C856,559 836,625 795,673C754,721 692,745 610,745C559,745 513,734 470,713C427,691 394,661 369,624C344,586 332,547 332,508C332,414 358,335 409,271C460,206 525,174 604,174z\"/>\n  <glyph unicode=\"7\" horiz-adv-x=\"1169\" d=\"M256,0l578,1253l-760,0l0,207l1011,0l0,-164l-575,-1296z\"/>\n  <glyph unicode=\"8\" horiz-adv-x=\"1169\" d=\"M584,1481C723,1481 832,1449 913,1386C994,1322 1034,1237 1034,1130C1034,980 944,861 764,772C879,715 960,654 1009,591C1057,528 1081,457 1081,379C1081,258 1037,162 948,89C859,16 739,-20 588,-20C429,-20 306,14 219,82C132,150 88,246 88,371C88,452 111,526 157,591C202,656 277,713 381,764C292,817 228,874 190,933C152,992 133,1059 133,1133C133,1239 175,1324 258,1387C341,1450 450,1481 584,1481M313,379C313,310 337,256 386,218C435,179 501,160 584,160C670,160 737,180 785,220C832,259 856,313 856,381C856,435 834,484 790,529C746,574 679,615 590,653l-29,13C473,627 410,585 371,539C332,492 313,439 313,379M582,1300C515,1300 462,1284 421,1251C380,1218 360,1173 360,1116C360,1081 367,1050 382,1023C397,996 418,971 446,949C474,926 521,899 588,868C668,903 725,941 758,980C791,1019 807,1064 807,1116C807,1173 787,1218 746,1251C705,1284 650,1300 582,1300z\"/>\n  <glyph unicode=\"9\" horiz-adv-x=\"1169\" d=\"M1079,838C1079,550 1021,335 905,193C789,51 614,-20 381,-20C292,-20 229,-15 190,-4l0,197C249,176 309,168 369,168C528,168 646,211 724,296C802,381 845,515 852,698l-12,0C801,638 753,595 698,568C642,541 577,528 502,528C373,528 271,568 197,649C123,730 86,840 86,981C86,1134 129,1255 215,1346C300,1436 417,1481 565,1481C669,1481 760,1456 837,1405C914,1354 974,1281 1016,1185C1058,1088 1079,973 1079,838M569,1286C488,1286 425,1260 382,1207C339,1154 317,1079 317,983C317,900 337,834 378,787C418,739 479,715 561,715C640,715 707,739 761,786C815,833 842,889 842,952C842,1011 831,1067 808,1119C785,1170 752,1211 711,1241C670,1271 622,1286 569,1286z\"/>\n  <glyph unicode=\":\" horiz-adv-x=\"563\" d=\"M133,125C133,174 146,211 171,237C196,263 233,276 281,276C330,276 367,263 392,236C417,209 430,172 430,125C430,78 417,40 392,13C366,-15 329,-29 281,-29C233,-29 196,-15 171,12C146,39 133,77 133,125M133,979C133,1080 182,1130 281,1130C331,1130 368,1117 393,1090C418,1063 430,1026 430,979C430,932 417,894 392,867C366,839 329,825 281,825C233,825 196,839 171,866C146,893 133,931 133,979z\"/>\n  <glyph unicode=\";\" horiz-adv-x=\"569\" d=\"M397,238l15,-23C380,91 321,-69 236,-264l-173,0C109,-84 143,83 166,238M131,979C131,1080 180,1130 279,1130C329,1130 366,1117 391,1090C416,1063 428,1026 428,979C428,932 415,894 390,867C364,839 327,825 279,825C231,825 194,839 169,866C144,893 131,931 131,979z\"/>\n  <glyph unicode=\"&lt;\" horiz-adv-x=\"1169\" d=\"M1073,221l-977,430l0,121l977,488l0,-195l-733,-344l733,-303z\"/>\n  <glyph unicode=\"=\" horiz-adv-x=\"1169\" d=\"M102,831l0,179l963,0l0,-179M102,432l0,178l963,0l0,-178z\"/>\n  <glyph unicode=\"&gt;\" horiz-adv-x=\"1169\" d=\"M96,418l733,303l-733,344l0,195l977,-488l0,-121l-977,-430z\"/>\n  <glyph unicode=\"?\" horiz-adv-x=\"928\" d=\"M283,444l0,64C283,581 296,642 323,691C350,740 396,790 463,842C542,905 594,953 617,988C640,1023 651,1064 651,1112C651,1168 632,1211 595,1241C558,1271 504,1286 434,1286C371,1286 312,1277 258,1259C204,1241 151,1219 100,1194l-84,176C151,1445 296,1483 451,1483C582,1483 685,1451 762,1387C839,1323 877,1235 877,1122C877,1072 870,1028 855,989C840,950 818,912 789,877C759,842 708,796 635,739C573,690 532,650 511,618C490,586 479,543 479,489l0,-45M242,125C242,226 291,276 389,276C437,276 474,263 499,237C524,210 537,173 537,125C537,78 524,40 499,13C473,-15 436,-29 389,-29C342,-29 305,-15 280,12C255,39 242,76 242,125z\"/>\n  <glyph unicode=\"@\" horiz-adv-x=\"1839\" d=\"M1726,739C1726,644 1711,557 1681,478C1651,399 1609,337 1555,293C1500,249 1437,227 1366,227C1313,227 1268,241 1229,269C1190,297 1164,335 1151,383l-12,0C1106,331 1066,292 1018,266C970,240 916,227 856,227C747,227 662,262 600,332C537,402 506,497 506,616C506,753 547,865 630,951C713,1036 824,1079 963,1079C1014,1079 1070,1075 1132,1066C1193,1057 1248,1044 1296,1028l-22,-465l0,-24C1274,432 1309,379 1378,379C1431,379 1473,413 1504,481C1535,549 1550,636 1550,741C1550,855 1527,955 1480,1042C1433,1128 1367,1194 1281,1241C1195,1288 1096,1311 985,1311C843,1311 720,1282 615,1223C510,1164 429,1081 374,972C319,863 291,736 291,592C291,399 343,250 446,146C549,42 698,-10 891,-10C1038,-10 1192,20 1352,80l0,-164C1212,-141 1060,-170 895,-170C648,-170 456,-103 318,30C180,163 111,348 111,586C111,760 148,915 223,1051C298,1186 401,1290 534,1362C666,1434 816,1470 983,1470C1128,1470 1257,1440 1370,1380C1483,1320 1570,1235 1633,1124C1695,1013 1726,884 1726,739M698,612C698,457 759,379 881,379C1010,379 1080,477 1092,672l12,239C1062,922 1017,928 969,928C884,928 817,900 770,843C722,786 698,709 698,612z\"/>\n  <glyph unicode=\"A\" horiz-adv-x=\"1354\" d=\"M1100,0l-146,406l-559,0l-143,-406l-252,0l547,1468l260,0l547,-1468M891,612l-137,398C744,1037 730,1079 713,1136C695,1193 683,1235 676,1262C658,1180 632,1090 597,993l-132,-381z\"/>\n  <glyph unicode=\"B\" horiz-adv-x=\"1352\" d=\"M193,1462l434,0C828,1462 974,1433 1064,1374C1153,1315 1198,1223 1198,1096C1198,1011 1176,940 1132,883C1088,826 1025,791 942,776l0,-10C1045,747 1120,709 1169,652C1217,595 1241,517 1241,420C1241,289 1195,186 1104,112C1012,37 884,0 721,0l-528,0M432,858l230,0C762,858 835,874 881,906C927,937 950,991 950,1067C950,1136 925,1185 876,1216C826,1247 747,1262 639,1262l-207,0M432,664l0,-463l254,0C786,201 862,220 913,259C964,297 989,357 989,440C989,516 963,572 911,609C859,646 780,664 674,664z\"/>\n  <glyph unicode=\"C\" horiz-adv-x=\"1298\" d=\"M815,1278C678,1278 570,1229 491,1132C412,1035 373,900 373,729C373,550 411,414 487,322C562,230 672,184 815,184C877,184 937,190 995,203C1053,215 1113,231 1176,250l0,-205C1061,2 931,-20 786,-20C572,-20 408,45 293,175C178,304 121,490 121,731C121,883 149,1016 205,1130C260,1244 341,1331 446,1392C551,1453 675,1483 817,1483C966,1483 1104,1452 1231,1389l-86,-199C1096,1213 1044,1234 989,1252C934,1269 876,1278 815,1278z\"/>\n  <glyph unicode=\"D\" horiz-adv-x=\"1503\" d=\"M1382,745C1382,504 1315,319 1181,192C1047,64 854,0 602,0l-409,0l0,1462l452,0C878,1462 1059,1399 1188,1274C1317,1149 1382,972 1382,745M1130,737C1130,1087 966,1262 639,1262l-207,0l0,-1061l170,0C954,201 1130,380 1130,737z\"/>\n  <glyph unicode=\"E\" horiz-adv-x=\"1143\" d=\"M1020,0l-827,0l0,1462l827,0l0,-202l-588,0l0,-398l551,0l0,-200l-551,0l0,-459l588,0z\"/>\n  <glyph unicode=\"F\" horiz-adv-x=\"1090\" d=\"M430,0l-237,0l0,1462l825,0l0,-202l-588,0l0,-457l551,0l0,-203l-551,0z\"/>\n  <glyph unicode=\"G\" horiz-adv-x=\"1487\" d=\"M791,793l538,0l0,-734C1241,30 1157,10 1076,-2C995,-14 907,-20 813,-20C592,-20 421,46 301,177C181,308 121,492 121,731C121,966 189,1151 324,1284C459,1417 646,1483 883,1483C1036,1483 1180,1454 1317,1395l-84,-199C1114,1251 996,1278 877,1278C721,1278 598,1229 507,1131C416,1033 371,899 371,729C371,550 412,415 494,322C575,229 693,182 846,182C923,182 1006,192 1094,211l0,377l-303,0z\"/>\n  <glyph unicode=\"H\" horiz-adv-x=\"1538\" d=\"M1346,0l-240,0l0,659l-674,0l0,-659l-239,0l0,1462l239,0l0,-598l674,0l0,598l240,0z\"/>\n  <glyph unicode=\"J\" horiz-adv-x=\"612\" d=\"M8,-408C-57,-408 -112,-400 -156,-383l0,201C-100,-196 -51,-203 -10,-203C121,-203 186,-120 186,45l0,1417l240,0l0,-1409C426,-96 391,-210 320,-289C249,-368 145,-408 8,-408z\"/>\n  <glyph unicode=\"K\" horiz-adv-x=\"1309\" d=\"M1309,0l-277,0l-459,662l-141,-115l0,-547l-239,0l0,1462l239,0l0,-698C497,844 562,921 627,995l395,467l272,0C1039,1162 856,948 745,821z\"/>\n  <glyph unicode=\"L\" horiz-adv-x=\"1110\" d=\"M193,0l0,1462l239,0l0,-1257l619,0l0,-205z\"/>\n  <glyph unicode=\"M\" horiz-adv-x=\"1890\" d=\"M825,0l-424,1221l-8,0C404,1040 410,870 410,711l0,-711l-217,0l0,1462l337,0l406,-1163l6,0l418,1163l338,0l0,-1462l-230,0l0,723C1468,796 1470,890 1474,1007C1477,1124 1480,1194 1483,1219l-8,0l-439,-1219z\"/>\n  <glyph unicode=\"N\" horiz-adv-x=\"1604\" d=\"M1411,0l-293,0l-719,1165l-8,0l5,-65C405,976 410,863 410,760l0,-760l-217,0l0,1462l290,0l717,-1159l6,0C1205,318 1202,374 1198,471C1194,567 1192,642 1192,696l0,766l219,0z\"/>\n  <glyph unicode=\"O\" horiz-adv-x=\"1612\" d=\"M1491,733C1491,495 1432,310 1313,178C1194,46 1025,-20 807,-20C586,-20 417,46 299,177C180,308 121,494 121,735C121,976 181,1162 300,1291C419,1420 588,1485 809,1485C1026,1485 1194,1419 1313,1288C1432,1157 1491,972 1491,733M375,733C375,553 411,417 484,324C557,231 664,184 807,184C949,184 1056,230 1129,322C1201,414 1237,551 1237,733C1237,912 1201,1048 1130,1141C1058,1234 951,1280 809,1280C666,1280 558,1234 485,1141C412,1048 375,912 375,733z\"/>\n  <glyph unicode=\"P\" horiz-adv-x=\"1260\" d=\"M1161,1020C1161,867 1111,750 1011,669C911,588 769,547 584,547l-152,0l0,-547l-239,0l0,1462l421,0C797,1462 934,1425 1025,1350C1116,1275 1161,1165 1161,1020M432,748l127,0C682,748 772,769 829,812C886,855 915,921 915,1012C915,1096 889,1159 838,1200C787,1241 707,1262 598,1262l-166,0z\"/>\n  <glyph unicode=\"Q\" horiz-adv-x=\"1612\" d=\"M1491,733C1491,556 1457,406 1390,285C1322,164 1223,78 1094,29l350,-377l-322,0l-276,328l-39,0C586,-20 417,46 299,177C180,308 121,494 121,735C121,976 181,1162 300,1291C419,1420 588,1485 809,1485C1026,1485 1194,1419 1313,1288C1432,1157 1491,972 1491,733M375,733C375,553 411,417 484,324C557,231 664,184 807,184C949,184 1056,230 1129,322C1201,414 1237,551 1237,733C1237,912 1201,1048 1130,1141C1058,1234 951,1280 809,1280C666,1280 558,1234 485,1141C412,1048 375,912 375,733z\"/>\n  <glyph unicode=\"R\" horiz-adv-x=\"1309\" d=\"M432,782l166,0C709,782 790,803 840,844C890,885 915,947 915,1028C915,1111 888,1170 834,1206C780,1242 699,1260 590,1260l-158,0M432,584l0,-584l-239,0l0,1462l413,0C795,1462 934,1427 1025,1356C1116,1285 1161,1179 1161,1036C1161,854 1066,724 877,647l413,-647l-272,0l-350,584z\"/>\n  <glyph unicode=\"S\" horiz-adv-x=\"1126\" d=\"M1036,397C1036,267 989,165 895,91C801,17 671,-20 506,-20C341,-20 205,6 100,57l0,226C167,252 238,227 313,209C388,191 457,182 522,182C617,182 687,200 732,236C777,272 799,320 799,381C799,436 778,482 737,520C696,558 610,603 481,655C348,709 254,771 199,840C144,909 117,993 117,1090C117,1212 160,1308 247,1378C334,1448 450,1483 596,1483C736,1483 875,1452 1014,1391l-76,-195C808,1251 692,1278 590,1278C513,1278 454,1261 414,1228C374,1194 354,1149 354,1094C354,1056 362,1024 378,997C394,970 420,944 457,920C494,896 560,864 655,825C762,780 841,739 891,700C941,661 978,618 1001,569C1024,520 1036,463 1036,397z\"/>\n  <glyph unicode=\"T\" horiz-adv-x=\"1159\" d=\"M698,0l-239,0l0,1257l-430,0l0,205l1099,0l0,-205l-430,0z\"/>\n  <glyph unicode=\"U\" horiz-adv-x=\"1520\" d=\"M1339,1462l0,-946C1339,408 1316,314 1270,233C1223,152 1156,89 1069,46C981,2 876,-20 754,-20C573,-20 432,28 331,124C230,220 180,352 180,520l0,942l240,0l0,-925C420,416 448,327 504,270C560,213 646,184 762,184C987,184 1100,302 1100,539l0,923z\"/>\n  <glyph unicode=\"V\" horiz-adv-x=\"1274\" d=\"M1026,1462l248,0l-512,-1462l-252,0l-510,1462l246,0l305,-909C567,510 584,454 602,386C620,317 632,266 637,233C646,284 659,342 677,409C695,476 710,525 721,557z\"/>\n  <glyph unicode=\"W\" horiz-adv-x=\"1937\" d=\"M1542,0l-260,0l-248,872C1023,910 1010,965 994,1037C978,1108 968,1158 965,1186C958,1143 948,1088 933,1020C918,952 905,901 895,868l-242,-868l-260,0l-189,732l-192,730l244,0l209,-852C498,473 521,353 535,248C542,305 553,368 568,438C583,508 596,565 608,608l238,854l237,0l244,-858C1350,525 1375,406 1401,248C1411,343 1435,465 1473,612l208,850l242,0z\"/>\n  <glyph unicode=\"X\" horiz-adv-x=\"1274\" d=\"M1270,0l-275,0l-366,598l-369,-598l-256,0l485,758l-454,704l266,0l338,-553l338,553l258,0l-457,-708z\"/>\n  <glyph unicode=\"Y\" horiz-adv-x=\"1212\" d=\"M606,795l346,667l260,0l-487,-895l0,-567l-240,0l0,559l-485,903l260,0z\"/>\n  <glyph unicode=\"Z\" horiz-adv-x=\"1178\" d=\"M1112,0l-1046,0l0,166l737,1091l-717,0l0,205l1006,0l0,-168l-740,-1089l760,0z\"/>\n  <glyph unicode=\"\\\" horiz-adv-x=\"799\" d=\"M238,1462l544,-1462l-221,0l-545,1462z\"/>\n  <glyph unicode=\"^\" horiz-adv-x=\"1100\" d=\"M29,535l436,935l121,0l485,-935l-194,0l-349,694l-307,-694z\"/>\n  <glyph unicode=\"_\" horiz-adv-x=\"879\" d=\"M883,-319l-887,0l0,135l887,0z\"/>\n  <glyph unicode=\"a\" horiz-adv-x=\"1188\" d=\"M860,0l-47,154l-8,0C752,87 698,41 644,17C590,-8 521,-20 436,-20C327,-20 243,9 182,68C121,127 90,210 90,317C90,431 132,517 217,575C302,633 431,665 604,670l191,6l0,59C795,806 779,859 746,894C713,929 661,946 592,946C535,946 481,938 429,921C377,904 327,885 279,862l-76,168C263,1061 329,1085 400,1102C471,1118 539,1126 602,1126C743,1126 849,1095 921,1034C992,973 1028,876 1028,745l0,-745M510,160C595,160 664,184 716,232C767,279 793,346 793,432l0,96l-142,-6C540,518 460,500 410,467C359,434 334,383 334,315C334,266 349,228 378,201C407,174 451,160 510,160z\"/>\n  <glyph unicode=\"b\" horiz-adv-x=\"1276\" d=\"M733,1126C871,1126 979,1076 1056,976C1133,876 1171,736 1171,555C1171,374 1132,233 1054,132C976,31 868,-20 729,-20C589,-20 480,30 403,131l-16,0l-43,-131l-176,0l0,1556l235,0l0,-370C403,1159 402,1118 399,1064C396,1010 394,976 393,961l10,0C478,1071 588,1126 733,1126M672,934C577,934 509,906 468,851C426,795 404,702 403,571l0,-16C403,420 424,323 467,263C510,202 579,172 676,172C759,172 823,205 866,271C909,337 930,432 930,557C930,808 844,934 672,934z\"/>\n  <glyph unicode=\"c\" horiz-adv-x=\"1014\" d=\"M614,-20C447,-20 320,29 233,127C146,224 102,364 102,547C102,733 148,876 239,976C330,1076 461,1126 633,1126C750,1126 855,1104 948,1061l-71,-189C778,911 696,930 631,930C440,930 344,803 344,549C344,425 368,332 416,270C463,207 533,176 625,176C730,176 829,202 922,254l0,-205C880,24 835,7 788,-4C740,-15 682,-20 614,-20z\"/>\n  <glyph unicode=\"d\" horiz-adv-x=\"1276\" d=\"M541,-20C403,-20 295,30 218,130C141,230 102,370 102,551C102,732 141,874 220,975C298,1076 406,1126 545,1126C690,1126 801,1072 877,965l12,0C878,1044 872,1107 872,1153l0,403l236,0l0,-1556l-184,0l-41,145l-11,0C797,35 686,-20 541,-20M604,170C701,170 771,197 815,252C859,306 882,394 883,516l0,33C883,688 860,787 815,846C770,905 699,934 602,934C519,934 456,901 411,834C366,767 344,671 344,547C344,424 366,331 409,267C452,202 517,170 604,170z\"/>\n  <glyph unicode=\"e\" horiz-adv-x=\"1180\" d=\"M651,-20C479,-20 345,30 248,131C151,231 102,369 102,545C102,726 147,868 237,971C327,1074 451,1126 608,1126C754,1126 869,1082 954,993C1039,904 1081,782 1081,627l0,-127l-737,0C347,393 376,310 431,253C486,195 563,166 662,166C727,166 788,172 845,185C901,197 961,217 1026,246l0,-191C969,28 911,8 852,-3C793,-14 726,-20 651,-20M608,948C533,948 474,924 429,877C384,830 357,761 348,670l502,0C849,761 827,831 784,878C741,925 683,948 608,948z\"/>\n  <glyph unicode=\"f\" horiz-adv-x=\"743\" d=\"M723,928l-270,0l0,-928l-236,0l0,928l-182,0l0,110l182,72l0,72C217,1313 248,1410 309,1473C370,1536 464,1567 590,1567C673,1567 754,1553 834,1526l-62,-178C714,1367 659,1376 606,1376C553,1376 514,1360 490,1327C465,1294 453,1244 453,1178l0,-72l270,0z\"/>\n  <glyph unicode=\"g\" horiz-adv-x=\"1139\" d=\"M1102,1106l0,-129l-189,-35C930,919 945,890 956,856C967,822 973,786 973,748C973,634 934,544 855,479C776,414 668,381 530,381C495,381 463,384 434,389C383,358 358,321 358,279C358,254 370,235 394,222C417,209 461,203 524,203l193,0C839,203 932,177 995,125C1058,73 1090,-2 1090,-100C1090,-225 1038,-322 935,-390C832,-458 682,-492 487,-492C336,-492 221,-465 142,-412C63,-359 23,-283 23,-184C23,-116 45,-59 88,-12C131,34 191,66 268,84C237,97 211,119 191,149C170,178 160,209 160,242C160,283 172,318 195,347C218,376 253,404 299,432C242,457 195,497 160,553C124,608 106,673 106,748C106,868 144,961 220,1027C295,1093 403,1126 543,1126C574,1126 607,1124 642,1120C676,1115 702,1111 719,1106M233,-172C233,-223 256,-262 302,-289C347,-316 411,-330 494,-330C622,-330 717,-312 780,-275C843,-238 874,-190 874,-129C874,-81 857,-47 823,-26C788,-6 724,4 631,4l-178,0C386,4 332,-12 293,-43C253,-75 233,-118 233,-172M334,748C334,679 352,625 388,588C423,551 474,532 541,532C677,532 745,605 745,750C745,822 728,878 695,917C661,956 610,975 541,975C473,975 422,956 387,917C352,878 334,822 334,748z\"/>\n  <glyph unicode=\"h\" horiz-adv-x=\"1300\" d=\"M1141,0l-236,0l0,680C905,765 888,829 854,871C819,913 765,934 690,934C591,934 519,905 473,846C426,787 403,688 403,549l0,-549l-235,0l0,1556l235,0l0,-395C403,1098 399,1030 391,958l15,0C438,1011 483,1053 540,1082C597,1111 663,1126 739,1126C1007,1126 1141,991 1141,721z\"/>\n  <glyph unicode=\"i\" horiz-adv-x=\"571\" d=\"M403,0l-235,0l0,1106l235,0M154,1399C154,1441 166,1473 189,1496C212,1519 244,1530 287,1530C328,1530 361,1519 384,1496C407,1473 418,1441 418,1399C418,1359 407,1328 384,1305C361,1282 328,1270 287,1270C244,1270 212,1282 189,1305C166,1328 154,1359 154,1399z\"/>\n  <glyph unicode=\"j\" horiz-adv-x=\"571\" d=\"M55,-492C-16,-492 -74,-484 -121,-467l0,186C-76,-293 -29,-299 18,-299C118,-299 168,-242 168,-129l0,1235l235,0l0,-1251C403,-259 373,-345 314,-404C254,-463 168,-492 55,-492M154,1399C154,1441 166,1473 189,1496C212,1519 244,1530 287,1530C328,1530 361,1519 384,1496C407,1473 418,1441 418,1399C418,1359 407,1328 384,1305C361,1282 328,1270 287,1270C244,1270 212,1282 189,1305C166,1328 154,1359 154,1399z\"/>\n  <glyph unicode=\"k\" horiz-adv-x=\"1171\" d=\"M395,584l133,166l334,356l271,0l-445,-475l473,-631l-276,0l-355,485l-129,-106l0,-379l-233,0l0,1556l233,0l0,-759l-12,-213z\"/>\n  <glyph unicode=\"l\" horiz-adv-x=\"571\" d=\"M403,0l-235,0l0,1556l235,0z\"/>\n  <glyph unicode=\"m\" horiz-adv-x=\"1958\" d=\"M1100,0l-236,0l0,682C864,767 848,830 816,872C784,913 734,934 666,934C575,934 509,905 467,846C424,787 403,688 403,551l0,-551l-235,0l0,1106l184,0l33,-145l12,0C428,1014 472,1054 531,1083C589,1112 653,1126 723,1126C893,1126 1006,1068 1061,952l16,0C1110,1007 1156,1049 1215,1080C1274,1111 1342,1126 1419,1126C1551,1126 1647,1093 1708,1026C1768,959 1798,858 1798,721l0,-721l-235,0l0,682C1563,767 1547,830 1515,872C1482,913 1432,934 1364,934C1273,934 1206,906 1164,849C1121,792 1100,704 1100,586z\"/>\n  <glyph unicode=\"n\" horiz-adv-x=\"1300\" d=\"M1141,0l-236,0l0,680C905,765 888,829 854,871C819,913 765,934 690,934C591,934 518,905 472,846C426,787 403,689 403,551l0,-551l-235,0l0,1106l184,0l33,-145l12,0C430,1014 478,1054 539,1083C600,1112 668,1126 743,1126C1008,1126 1141,991 1141,721z\"/>\n  <glyph unicode=\"o\" horiz-adv-x=\"1251\" d=\"M1149,555C1149,374 1103,233 1010,132C917,31 788,-20 623,-20C520,-20 428,3 349,50C270,97 209,164 166,251C123,338 102,440 102,555C102,734 148,874 240,975C332,1076 462,1126 629,1126C789,1126 916,1075 1009,972C1102,869 1149,730 1149,555M344,555C344,300 438,172 627,172C814,172 907,300 907,555C907,808 813,934 625,934C526,934 455,901 411,836C366,771 344,677 344,555z\"/>\n  <glyph unicode=\"p\" horiz-adv-x=\"1276\" d=\"M729,-20C589,-20 480,30 403,131l-14,0C398,38 403,-19 403,-39l0,-453l-235,0l0,1598l190,0C363,1085 374,1036 391,958l12,0C476,1070 586,1126 733,1126C871,1126 979,1076 1056,976C1133,876 1171,736 1171,555C1171,374 1132,233 1054,132C975,31 867,-20 729,-20M672,934C579,934 511,907 468,852C425,797 403,710 403,590l0,-35C403,420 424,323 467,263C510,202 579,172 676,172C757,172 820,205 864,272C908,339 930,434 930,557C930,681 908,775 865,839C821,902 757,934 672,934z\"/>\n  <glyph unicode=\"q\" horiz-adv-x=\"1276\" d=\"M606,168C705,168 776,197 819,254C862,311 883,397 883,512l0,37C883,686 861,784 817,844C772,904 701,934 602,934C518,934 454,901 410,834C366,767 344,672 344,547C344,294 431,168 606,168M539,-20C402,-20 295,30 218,131C141,231 102,371 102,551C102,731 141,872 220,974C299,1075 407,1126 545,1126C614,1126 677,1113 732,1088C787,1062 836,1020 879,961l8,0l26,145l195,0l0,-1598l-236,0l0,469C872,6 873,37 876,70C879,103 881,128 883,145l-13,0C801,35 690,-20 539,-20z\"/>\n  <glyph unicode=\"r\" horiz-adv-x=\"883\" d=\"M729,1126C776,1126 815,1123 846,1116l-23,-219C790,905 755,909 719,909C625,909 549,878 491,817C432,756 403,676 403,578l0,-578l-235,0l0,1106l184,0l31,-195l12,0C432,977 480,1029 539,1068C598,1107 661,1126 729,1126z\"/>\n  <glyph unicode=\"s\" horiz-adv-x=\"997\" d=\"M911,315C911,207 872,124 793,67C714,9 602,-20 455,-20C308,-20 189,2 100,47l0,203C230,190 351,160 463,160C608,160 680,204 680,291C680,319 672,342 656,361C640,380 614,399 577,419C540,439 489,462 424,487C297,536 211,586 166,635C121,684 98,748 98,827C98,922 136,995 213,1048C289,1100 393,1126 524,1126C654,1126 777,1100 893,1047l-76,-177C698,919 597,944 516,944C392,944 330,909 330,838C330,803 346,774 379,750C411,726 481,693 590,651C681,616 748,583 789,554C830,525 861,491 881,453C901,414 911,368 911,315z\"/>\n  <glyph unicode=\"t\" horiz-adv-x=\"805\" d=\"M580,170C637,170 695,179 752,197l0,-177C726,9 693,-1 652,-8C611,-16 568,-20 524,-20C301,-20 190,97 190,332l0,596l-151,0l0,104l162,86l80,234l145,0l0,-246l315,0l0,-178l-315,0l0,-592C426,279 440,238 469,211C497,184 534,170 580,170z\"/>\n  <glyph unicode=\"u\" horiz-adv-x=\"1300\" d=\"M948,0l-33,145l-12,0C870,94 824,53 764,24C703,-5 634,-20 557,-20C423,-20 323,13 257,80C191,147 158,248 158,383l0,723l237,0l0,-682C395,339 412,276 447,234C482,191 536,170 610,170C709,170 781,200 828,259C874,318 897,416 897,555l0,551l236,0l0,-1106z\"/>\n  <glyph unicode=\"v\" horiz-adv-x=\"1096\" d=\"M420,0l-420,1106l248,0l225,-643C512,355 535,268 543,201l8,0C557,249 580,336 621,463l225,643l250,0l-422,-1106z\"/>\n  <glyph unicode=\"w\" horiz-adv-x=\"1673\" d=\"M1075,0l-143,516C915,571 883,698 838,897l-9,0C790,717 760,589 737,514l-147,-514l-260,0l-310,1106l240,0l141,-545C433,426 456,311 469,215l6,0C482,264 492,320 506,383C519,446 531,493 541,524l168,582l258,0l163,-582C1140,491 1153,441 1168,374C1183,307 1191,254 1194,217l8,0C1212,299 1235,414 1272,561l143,545l236,0l-312,-1106z\"/>\n  <glyph unicode=\"x\" horiz-adv-x=\"1128\" d=\"M414,565l-371,541l268,0l252,-387l254,387l266,0l-372,-541l391,-565l-266,0l-273,414l-272,-414l-266,0z\"/>\n  <glyph unicode=\"y\" horiz-adv-x=\"1098\" d=\"M0,1106l256,0l225,-627C515,390 538,306 549,227l8,0C563,264 574,308 590,361C606,413 691,661 844,1106l254,0l-473,-1253C539,-377 396,-492 195,-492C143,-492 92,-486 43,-475l0,186C78,-297 119,-301 164,-301C277,-301 357,-235 403,-104l41,104z\"/>\n  <glyph unicode=\"z\" horiz-adv-x=\"979\" d=\"M907,0l-839,0l0,145l559,781l-525,0l0,180l789,0l0,-164l-547,-762l563,0z\"/>\n  <glyph unicode=\"~\" horiz-adv-x=\"1169\" d=\"M330,692C297,692 260,682 219,662C178,642 137,612 96,571l0,191C162,834 245,870 346,870C390,870 432,866 471,857C510,848 559,832 618,807C705,770 779,752 838,752C873,752 911,762 953,783C994,804 1034,833 1073,872l0,-190C1003,608 920,571 823,571C780,571 737,576 696,587C654,597 605,614 549,637C464,674 391,692 330,692z\"/>\n  <glyph unicode=\"&#xA0;\" horiz-adv-x=\"532\"/>\n  <glyph unicode=\"&#xA3;\" horiz-adv-x=\"1169\" d=\"M690,1481C819,1481 944,1454 1065,1399l-76,-182C881,1264 786,1288 705,1288C568,1288 500,1215 500,1069l0,-244l397,0l0,-172l-397,0l0,-182C500,410 489,359 467,316C445,273 407,237 354,207l756,0l0,-207l-1038,0l0,195C137,215 186,247 217,291C248,335 264,394 264,469l0,184l-188,0l0,172l188,0l0,256C264,1206 302,1304 378,1375C453,1446 557,1481 690,1481z\"/>\n  <glyph unicode=\"&#xA9;\" horiz-adv-x=\"1704\" d=\"M893,1034C819,1034 762,1007 722,954C682,900 662,826 662,731C662,633 680,558 716,505C752,452 811,426 893,426C930,426 969,431 1011,441C1053,451 1089,463 1120,477l0,-158C1043,285 965,268 885,268C754,268 652,308 580,389C507,469 471,583 471,731C471,874 508,986 581,1069C654,1151 756,1192 887,1192C979,1192 1070,1169 1161,1122l-65,-143C1025,1016 958,1034 893,1034M100,731C100,864 133,989 200,1106C267,1223 358,1315 475,1382C592,1449 717,1483 852,1483C985,1483 1110,1450 1227,1383C1344,1316 1436,1225 1503,1108C1570,991 1604,866 1604,731C1604,600 1572,476 1507,361C1442,246 1352,153 1235,84C1118,15 991,-20 852,-20C714,-20 587,15 470,84C353,153 263,245 198,360C133,475 100,599 100,731M223,731C223,618 251,513 308,416C364,319 441,242 538,186C635,130 740,102 852,102C965,102 1071,131 1168,188C1265,245 1342,321 1398,418C1453,514 1481,618 1481,731C1481,843 1453,948 1397,1046C1340,1143 1263,1220 1166,1276C1068,1332 963,1360 852,1360C740,1360 636,1332 540,1277C443,1222 366,1145 309,1048C252,951 223,845 223,731z\"/>\n  <glyph unicode=\"&#xAD;\" horiz-adv-x=\"659\" d=\"M72,449l0,200l514,0l0,-200z\"/>\n  <glyph unicode=\"&#xAE;\" horiz-adv-x=\"1704\" d=\"M748,770l69,0C866,770 904,782 929,805C954,828 967,862 967,905C967,953 955,987 931,1006C906,1025 868,1034 815,1034l-67,0M1157,909C1157,795 1106,717 1004,676l237,-397l-211,0l-192,346l-90,0l0,-346l-189,0l0,903l262,0C937,1182 1022,1159 1076,1114C1130,1069 1157,1000 1157,909M100,731C100,864 133,989 200,1106C267,1223 358,1315 475,1382C592,1449 717,1483 852,1483C985,1483 1110,1450 1227,1383C1344,1316 1436,1225 1503,1108C1570,991 1604,866 1604,731C1604,600 1572,476 1507,361C1442,246 1352,153 1235,84C1118,15 991,-20 852,-20C714,-20 587,15 470,84C353,153 263,245 198,360C133,475 100,599 100,731M223,731C223,618 251,513 308,416C364,319 441,242 538,186C635,130 740,102 852,102C965,102 1071,131 1168,188C1265,245 1342,321 1398,418C1453,514 1481,618 1481,731C1481,843 1453,948 1397,1046C1340,1143 1263,1220 1166,1276C1068,1332 963,1360 852,1360C740,1360 636,1332 540,1277C443,1222 366,1145 309,1048C252,951 223,845 223,731z\"/>\n  <glyph unicode=\"&#x2018;\" horiz-adv-x=\"395\" d=\"M37,961l-12,22C38,1038 62,1113 96,1207C130,1301 165,1386 201,1462l170,0C328,1291 295,1124 270,961z\"/>\n  <glyph unicode=\"&#x2019;\" horiz-adv-x=\"395\" d=\"M356,1462l15,-22C336,1301 277,1141 195,961l-170,0C71,1154 104,1321 125,1462z\"/>\n  <glyph unicode=\"&#x201C;\" horiz-adv-x=\"813\" d=\"M440,983C475,1118 535,1278 618,1462l170,0C742,1265 709,1098 688,961l-233,0M25,983C38,1038 62,1113 96,1207C130,1301 165,1386 201,1462l170,0C328,1291 295,1124 270,961l-233,0z\"/>\n  <glyph unicode=\"&#x201D;\" horiz-adv-x=\"813\" d=\"M371,1440C336,1301 277,1141 195,961l-170,0C71,1154 104,1321 125,1462l231,0M788,1440C753,1301 694,1141 612,961l-172,0C486,1142 520,1309 543,1462l231,0z\"/>\n  <glyph unicode=\"&#x2022;\" horiz-adv-x=\"770\" d=\"M131,748C131,840 153,910 197,958C241,1006 304,1030 385,1030C466,1030 528,1006 573,958C617,909 639,839 639,748C639,658 617,588 572,539C527,490 465,465 385,465C305,465 243,489 198,538C153,586 131,656 131,748z\"/>\n  <glyph unicode=\"&#x20AC;\" horiz-adv-x=\"1188\" d=\"M799,1278C705,1278 628,1250 569,1194C509,1138 469,1053 449,940l456,0l0,-154l-471,0l-2,-45l0,-55l2,-39l408,0l0,-153l-391,0C494,286 615,182 815,182C910,182 1008,203 1108,244l0,-203C1021,0 919,-20 803,-20C642,-20 512,24 412,112C311,200 246,327 215,494l-152,0l0,153l136,0l-2,37l0,37l2,65l-136,0l0,154l150,0C238,1107 302,1239 404,1334C506,1429 638,1477 799,1477C932,1477 1052,1448 1157,1389l-84,-187C970,1253 879,1278 799,1278z\"/>\n  <glyph unicode=\"&#x2122;\" horiz-adv-x=\"1561\" d=\"M375,741l-146,0l0,592l-202,0l0,129l553,0l0,-129l-205,0M963,741l-185,543l-6,0l4,-119l0,-424l-141,0l0,721l217,0l178,-534l187,534l210,0l0,-721l-147,0l0,414l4,129l-6,0l-193,-543z\"/>\n  <glyph unicode=\"I\" horiz-adv-x=\"625\" d=\"M193,0l0,1462l239,0l0,-1462z\"/>\n </font>\n")
  // diagram.to_defs(fs.readFileSync('../resources/background.svg'))
  diagram.to_defs("<g class=\"FCHBox\">\n  <g>\n    <path fill=\"#FFFFFF\" d=\"m160 50c0 1 -1 3 -2 3h-155c-1 0 -2 -1 -2 -2v-45c0 -1 1 -2 3 -2h155c1 0 3 1 3 3v45z\"/>\n    <path fill=\"#AAB2BD\" d=\"m160 0v50h-155v-45h155m0 -5h-155c-3 0 -5 2 -5 5v45c0 3 2 5 5 5h155c3 0 5 -2 5 -5v-45c0 -3 -2 -5 -5 -5l0 0z\"/>\n  </g>\n  <rect class=\"FCHBox-Text-bg\"  fill=\"none\" width=\"135\" height=\"32.7\"/>\n  <g class=\"FCHBox-Text\">\n    <text class=\"FCHBox-Text-title\" x=\"15\" y=\"21\" fill=\"#AAB2BD\" font-family=\"'OpenSans-Semibold'\" font-size=\"14\">Action Title</text>\n    <text class=\"FCHBox-Text-type\" x=\"15\" y=\"42\" fill=\"#AAB2BD\" font-family=\"'OpenSans-Semibold'\" font-size=\"14\">Type: Normal</text>\n  </g>\n</g>\n")
  diagram.to_defs("<pattern id=\"fhc-line-pattern\" patternContentUnits=\"objectBoundingBox\" class=\"FCHLine-pattern\">\n  <circle fill=\"#AAB2BD\" r=\"2.5\"/>\n</pattern>\n")
  diagram.to_defs("<g class=\"FCHLine-arrow\">\n  <marker id=\"fch-endarrow\" overflow=\"visible\" orient=\"auto\" >\n   <polygon points=\"-5,-5 0,0 -5,5\" fill=\"#AAB2BD\"/>\n  </marker>\n</g>\n")
  diagram.to_defs("<g class=\"FCHLine-intersection Edge-intersection\">\n  <!--rect x=\"18\" y=\"17\" width=\"9\" height=\"11\" />\n  <line x1=\"45\" y1=\"28\" x2=\"30\" y2=\"28\"/>\n  <line x1=\"30\" y1=\"17\" x2=\"45\" y2=\"17\"/>\n  <line x1=\"15\" y1=\"28\"         y2=\"28\" />\n  <line         y1=\"17\" x2=\"15\" y2=\"17\"/>\n  <line x1=\"17\" y1=\"45\" x2=\"17\"/>\n  <line x1=\"28\" x2=\"28\" y2=\"45\"/-->\n<rect x=\"12\" y=\"10\" width=\"10\" height=\"13\"/>\n<line x1=\"34\" y1=\"23\" x2=\"23\" y2=\"23\" />\n\n<line x1=\"23\" y1=\"11\" x2=\"34\" y2=\"11\" />\n<line x1=\"11\" y1=\"23\"         y2=\"23\" />\n<line         y1=\"11\" x2=\"11\" y2=\"11\" />\n<line x1=\"11\" y1=\"34\"   x2=\"11\"         />\n<line x1=\"23\"           x2=\"23\" y2=\"34\" />\n\n\n</g>\n")
  diagram.to_defs("<g class=\"FCHLine\">\n  <line class=\"FCHLine-dots Edge\" />\n</g>\n")
  diagram.to_defs("<g class=\"FCHLine-witharrow\">\n  <line class=\"FCHLine-dots Edge\" />\n  <line class=\"FCHLine-endarrow Edge--end\" />\n</g>\n")
  diagram.display()


}()

},{"../index.js":11,"../util/dom.js":71,"../util/unique_id.js":72,"fs":73,"lorem-ipsum":61,"random-number":62,"random-token":63}],70:[function(require,module,exports){
void function(){
  "use strict"
  module.exports = function defaults(obj) {
    Array.prototype.slice.call(arguments, 1).forEach(function(source){
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop]
      }
    })
    return obj
  }
}()

},{}],71:[function(require,module,exports){
void function(){

  function query(selector, parent){
    parent = parent || document
    return parent.querySelector(selector)
  }

  function create(tag_name, attrs){
    var node = document.createElement(tag_name)
    if ( attrs ) { set_attributes(node, attrs) }
    return node
  }

  function set_attribute(node, attr){
    node.setAttribute(name,value)
  }

  function set_attributes(node, attrs){
    Object.keys(attrs)
          .forEach(function(name){
            node.setAttribute(name, attrs[name])
          })
  }

  function get_text(node){
    return node.textContent || node.innerText
  }

  function set_text(node, text){
    node.textContent = node.innerText = text
  }

  function insertAfter(parentEl, sp1, sp2){
    parentEl.insertBefore(sp1, sp2.nextSibling)
  }

  function removeNode(node){
    node.parentNode.removeChild(node)
  }

  module.exports = {
    $             : query
  //, $id           : document.getElementById.bind(document)
  , $id           : function(id){ return document.getElementById(id) }
  , create        : create
  , attr          : set_attribute
  , attrs         : set_attributes
  , get_text      : get_text
  , set_text      : set_text
  , remove        : removeNode
  , insertAfter   : insertAfter
  }

}()

},{}],72:[function(require,module,exports){
void function(){
  var ids = []
  var rt = require('random-token')
  var letters = rt.gen('abcdefghijklmnopqrstuvwxyt')

  function token(){ return letters(1) + rt(16) }

  module.exports = function(){
    var id = token()
    while ( ids.indexOf(id) != -1 ){
      id = token()
    }
    return id
  }
}()

},{"random-token":63}],73:[function(require,module,exports){

},{}],74:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}]},{},[69])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdXNyL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9hcnIuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvZGlhZ3JhbS9kaWFncmFtLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L2RpYWdyYW0vZWRnZXMuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvZGlhZ3JhbS9pbnRlcnNlY3QuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvZGlhZ3JhbS9pdGVtLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L2RpYWdyYW0vdHJhbnNsYXRlLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L2RpYWdyYW0vdmVjdG9ycy5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ncmFwaC9lZGdlLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L2dyYXBoL2dyYXBoLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L2dyYXBoL25vZGUuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvaW5kZXguanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL2luZGV4LmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbGF5b3V0LmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9jcm9zc0NvdW50LmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvaW5pdExheWVyR3JhcGhzLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvaW5pdE9yZGVyLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvc29ydExheWVyLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcG9zaXRpb24uanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9yYW5rLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay9hY3ljbGljLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay9jb25zdHJhaW50cy5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvZGFncmUvbGliL3JhbmsvZmVhc2libGVUcmVlLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay9pbml0UmFuay5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvZGFncmUvbGliL3JhbmsvcmFua1V0aWwuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9yYW5rL3NpbXBsZXguanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi91dGlsLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9saWIvdmVyc2lvbi5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvZGFncmUvbm9kZV9tb2R1bGVzL2NwLWRhdGEvaW5kZXguanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9jcC1kYXRhL2xpYi9Qcmlvcml0eVF1ZXVlLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9ub2RlX21vZHVsZXMvY3AtZGF0YS9saWIvU2V0LmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9ub2RlX21vZHVsZXMvY3AtZGF0YS9saWIvdXRpbC5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvZGFncmUvbm9kZV9tb2R1bGVzL2NwLWRhdGEvbGliL3ZlcnNpb24uanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9pbmRleC5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvZGFncmUvbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9CYXNlR3JhcGguanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvQ0RpZ3JhcGguanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvQ0dyYXBoLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL0RpZ3JhcGguanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvR3JhcGguanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2NvbXBvbmVudHMuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9kaWprc3RyYUFsbC5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvZGFncmUvbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZmluZEN5Y2xlcy5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvZGFncmUvbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZmxveWRXYXJzaGFsbC5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvZGFncmUvbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvaXNBY3ljbGljLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9wb3N0b3JkZXIuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3ByZW9yZGVyLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9wcmltLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy90YXJqYW4uanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3RvcHNvcnQuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvY29tcG91bmRpZnkuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvY29udmVydGVyL2pzb24uanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvZmlsdGVyLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9kYWdyZS9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2dyYXBoLWNvbnZlcnRlcnMuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2RhZ3JlL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvdXRpbC5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvZGFncmUvbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi92ZXJzaW9uLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9lbnNsYXZlL2luZGV4LmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9oeXBlcmdsdWUvYnJvd3Nlci5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvaHlwZXJnbHVlL25vZGVfbW9kdWxlcy9kb21pZnkvaW5kZXguanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL2xvcmVtLWlwc3VtL2xpYi9kaWN0aW9uYXJ5LmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9sb3JlbS1pcHN1bS9saWIvZ2VuZXJhdG9yLmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9yYW5kb20tbnVtYmVyL2luZGV4LmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L25vZGVfbW9kdWxlcy9yYW5kb20tdG9rZW4vaW5kZXguanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvbm9kZV9tb2R1bGVzL3NuYXBzdmcvZGlzdC9zbmFwLnN2Zy5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvc25hcHN2Zy9ub2RlX21vZHVsZXMvZXZlL2V2ZS5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9ub2RlX21vZHVsZXMvdmlyYWwvdmlyYWwuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvcGF0aHdheS5qcyIsIi9ob21lL2FzaG51ci93b3JrL2RpYWdyYW1zL2NsaWVudC9zZXQuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvdGVzdC90ZXN0LmpzIiwiL2hvbWUvYXNobnVyL3dvcmsvZGlhZ3JhbXMvY2xpZW50L3V0aWwvZGVmYXVsdHMuanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvdXRpbC9kb20uanMiLCIvaG9tZS9hc2hudXIvd29yay9kaWFncmFtcy9jbGllbnQvdXRpbC91bmlxdWVfaWQuanMiLCIvdXNyL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIi91c3IvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnhOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidm9pZCBmdW5jdGlvbigpe1xuICB2YXIgdmlyYWwgPSByZXF1aXJlKCd2aXJhbCcpXG4gIHZhciBlbnNsYXZlID0gcmVxdWlyZSgnZW5zbGF2ZScpXG5cbiAgZnVuY3Rpb24gc2l6ZShhcnIpe1xuICAgIHJldHVybiBhcnIudmFsdWVzLmxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmUoYXJyKXtcbiAgICByZXR1cm4gQXJyLm1ha2UoYXJyKVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yRWFjaChzZXQsIGZuKXtcbiAgICBzZXQudmFsdWVzLmZvckVhY2goZm4pXG4gIH1cblxuICBmdW5jdGlvbiByZWR1Y2Uoc2V0LCBmbiwgaW5pdCl7XG4gICAgaWYgKCBpbml0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICByZXR1cm4gc2V0LnZhbHVlcy5yZWR1Y2UoZm4sIGluaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZXQudmFsdWVzLnJlZHVjZShmbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXAoc2V0LCBmbil7XG4gICAgcmV0dXJuIHNldC52YWx1ZXMubWFwKGZuKVxuICB9XG5cbiAgZnVuY3Rpb24gc29tZShzZXQsIGZuKXtcbiAgICByZXR1cm4gc2V0LnZhbHVlcy5zb21lKGZuKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXhPZihzZXQsIHZhbHVlKXtcbiAgICByZXR1cm4gc2V0LnZhbHVlcy5pbmRleE9mKHZhbHVlKVxuICB9XG5cbiAgdmFyIEFyciA9IHZpcmFsLmV4dGVuZCh7XG4gICAgaW5pdDogZnVuY3Rpb24oYXJyKXtcbiAgICAgIHRoaXMudmFsdWVzID0gYXJyICE9IG51bGwgPyBhcnIudmFsdWVzLnNsaWNlKDApIDogW11cbiAgICB9XG4gICwgZm9yRWFjaDogZW5zbGF2ZShmb3JFYWNoKVxuICAsIHJlZHVjZTogZW5zbGF2ZShyZWR1Y2UpXG4gICwgbWFwOiBlbnNsYXZlKG1hcClcbiAgLCBzb21lOiBlbnNsYXZlKHNvbWUpXG4gICwgc2l6ZTogZW5zbGF2ZShzaXplKVxuICAsIGNsb25lOiBlbnNsYXZlKGNsb25lKVxuICAsIGluZGV4T2Y6IGVuc2xhdmUoaW5kZXhPZilcbiAgfSlcblxuICBtb2R1bGUuZXhwb3J0cyA9IEFyclxuXG59KClcbiIsInZvaWQgZnVuY3Rpb24oKXtcbiAgdmFyIFNuYXAgPSByZXF1aXJlKCdzbmFwc3ZnJylcbiAgdmFyIHZpcmFsID0gcmVxdWlyZSgndmlyYWwnKVxuICB2YXIgZW5zbGF2ZSA9IHJlcXVpcmUoJ2Vuc2xhdmUnKVxuICB2YXIgZGFncmUgPSByZXF1aXJlKCdkYWdyZScpXG4gIHZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxuICB2YXIgaGdsdWUgPSByZXF1aXJlKCdoeXBlcmdsdWUnKVxuICB2YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi91dGlsL2RlZmF1bHRzLmpzJylcbiAgdmFyIHVpZCA9IHJlcXVpcmUoJy4uL3V0aWwvdW5pcXVlX2lkLmpzJylcbiAgdmFyIGRvbSA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tLmpzJylcbiAgdmFyIGludGVyc2VjdCA9IHJlcXVpcmUoJy4vaW50ZXJzZWN0LmpzJylcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vclxuICB2YXIgY2VpbCA9IE1hdGguY2VpbFxuICB2YXIgbWluID0gTWF0aC5taW5cbiAgdmFyIG1heCA9IE1hdGgubWF4XG5cbiAgdmFyIEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0uanMnKVxuICB2YXIgcHJpbnQgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpXG5cbiAgZnVuY3Rpb24gZnJvbV9kZWZzKGRpYWdyYW0sIGNsYXNzbmFtZSl7XG4gICAgcmV0dXJuIGRpYWdyYW0uc3ZnZWwucGFyZW50KCkuc2VsZWN0KCdkZWZzIC4nICsgY2xhc3NuYW1lKVxuICB9XG5cbiAgZnVuY3Rpb24gdG9fZGVmcyhkaWFncmFtLCBzdmcpe1xuICAgIHZhciBwID0gZGlhZ3JhbS5zdmdlbC5wYXJlbnQoKVxuICAgIGlmICggdHlwZW9mIHN2ZyA9PSAnc3RyaW5nJyApIHtcbiAgICAgIHZhciBlbCA9IFNuYXAucGFyc2Uoc3ZnKS5zZWxlY3QoJyonKVxuICAgIH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoc3ZnKSApIHtcbiAgICAgIHZhciBlbCA9IHAuZWwuYXBwbHkocC5lbCwgc3ZnKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiByZXBsYWNlIHRoaXNcbiAgICAgIHByaW50KCdub3Qgc3VyZSBob3cgdG8gaGFuZGxlJylcbiAgICB9XG4gICAgcmV0dXJuIHAuc2VsZWN0KCdkZWZzJykuYXBwZW5kKGVsKVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhdyhkaWFncmFtLCBlbCl7XG4gICAgdmFyIG5ld19lbCA9IGZyb21fZGVmcyhkaWFncmFtLCBlbC5jbGFzc25hbWUpLmNsb25lKClcbiAgICB2YXIgbm9kZSA9IGhnbHVlKG5ld19lbC5ub2RlLCBlbC5jb250ZW50KVxuICAgIGRpYWdyYW0uc3ZnZWwuYXBwZW5kKG5ld19lbClcbiAgICByZXR1cm4gbmV3X2VsXG4gIH1cblxuICBmdW5jdGlvbiBzZXRfbGluZV9hdHRycyhpdGVtLCBsaW5lX2hlaWdodCwgeCl7XG4gICAgaXRlbS5nLnNlbGVjdEFsbCgndHNwYW4nKS5mb3JFYWNoKGZ1bmN0aW9uKHRzcGFuLCBpZHgpe1xuICAgICAgdHNwYW4uYXR0cih7IGR5OiBpZHggPyBsaW5lX2hlaWdodCA6IDAgLCB4OiB4IH0pXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc19jYWxjKHgsdyx5LGgpe1xuICAgIHJldHVybiBbeCArIHcgLyAyLCB5ICsgaCAvIDJdXG4gIH1cblxuICBmdW5jdGlvbiBnZXRfdGV4dHdpZHRoKG5vZGUpe1xuICAgIHJldHVybiBub2RlLmdldENvbXB1dGVkVGV4dExlbmd0aCgpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZpel9iYm94KGRpYWdyYW0sIGVsKXtcbiAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZSgpLmF0dHIoKVxuICAgIGRpYWdyYW0uc3ZnZWwuYXBwZW5kKGNsb25lKVxuICAgIHZhciBiYm94ID0gY2xvbmUuZ2V0QkJveCgpXG4gICAgY2xvbmUucmVtb3ZlKClcbiAgICByZXR1cm4gYmJveFxuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnRfdG9fc3RyaW5nKHApeyByZXR1cm4gcC54ICsgJywnICsgcC55IH1cblxuICBmdW5jdGlvbiBob3Jpem9udGFsKGxpbmUpe1xuICAgIHJldHVybiBsaW5lLmdldEF0dHJpYnV0ZSgneDEnKSA9PSBsaW5lLmdldEF0dHJpYnV0ZSgneDInKVxuICB9XG5cblxuICBmdW5jdGlvbiBkaXNwbGF5KGRpYWdyYW0pe1xuICAgIC8vIGFwcGx5IGhlaWdodCAvIHdpZHRoIG9uIG5vZGVzXG4gICAgdmFyIGluZ3JhcGggPSBkaWFncmFtLmluZ3JhcGhcbiAgICB2YXIgYmJveF9jYWNoZSA9IHt9XG4gICAgaW5ncmFwaC5lYWNoTm9kZShmdW5jdGlvbihpZCwgbm9kZSl7XG4gICAgICB2YXIgY2xhc3NuYW1lID0gbm9kZS5jbGFzc25hbWVcbiAgICAgIHZhciBiYm94ID0gYmJveF9jYWNoZVtjbGFzc25hbWVdIHx8IChiYm94X2NhY2hlW2NsYXNzbmFtZV0gPSBpbnZpel9iYm94KGRpYWdyYW0sIGZyb21fZGVmcyhkaWFncmFtLCBjbGFzc25hbWUpKSlcbiAgICAgIG5vZGUuYXR0cigneCcsIGJib3gueClcbiAgICAgIG5vZGUuYXR0cigneScsIGJib3gueSlcbiAgICAgIG5vZGUuYXR0cignd2lkdGgnLCBiYm94LndpZHRoKVxuICAgICAgbm9kZS5hdHRyKCdoZWlnaHQnLCBiYm94LmhlaWdodClcbiAgICB9KVxuXG4gICAgdmFyIGxheW91dCA9IGRpYWdyYW0ubGF5b3V0XG4gICAgdmFyIGdjZmcgPSBkaWFncmFtLmdyYXBoLmNvbmZpZ1xuICAgIGlmICggZ2NmZyApIHtcbiAgICAgIE9iamVjdC5rZXlzKGdjZmcpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKXtcbiAgICAgICAgbGF5b3V0ID0gbGF5b3V0W21ldGhvZF0oZ2NmZ1ttZXRob2RdKVxuICAgICAgfSlcbiAgICB9XG4gICAgbGF5b3V0LnJhbmtTaW1wbGV4ID0gdHJ1ZVxuICAgIC8vIGNhbGN1bGF0ZSBub2RlcyBsYXlvdXRcbiAgICBsYXlvdXQgPSBsYXlvdXQucnVuKGluZ3JhcGgpXG5cbiAgICB2YXIgZ3JhcGggPSBkaWFncmFtLm91dGdyYXBoID0gbGF5b3V0LmdyYXBoKClcblxuICAgIC8vIGRpc3BsYXkgbm9kZXNcbiAgICBsYXlvdXQuZWFjaE5vZGUoZnVuY3Rpb24oaWQsIHZhbHVlcyl7XG4gICAgICB2YXIgbm9kZSA9IGRpYWdyYW0uaW5ncmFwaC5ub2RlKGlkKVxuICAgICAgbm9kZS50cmFuc2Zvcm0odmFsdWVzKVxuICAgICAgZHJhdyhkaWFncmFtLCBub2RlKVxuICAgIH0pXG5cblxuICAgIC8vIGNhbGN1bGF0ZSBlZGdlcyBsYXlvdXRcbiAgICB2YXIgbGFuZXMgPSByZXF1aXJlKCcuL2VkZ2VzLmpzJykobGF5b3V0LCBkaWFncmFtKVxuICAgIHZhciBzZWdtZW50cyA9IFtdXG5cbiAgICB2YXIgZHJhd19ib3VuZCA9IGRyYXcuYmluZChudWxsLCBkaWFncmFtKVxuXG4gICAgbGFuZXMuZm9yRWFjaChmdW5jdGlvbihsYW5lKXtcbiAgICAgIGxhbmUuZm9yRWFjaChmdW5jdGlvbihwdyl7XG4gICAgICAgIHZhciBzdGFydCA9IHB3WzBdXG4gICAgICAgIHZhciBlbmQgPSBwd1twdy5sZW5ndGggLSAxXVxuICAgICAgICAvLyBkcmF3IHBhdGhcbiAgICAgICAgdmFyIHBhdGhfc2VnbWVudCA9IHtpZDogdWlkKCksIHgxOiBzdGFydC54LCB5MTpzdGFydC55LCB4MjogZW5kLngsIHkyOiBlbmQueX1cbiAgICAgICAgZHJhd19ib3VuZCh7XG4gICAgICAgICAgY2xhc3NuYW1lOiBkaWFncmFtLmNvbmZpZy5lZGdlQ2xhc3NcbiAgICAgICAgLCBjb250ZW50OiB7Jy5FZGdlOmZpcnN0JzogcGF0aF9zZWdtZW50fVxuICAgICAgICB9KVxuICAgICAgICBzZWdtZW50cy5wdXNoKHBhdGhfc2VnbWVudClcblxuICAgICAgICAvLyBkcmF3IHRoZSBqdW5jdGlvbnNcbiAgICAgICAgdmFyIGp1bmN0aW9ucyA9IHB3LmZpbHRlcihmdW5jdGlvbihwKXtyZXR1cm4gcC5ub2RlICYmICEgcC5lbnRyeSB9KVxuICAgICAgICBkcmF3X2JvdW5kKHtcbiAgICAgICAgICBjbGFzc25hbWU6IGRpYWdyYW0uY29uZmlnLmVkZ2VDbGFzc1xuICAgICAgICAsIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICcuRWRnZSc6IGp1bmN0aW9ucy5tYXAoZnVuY3Rpb24ocCl7XG4gICAgICAgICAgICAgIHZhciBqX3NlZ21lbnQgPSB7aWQ6IHVpZCgpLCB4MTogcC54LCB5MTpwLnksIHgyOiBwLm5vZGUueCwgeTI6IHAubm9kZS55fVxuICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKGpfc2VnbWVudClcbiAgICAgICAgICAgICAgcmV0dXJuIHsgJzpmaXJzdCc6IGpfc2VnbWVudH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHZhciBlbnRyaWVzID0gcHcuZmlsdGVyKGZ1bmN0aW9uKHApe3JldHVybiAhISBwLmVudHJ5IH0pXG4gICAgICAgIGRyYXdfYm91bmQoe1xuICAgICAgICAgIGNsYXNzbmFtZTogZGlhZ3JhbS5jb25maWcuZWRnZUVuZENsYXNzXG4gICAgICAgICwgY29udGVudDoge1xuICAgICAgICAgICAgJy5FZGdlJzogZW50cmllcy5tYXAoZnVuY3Rpb24ocCl7XG4gICAgICAgICAgICAgIHZhciBqX3NlZ21lbnQgPSB7aWQ6IHVpZCgpLCB4MTogcC54LCB5MTpwLnksIHgyOiBwLmN1dC54LCB5MjogcC5jdXQueX1cbiAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChqX3NlZ21lbnQpXG4gICAgICAgICAgICAgIHJldHVybiB7JzpmaXJzdCc6IGpfc2VnbWVudH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgLCAnLkVkZ2UtLWVuZCc6IGVudHJpZXMubWFwKGZ1bmN0aW9uKHApe1xuICAgICAgICAgICAgICB2YXIgal9zZWdtZW50ID0ge2lkOiB1aWQoKSwgeDE6IHAuY3V0LngsIHkxOnAuY3V0LnksIHgyOiBwLm5vZGUueCwgeTI6IHAubm9kZS55fVxuICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKGpfc2VnbWVudClcbiAgICAgICAgICAgICAgcmV0dXJuIHsnOmZpcnN0Jzogal9zZWdtZW50fVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIGRyYXcgdGhlIHNraXBzXG4gICAgZHJhd19ib3VuZCh7XG4gICAgICBjbGFzc25hbWU6IGRpYWdyYW0uY29uZmlnLmVkZ2VDbGFzc1xuICAgICwgY29udGVudDogeycuRWRnZSc6IGxhbmVzLnNraXBzLm1hcChmdW5jdGlvbihwKXtcbiAgICAgICAgdmFyIHNraXBfc2VnbWVudCA9IHtpZDogdWlkKCksIHgxOiBwWzBdLngsIHkxOnBbMF0ueSwgeDI6IHBbMV0ueCwgeTI6IHBbMV0ueX1cbiAgICAgICAgc2VnbWVudHMucHVzaChza2lwX3NlZ21lbnQpXG4gICAgICAgIHJldHVybiB7ICc6Zmlyc3QnOiBza2lwX3NlZ21lbnQgfVxuICAgICAgfSl9XG4gICAgfSlcblxuICAgIHZhciBpbnRlcnNlY3Rpb25fc2l6ZSA9IGludml6X2Jib3goZGlhZ3JhbSwgZnJvbV9kZWZzKGRpYWdyYW0sIGRpYWdyYW0uY29uZmlnLmludGVyc2VjdGlvbkNsYXNzKSlcbiAgICB2YXIgaW50ZXJzZWN0aW9uX21pZGRsZSA9IFtpbnRlcnNlY3Rpb25fc2l6ZS53aWR0aCAvIDIsIGludGVyc2VjdGlvbl9zaXplLmhlaWdodCAvIDJdXG4gICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWcxLCBpZDEpe1xuICAgICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWcyLCBpZDIpe1xuICAgICAgICBpZiAoIGlkMiA+IGlkMSAmJiBzZWcxLngxICE9IHNlZzIueDEgJiYgIHNlZzEueDIgIT0gc2VnMi54MiAmJiBzZWcxLnkxICE9IHNlZzIueTEgJiYgIHNlZzEueTIgIT0gc2VnMi55MiApIHtcbiAgICAgICAgICB2YXIgaXNjdCA9IGludGVyc2VjdChzZWcxLCBzZWcyKVxuICAgICAgICAgIGlmICggaXNjdCApIHtcbiAgICAgICAgICAgIHZhciBzZWcxbm9kZSA9IGRvbS4kaWQoc2VnMS5pZClcbiAgICAgICAgICAgIHZhciBzZWcybm9kZSA9IGRvbS4kaWQoc2VnMi5pZClcbiAgICAgICAgICAgIHZhciB0b3Bub2RlID0gc2VnMW5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oc2VnMm5vZGUpICYgNCA/IHNlZzFub2RlIDogc2VnMm5vZGVcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rfbm9kZSA9IGRyYXcoZGlhZ3JhbSwgeyBjbGFzc25hbWU6IGRpYWdyYW0uY29uZmlnLmludGVyc2VjdGlvbkNsYXNzICwgY29udGVudDoge30gfSlcbiAgICAgICAgICAgIGlmICggaG9yaXpvbnRhbCh0b3Bub2RlKSApIHtcbiAgICAgICAgICAgICAgaW50ZXJzZWN0X25vZGUudHJhbnNmb3JtKChuZXcgU25hcC5NYXRyaXgoMSwgMCwgMCwgMSwgMCAsIDApKS5yb3RhdGUoOTAsIGlzY3RbMF0gLCBpc2N0WzFdICkudG9UcmFuc2Zvcm1TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNmb3JtKGludGVyc2VjdF9ub2RlLm1hdHJpeC50cmFuc2xhdGUoaXNjdFswXSAtIGludGVyc2VjdGlvbl9taWRkbGVbMF0sIGlzY3RbMV0gLSBpbnRlcnNlY3Rpb25fbWlkZGxlWzFdKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGludGVyc2VjdF9ub2RlLnRyYW5zZm9ybShuZXcgU25hcC5NYXRyaXgoMSwgMCwgMCwgMSwgaXNjdFswXSAtIGludGVyc2VjdGlvbl9taWRkbGVbMF0sIGlzY3RbMV0gLSBpbnRlcnNlY3Rpb25fbWlkZGxlWzFdKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9tLmluc2VydEFmdGVyKHRvcG5vZGUucGFyZW50Tm9kZSwgaW50ZXJzZWN0X25vZGUubm9kZSwgdG9wbm9kZS5uZXh0U2libGluZylcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdmFyIG1vdmUgPSBkaWFncmFtLnN2Z2VsLm1hdHJpeC5jbG9uZSgpXG4gICAgaWYgKCBncmFwaC5yYW5rRGlyID09IFwiTFJcIiB8fCBncmFwaC5yYW5rRGlyID09IFwiUkxcIiApIHtcbiAgICAgIGdyYXBoLmhlaWdodCA9IGdyYXBoLmhlaWdodCArIGxhbmVzLmdyb3d0aCAqIDJcbiAgICAgIHZhciBtb3ZlID0gbW92ZS50cmFuc2xhdGUoMCwgbGFuZXMuZ3Jvd3RoKVxuICAgIH0gZWxzZSB7XG4gICAgICBncmFwaC53aWR0aCA9IGdyYXBoLndpZHRoICsgbGFuZXMuZ3Jvd3RoICogMlxuICAgICAgdmFyIG1vdmUgPSBtb3ZlLnRyYW5zbGF0ZShsYW5lcy5ncm93dGgsIDApXG4gICAgfVxuXG4gICAgZGlhZ3JhbS5zdmdlbC5hdHRyKHsgd2lkdGg6IGdyYXBoLndpZHRoLCBoZWlnaHQ6IGdyYXBoLmhlaWdodCB9KS50cmFuc2Zvcm0obW92ZS50b1RyYW5zZm9ybVN0cmluZygpKVxuICAgIGRpYWdyYW0uc3ZnZWwucGFyZW50KCkuYXR0cih7IHdpZHRoOiBncmFwaC53aWR0aCArIGRpYWdyYW0uY29uZmlnLmVkZ2VXaWR0aCArIGRpYWdyYW0uY29uZmlnLnBhZGRpbmcsIGhlaWdodDogZ3JhcGguaGVpZ2h0ICsgZGlhZ3JhbS5jb25maWcuZWRnZVdpZHRoICsgZGlhZ3JhbS5jb25maWcucGFkZGluZyB9KVxuICAgIHJldHVybiBsYXlvdXRcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gdmlyYWwuZXh0ZW5kKG5ldyBldmVudHMuRXZlbnRFbWl0dGVyKS5leHRlbmQoe1xuICAgIGluaXQ6IGZ1bmN0aW9uKGNvbmZpZywgZ3JhcGgpe1xuICAgICAgdGhpcy5jb25maWcgPSBjb25maWdcbiAgICAgIHRoaXMuaXRlbXMgPSB7fVxuICAgICAgdGhpcy5jb25uZWN0b3JzID0ge31cbiAgICAgIHRoaXMuZ3JhcGggPSBncmFwaFxuICAgICAgdGhpcy5pbmdyYXBoID0gZ3JhcGguaW5ncmFwaFxuICAgICAgdGhpcy5sYXlvdXQgPSBkYWdyZS5sYXlvdXQoKVxuICAgICAgdGhpcy5zdmdlbCA9IFNuYXAuYXBwbHkoU25hcCwgY29uZmlnLnNuYXBfYXJncykuZygpLmF0dHIoeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKDIwLDIwKVwiLCBpZDp1aWQoKX0pXG4gICAgfVxuICAsIGRpc3BsYXk6IGVuc2xhdmUoZGlzcGxheSlcbiAgLCBkcmF3OiBlbnNsYXZlKGRyYXcpXG4gICwgdG9fZGVmczogZW5zbGF2ZSh0b19kZWZzKVxuXG4vLyAgLCBhZGRJdGVtOiBlbnNsYXZlKGFkZF9pdGVtKVxuLy8gICwgZGVsSXRlbTogZW5zbGF2ZShyZW1vdmVfaXRlbSlcbi8vXG4vLyAgLCBjb25uZWN0OiBlbnNsYXZlKGFkZF9jb25uZWN0b3IpXG4vLyAgLCBkaXNjb25uZWN0OiBlbnNsYXZlKHJlbW92ZV9jb25uZWN0b3IpXG4vL1xuLy9cbi8vICAsIHNlbGVjdEl0ZW1zOiBlbnNsYXZlKGZpbHRlcl9pdGVtcylcbi8vICAsIHNlbGVjdENvbm5lY3RvcnM6IGVuc2xhdmUoZmlsdGVyX2l0ZW1zKVxuXG4gIH0pXG59KClcbiIsInZvaWQgZnVuY3Rpb24oKXtcblxuICB2YXIgU2V0ID0gcmVxdWlyZSgnLi4vc2V0LmpzJylcbiAgdmFyIFBhdGh3YXlzID0gcmVxdWlyZSgnLi4vcGF0aHdheS5qcycpXG5cbiAgdmFyIHRyYW5zbGF0ZSA9IHJlcXVpcmUoJy4vdHJhbnNsYXRlLmpzJylcbiAgdmFyIFYgPSByZXF1aXJlKCcuL3ZlY3RvcnMuanMnKVxuXG4gIGZ1bmN0aW9uIHBvaW50KHgsIHkpe1xuICAgIHJldHVybiB7IHg6IHggfHwgMCwgeTogeSB8fCAwIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZGVfZnJvbV9kaXJlY3Rpb24obm9kZSwgZCl7XG4gICAgdmFyIGMgPSBwb2ludChub2RlLngsIG5vZGUueSlcbiAgICB2YXIgdyA9IG5vZGUud2lkdGggLyAyXG4gICAgdmFyIGggPSBub2RlLmhlaWdodCAvIDJcbiAgICB2YXIgdGwgPSB0cmFuc2xhdGUoWy13LCAtaF0sIGMpXG4gICAgdmFyIHRyID0gdHJhbnNsYXRlKFt3LCAtaF0sIGMpXG4gICAgdmFyIGJsID0gdHJhbnNsYXRlKFstdywgaF0sIGMpXG4gICAgdmFyIGJyID0gdHJhbnNsYXRlKFt3LCBoXSwgYylcbiAgICBzd2l0Y2ggKCBkICkge1xuICAgICAgY2FzZSAnTCcgOlxuICAgICAgICByZXR1cm4gW3RsLCBibF1cbiAgICAgIGNhc2UgJ1InIDpcbiAgICAgICAgcmV0dXJuIFt0ciwgYnJdXG4gICAgICBjYXNlICdCJyA6XG4gICAgICAgIHJldHVybiBbYmwsIGJyXVxuICAgICAgY2FzZSAnVCcgOlxuICAgICAgICByZXR1cm4gW3RsLCB0cl1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXZpZGVfc2lkZShzaWRlLCBuKXtcbiAgICB2YXIgWDEgPSBzaWRlWzBdLnhcbiAgICB2YXIgWTEgPSBzaWRlWzBdLnlcbiAgICB2YXIgWDIgPSBzaWRlWzFdLnhcbiAgICB2YXIgWTIgPSBzaWRlWzFdLnlcblxuICAgIHZhciBXID0gWDIgLSBYMVxuICAgIHZhciBIID0gWTIgLSBZMVxuICAgIHZhciBwb2ludHMgPSBbXVxuICAgIHZhciBydyA9IFcgLyBuXG4gICAgdmFyIHJoID0gSCAvIG5cbiAgICB3aGlsZSAoIC0tbiA+IDAgKSB7XG4gICAgICBwb2ludHMucHVzaCh0cmFuc2xhdGUoWyBuICogcncsIG4gKiByaCBdLCBzaWRlWzBdKSlcbiAgICB9XG4gICAgcG9pbnRzLnJldmVyc2UoKVxuICAgIHJldHVybiBwb2ludHNcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldF9yYW5rX2RpbShtYXJnaW4sIGtleSwgbm9kZSl7XG4gICAgcmV0dXJuIE1hdGguY2VpbChub2RlW2tleV0gLyBtYXJnaW4pICogbWFyZ2luXG4gIH1cblxuICBmdW5jdGlvbiBudW1fY29tcChhLCBiKXtcbiAgICByZXR1cm4gYSA+IGIgPyAgMVxuICAgICAgICAgOiBhIDwgYiA/IC0xXG4gICAgICAgICA6ICAgICAgICAgIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvcnRfbm9kZXNfaW5fcmFuayhkaXIsIGEsIGIpe1xuICAgIHN3aXRjaCAoIGRpciApIHtcbiAgICAgIGNhc2UgJ1RCJzpcbiAgICAgICAgcmV0dXJuIGEueCA8IGIueCA/IC0xXG4gICAgICAgICAgICAgOiBhLnggPiBiLnggPyAgMVxuICAgICAgICAgICAgIDogICAgICAgICAgICAgIDBcbiAgICAgIGNhc2UgJ0JUJzpcbiAgICAgICAgcmV0dXJuIGEueCA+IGIueCA/IC0xXG4gICAgICAgICAgICAgOiBhLnggPCBiLnggPyAgMVxuICAgICAgICAgICAgIDogICAgICAgICAgICAgIDBcbiAgICAgIGNhc2UgJ0xSJzpcbiAgICAgICAgcmV0dXJuIGEueSA8IGIueSA/IC0xXG4gICAgICAgICAgICAgOiBhLnkgPiBiLnkgPyAgMVxuICAgICAgICAgICAgIDogICAgICAgICAgICAgIDBcbiAgICAgIGNhc2UgJ1JMJzpcbiAgICAgICAgcmV0dXJuIGEueSA+IGIueSA/IC0xXG4gICAgICAgICAgICAgOiBhLnkgPCBiLnkgPyAgMVxuICAgICAgICAgICAgIDogICAgICAgICAgICAgIDBcbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvdW50X2V4aXRzKHBhdGh3YXlzLCBzb3VyY2VfaWQpe1xuICAgIHZhciBjb3VudCA9IDAsIGZpbmRzID0gW11cblxuICAgIHBhdGh3YXlzLmZvckVhY2goZnVuY3Rpb24ocCwgcGkpe1xuICAgICAgcC5mb3JFYWNoKGZ1bmN0aW9uKHcsIHdpKXtcbiAgICAgICAgaWYgKCB3LnNvdXJjZXMuaGFzKHNvdXJjZV9pZCkgKSB7XG4gICAgICAgICAgZmluZHMucHVzaChbcGksIHdpLCB3XSlcbiAgICAgICAgICBjb3VudCsrXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICByZXR1cm4gY291bnRcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3V0Z3JhcGgsIGRpYWdyYW0pe1xuICAgIHZhciBnID0gb3V0Z3JhcGguZ3JhcGgoKVxuICAgIHZhciByYW5rRGlyID0gZy5yYW5rRGlyXG4gICAgdmFyIHZlcnRpY2FsID0gcmFua0RpciA9PSAnVEInIHx8IHJhbmtEaXIgPT0gJ0JUJ1xuICAgIHZhciByZXZlcnNlZCA9IHJhbmtEaXIgPT0gJ0JUJyB8fCByYW5rRGlyID09ICdSTCdcbiAgICB2YXIgcmFua1NlcCA9IGRpYWdyYW0uZ3JhcGguY29uZmlnLnJhbmtTZXBcbiAgICB2YXIgcmFua19zb3J0ZXIgPSBzb3J0X25vZGVzX2luX3JhbmsuYmluZChudWxsLCByYW5rRGlyKVxuICAgIHZhciBsZXZlbF9kaXIgPSB2ZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J1xuICAgIHZhciByYW5rc19wb3NpdGlvbnMgPSBbXVxuICAgIHZhciByYW5rcyA9IFtdXG4gICAgdmFyIG5vcm1fcmFua19kaW0gPSBnZXRfcmFua19kaW0uYmluZChudWxsLCBkaWFncmFtLmNvbmZpZy5yYW5rX2RldGVjdGlvbl9lcnJvcl9tYXJnaW4sIHZlcnRpY2FsID8gJ3knIDogJ3gnIClcblxuICAgIGZ1bmN0aW9uIGdldF9qdW5jdGlvbihwYXRoLCBsZXZlbCl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB2ZXJ0aWNhbCA/IGxldmVsIDogcGF0aFxuICAgICAgLCB5OiB2ZXJ0aWNhbCA/IHBhdGggOiBsZXZlbFxuICAgICAgfVxuICAgIH1cblxuICAgIG91dGdyYXBoLmVhY2hOb2RlKGZ1bmN0aW9uKGlkLCBub2RlKXtcbiAgICAgIHZhciByZGltID0gbm9ybV9yYW5rX2RpbShub2RlKVxuICAgICAgaWYgKCByYW5rc19wb3NpdGlvbnMuaW5kZXhPZihyZGltKSA9PSAtMSApIHtcbiAgICAgICAgcmFua3NfcG9zaXRpb25zLnB1c2gocmRpbSlcbiAgICAgICAgcmFua3NfcG9zaXRpb25zLnNvcnQobnVtX2NvbXApXG4gICAgICB9XG4gICAgICBub2RlLnJkaW0gPSByZGltXG4gICAgfSlcbiAgICBpZiAoIHJldmVyc2VkICkge1xuICAgICAgcmFua3NfcG9zaXRpb25zLnJldmVyc2UoKVxuICAgIH1cbiAgICBvdXRncmFwaC5lYWNoTm9kZShmdW5jdGlvbihpZCwgbm9kZSl7XG4gICAgICB2YXIgciA9IHJhbmtzX3Bvc2l0aW9ucy5pbmRleE9mKG5vZGUucmRpbSlcbiAgICAgIG5vZGUudHJ1ZV9yYW5rID0gclxuICAgICAgaWYgKCByYW5rc1tyXSA9PSBudWxsICkgcmFua3Nbcl0gPSBbXVxuICAgICAgcmFua3Nbcl0ucHVzaChub2RlKVxuICAgIH0pXG5cbiAgICByYW5rcy5mb3JFYWNoKGZ1bmN0aW9uKHIsIGkpe1xuICAgICAgcmFua3NbaV0uc29ydChyYW5rX3NvcnRlcilcbiAgICB9KVxuXG4gICAgdmFyIGVkZ2VzX2luX3JhbmtzID0gW11cbiAgICB2YXIgcGF0aHdheV9jb3VudCA9IHJhbmtzLmxlbmd0aCArIDFcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXRod2F5X2NvdW50OyBpKysgKSB7XG4gICAgICBlZGdlc19pbl9yYW5rc1tpXSA9IFNldC5tYWtlKClcbiAgICB9XG5cbiAgICBvdXRncmFwaC5lYWNoTm9kZShmdW5jdGlvbihpZCwgbm9kZSl7XG5cbiAgICAgIHZhciBub2RlX3JhbmsgPSBub2RlLnRydWVfcmFua1xuICAgICAgb3V0Z3JhcGgub3V0RWRnZXMoaWQpLmZvckVhY2goZnVuY3Rpb24ob3V0X2VkZ2VfaWQpe1xuICAgICAgICBlZGdlc19pbl9yYW5rc1tub2RlX3JhbmsgKyAxXS5hZGQob3V0X2VkZ2VfaWQpXG4gICAgICB9KVxuXG4gICAgfSlcblxuICAgIHZhciBsYW5lcyA9IFtdXG4gICAgZWRnZXNfaW5fcmFua3MuZm9yRWFjaChmdW5jdGlvbihyYW5rLCBpZHgpe1xuICAgICAgbGFuZXNbaWR4XSA9IFBhdGh3YXlzLm1ha2UoKVxuICAgICAgcmFuay5mb3JFYWNoKGZ1bmN0aW9uKGVkZ2VfaWQpe1xuICAgICAgICBsYW5lc1tpZHhdLmFkZCggb3V0Z3JhcGguc291cmNlKGVkZ2VfaWQpXG4gICAgICAgICAgICAgICAgICAgICwgZWRnZV9pZFxuICAgICAgICAgICAgICAgICAgICAsIG91dGdyYXBoLnRhcmdldChlZGdlX2lkKSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIG91dGdyYXBoLmVhY2hOb2RlKGZ1bmN0aW9uKGlkLCBub2RlKXtcbiAgICAgIHZhciBleGl0cyA9IGRpdmlkZV9zaWRlKHNpZGVfZnJvbV9kaXJlY3Rpb24obm9kZSwgcmFua0RpclsxXSksIGNvdW50X2V4aXRzKGxhbmVzLCBpZCkgKyAxKVxuICAgICAgbm9kZS5leGl0cyA9IGV4aXRzXG4gICAgICBub2RlLmVudHJpZXMgPSBkaXZpZGVfc2lkZShzaWRlX2Zyb21fZGlyZWN0aW9uKG5vZGUsIHJhbmtEaXJbMF0pLCAyKVxuICAgIH0pXG5cbiAgICB2YXIgZnNraXBzID0gW11cbiAgICB2YXIgYnNraXBzID0gW11cbiAgICB2YXIgZWRnZXMgPSBbXVxuICAgIHZhciBza2lwc2VwID0gZGlhZ3JhbS5jb25maWcuZWRnZVdpZHRoXG4gICAgbGFuZXMuZm9yRWFjaChmdW5jdGlvbihsYW5lLCByYW5rX25yKXtcbiAgICAgIHZhciBwd3MgID0gW11cbiAgICAgIHZhciBwYXRod2F5c19jb3VudCA9IGxhbmUuc2l6ZSgpXG4gICAgICB2YXIgcHNlcCA9IHJhbmtTZXAgLyAocGF0aHdheXNfY291bnQgKyAxKVxuICAgICAgbGFuZS5mb3JFYWNoKGZ1bmN0aW9uKHBhdGh3YXksIHB3X2lkeCl7XG4gICAgICAgIHZhciB0ciA9IHBzZXAgKiAocHdfaWR4ICsgMSlcbiAgICAgICAgaWYgKCByZXZlcnNlZCApIHRyICA9IHRyICogLTFcbiAgICAgICAgdmFyIHRyX2V4aXQgPSB0cmFuc2xhdGUuYmluZChudWxsLCB2ZXJ0aWNhbCA/IFswLCB0cl0gOiBbdHIsIDBdKVxuICAgICAgICB2YXIgdHJfZW50cnkgPSB0cmFuc2xhdGUuYmluZChudWxsLCB2ZXJ0aWNhbCA/IFswLCB0ciAtIChyZXZlcnNlZCA/IC0xICogcmFua1NlcCA6IHJhbmtTZXApXSA6IFt0ciAtIChyZXZlcnNlZCA/IC0xICogcmFua1NlcCA6IHJhbmtTZXApLCAwXSlcbiAgICAgICAgdmFyIHB3ID0gW11cbiAgICAgICAgcGF0aHdheS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc291cmNlX2lkKXtcbiAgICAgICAgICB2YXIgc291cmNlID0gb3V0Z3JhcGgubm9kZShzb3VyY2VfaWQpXG4gICAgICAgICAgaWYgKCBzb3VyY2UudHJ1ZV9yYW5rID09IHJhbmtfbnIgLSAxICkge1xuICAgICAgICAgICAgc291cmNlLnNwd2kgPSBwd19pZHhcbiAgICAgICAgICAgIHZhciBqdW5jdGlvbnMgPSBzb3VyY2UuZXhpdHMubWFwKGZ1bmN0aW9uKGV4aXQsIGlkeCl7XG4gICAgICAgICAgICAgIHZhciBwID0gdHJfZXhpdChleGl0KVxuICAgICAgICAgICAgICBwLm5vZGUgPSBleGl0XG4gICAgICAgICAgICAgIHNvdXJjZS5leGl0c1tpZHhdLmp1bmN0aW9uID0gcFxuICAgICAgICAgICAgICByZXR1cm4gcFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHB3ID0gcHcuY29uY2F0KGp1bmN0aW9ucylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHBhdGh3YXkudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHRhcmdldF9pZCl7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IG91dGdyYXBoLm5vZGUodGFyZ2V0X2lkKVxuICAgICAgICAgIGlmICggdGFyZ2V0LnRydWVfcmFuayA9PSByYW5rX25yICkge1xuICAgICAgICAgICAgdGFyZ2V0LnRwd2kgPSBwd19pZHhcbiAgICAgICAgICAgIHZhciBqdW5jdGlvbnMgPSB0YXJnZXQuZW50cmllcy5tYXAoZnVuY3Rpb24oZW50cnksIGlkeCl7XG4gICAgICAgICAgICAgIHZhciBwID0gdHJfZW50cnkoZW50cnkpXG4gICAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBbZW50cnkueCAtIHAueCwgZW50cnkueSAtIHAueV1cbiAgICAgICAgICAgICAgdmFyIHMgPSBWLnNjYWxlKHZlY3RvciwgLTEuMiAqIGRpYWdyYW0uY29uZmlnLmVkZ2VXaWR0aCAvIFYubWFnbml0dWRlKHZlY3RvcikpXG4gICAgICAgICAgICAgIHAuY3V0ID0gdHJhbnNsYXRlKHMsIGVudHJ5KVxuICAgICAgICAgICAgICBwLm5vZGUgPSBlbnRyeVxuICAgICAgICAgICAgICBwLmVudHJ5ID0gdHJ1ZVxuICAgICAgICAgICAgICB0YXJnZXQuZW50cmllc1tpZHhdLmp1bmN0aW9uID0gcFxuICAgICAgICAgICAgICByZXR1cm4gcFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHB3ID0gcHcuY29uY2F0KGp1bmN0aW9ucylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHB3c1twd19pZHhdID0gcHdcbiAgICAgIH0pXG4gICAgICBlZGdlc1tyYW5rX25yXSA9IHB3c1xuICAgIH0pXG5cbiAgICBlZGdlcy5za2lwcyA9IFtdXG4gICAgbGFuZXMuZm9yRWFjaChmdW5jdGlvbihsYW5lLCByYW5rX25yKXtcbiAgICAgIGxhbmUuZm9yRWFjaChmdW5jdGlvbihwYXRod2F5LCBwd19pZHgpe1xuICAgICAgICBwYXRod2F5LmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZV9pZCl7XG4gICAgICAgICAgdmFyIHRpZCA9IG91dGdyYXBoLnRhcmdldChlZGdlX2lkKVxuICAgICAgICAgIHZhciB0YXJnZXQgPSBvdXRncmFwaC5ub2RlKHRpZClcbiAgICAgICAgICB2YXIgdGFyZ2V0X3JhbmsgPSB0YXJnZXQudHJ1ZV9yYW5rXG4gICAgICAgICAgdmFyIHNpZCA9IG91dGdyYXBoLnNvdXJjZShlZGdlX2lkKVxuICAgICAgICAgIHZhciBzb3VyY2UgPSBvdXRncmFwaC5ub2RlKHNpZClcbiAgICAgICAgICB2YXIgc291cmNlX3JhbmsgPSBzb3VyY2UudHJ1ZV9yYW5rXG4gICAgICAgICAgdmFyIHJkID0gdGFyZ2V0X3JhbmsgLSBzb3VyY2VfcmFua1xuICAgICAgICAgIGlmICggcmQgPiAxICYmIGZza2lwcy5pbmRleE9mKHBhdGh3YXkpID09IC0xICkge1xuICAgICAgICAgICAgZnNraXBzLnB1c2gocGF0aHdheSlcbiAgICAgICAgICAgIHZhciBsZXZlbF9hbW91bnQgPSBmc2tpcHMubGVuZ3RoICogc2tpcHNlcFxuICAgICAgICAgICAgdmFyIGxldmVsID0gcmV2ZXJzZWQgPyAwIC0gbGV2ZWxfYW1vdW50IDogZ1tsZXZlbF9kaXJdICsgbGV2ZWxfYW1vdW50XG4gICAgICAgICAgICB2YXIgc291cmNlX2p1bmN0aW9uID0gZ2V0X2p1bmN0aW9uKHNvdXJjZS5leGl0c1swXS5qdW5jdGlvblt2ZXJ0aWNhbCA/ICd5JyA6ICd4J10sIGxldmVsIClcbiAgICAgICAgICAgIGVkZ2VzW3NvdXJjZS50cnVlX3JhbmsgKyAxXVtzb3VyY2Uuc3B3aV0ucHVzaChzb3VyY2VfanVuY3Rpb24pXG4gICAgICAgICAgICB2YXIgdGFyZ2V0X2p1bmN0aW9uID0gZ2V0X2p1bmN0aW9uKHRhcmdldC5lbnRyaWVzWzBdLmp1bmN0aW9uW3ZlcnRpY2FsID8gJ3knIDogJ3gnXSwgbGV2ZWwgKVxuICAgICAgICAgICAgZWRnZXNbdGFyZ2V0LnRydWVfcmFua11bdGFyZ2V0LnRwd2ldLnB1c2godGFyZ2V0X2p1bmN0aW9uKVxuICAgICAgICAgICAgZWRnZXMuc2tpcHMucHVzaChbc291cmNlX2p1bmN0aW9uLCB0YXJnZXRfanVuY3Rpb25dKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIHJkIDwgMCAmJiBic2tpcHMuaW5kZXhPZihwYXRod2F5KSA9PSAtMSApIHtcbiAgICAgICAgICAgIGJza2lwcy5wdXNoKHBhdGh3YXkpXG4gICAgICAgICAgICB2YXIgbGV2ZWxfYW1vdW50ID0gYnNraXBzLmxlbmd0aCAqIHNraXBzZXBcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHJldmVyc2VkID8gZ1tsZXZlbF9kaXJdICsgbGV2ZWxfYW1vdW50IDogMCAtIGxldmVsX2Ftb3VudFxuICAgICAgICAgICAgdmFyIHNvdXJjZV9qdW5jdGlvbiA9IGdldF9qdW5jdGlvbihzb3VyY2UuZXhpdHNbMF0uanVuY3Rpb25bdmVydGljYWwgPyAneScgOiAneCddLCBsZXZlbCApXG4gICAgICAgICAgICBlZGdlc1tzb3VyY2UudHJ1ZV9yYW5rICsgMV1bc291cmNlLnNwd2ldLnB1c2goc291cmNlX2p1bmN0aW9uKVxuICAgICAgICAgICAgdmFyIHRhcmdldF9qdW5jdGlvbiA9IGdldF9qdW5jdGlvbih0YXJnZXQuZW50cmllc1swXS5qdW5jdGlvblt2ZXJ0aWNhbCA/ICd5JyA6ICd4J10sIGxldmVsIClcbiAgICAgICAgICAgIGVkZ2VzW3RhcmdldC50cnVlX3JhbmtdW3RhcmdldC50cHdpXS5wdXNoKHRhcmdldF9qdW5jdGlvbilcbiAgICAgICAgICAgIGVkZ2VzLnNraXBzLnB1c2goW3NvdXJjZV9qdW5jdGlvbiwgdGFyZ2V0X2p1bmN0aW9uXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gICAgbGFuZXMuZm9yRWFjaChmdW5jdGlvbihsYW5lLCByYW5rX25yKXtcbiAgICAgIGxhbmUuZm9yRWFjaChmdW5jdGlvbihwYXRod2F5LCBwd19pZHgpe1xuICAgICAgICBlZGdlc1tyYW5rX25yXVtwd19pZHhdLnNvcnQocmFua19zb3J0ZXIpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBlZGdlcy5ncm93dGggPSAoZnNraXBzLmxlbmd0aCArIGJza2lwcy5sZW5ndGgpICogc2tpcHNlcFxuXG5cbiAgICByZXR1cm4gZWRnZXNcbiAgfVxuXG59KClcbiIsInZvaWQgZnVuY3Rpb24oKXtcblxuICB2YXIgViA9IHJlcXVpcmUoJy4vdmVjdG9ycy5qcycpXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzZWcxLCBzZWcyKXtcbiAgICB2YXIgcCA9IFtzZWcxLngxLCBzZWcxLnkxXVxuICAgIHZhciByID0gVi5zdWJ0cmFjdChbc2VnMS54Miwgc2VnMS55Ml0sIHApXG4gICAgdmFyIHEgPSBbc2VnMi54MSwgc2VnMi55MV1cbiAgICB2YXIgcyA9IFYuc3VidHJhY3QoW3NlZzIueDIsIHNlZzIueTJdLCBxKVxuXG4gICAgdmFyIHJ4cyA9IFYuY3Jvc3MociwgcylcbiAgICBpZiAoIHJ4cyA9PSAwICkgcmV0dXJuIGZhbHNlXG5cbiAgICB2YXIgcV9wID0gVi5zdWJ0cmFjdChxLHApXG4gICAgdmFyIHJ4cyA9IFYuY3Jvc3MociwgcylcbiAgICB2YXIgdCA9IFYuY3Jvc3MocV9wLCBzKSAvIHJ4c1xuICAgIGlmICggdCA8IDAgfHwgdCA+IDEgKSByZXR1cm4gZmFsc2VcbiAgICB2YXIgdSA9IFYuY3Jvc3MocV9wLCByKSAvIHJ4c1xuICAgIGlmICggdSA8IDAgfHwgdSA+IDEgKSByZXR1cm4gZmFsc2VcblxuICAgIC8vIHZhciB6MSA9IFYuYWRkKHAsIFYuc2NhbGUociwgdCkpXG4gICAgLy8gdmFyIHoyID0gVi5hZGQocSwgVi5zY2FsZShzLCB1KSlcblxuICAgIHJldHVybiBWLmFkZChwLCBWLnNjYWxlKHIsIHQpKVxuICB9XG5cbn0oKVxuIiwidm9pZCBmdW5jdGlvbigpe1xuICB2YXIgdmlyYWwgPSByZXF1aXJlKCd2aXJhbCcpXG4gIHZhciBlbnNsYXZlID0gcmVxdWlyZSgnZW5zbGF2ZScpXG5cbi8vICBmdW5jdGlvbiBkcmF3X2l0ZW0oaXRlbSl7XG4vLyAgICByZXR1cm4gaXRlbS5nID0gaXRlbS5kaWFncmFtLmRyYXcoaXRlbSlcbi8vICB9XG5cbiAgdmFyIEl0ZW0gPSB2aXJhbC5leHRlbmQoe1xuICAgIGluaXQ6IGZ1bmN0aW9uKGRpYWdyYW0sIGlkLCB2YWx1ZSwgaW52YWx1ZXMpe1xuICAgICAgdGhpcy5kaWFncmFtID0gZGlhZ3JhbVxuICAgICAgdGhpcy5pZCA9IGlkXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXMuaW5wdXQgPSBpbnZhbHVlc1xuXG5cblxuLy8gICAgICBjb25zb2xlLmxvZygnbycsIHZhbHVlKVxuLy8gICAgICBjb25zb2xlLmxvZygnaScsIGludmFsdWVzKVxuICAgIH1cbi8vICAgICwgZHJhdzogZW5zbGF2ZShkcmF3X2l0ZW0pXG4gIH0pXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBJdGVtXG5cbn0oKVxuXG4iLCJ2b2lkIGZ1bmN0aW9uKCl7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNsYXRlKHZlY3RvciwgcG9pbnQpe1xuICAgIHJldHVybiB7IHg6IHBvaW50LnggKyB2ZWN0b3JbMF0sIHk6IHBvaW50LnkgKyB2ZWN0b3JbMV0gfVxuICB9XG59KClcbiIsInZvaWQgZnVuY3Rpb24oKXtcblxuICBmdW5jdGlvbiBweXRoKGEsIGIpe1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYSwyKSwgTWF0aC5wb3coYiwyKSlcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNyb3NzOiBmdW5jdGlvbiBjcm9zcyh2LCB3KXtcbiAgICAgIHJldHVybiB2WzBdICogd1sxXSAtIHZbMV0gKiB3WzBdXG4gICAgfVxuXG4gICwgYWRkOiAgZnVuY3Rpb24gYWRkKHYsIHcpe1xuICAgICAgcmV0dXJuIFt2WzBdICsgd1swXSwgdlsxXSArIHdbMV1dXG4gICAgfVxuXG4gICwgc3VidHJhY3Q6ICBmdW5jdGlvbiBzdWJ0cmFjdCh2LCB3KXtcbiAgICAgIHJldHVybiBbdlswXSAtIHdbMF0sIHZbMV0gLSB3WzFdXVxuICAgIH1cblxuICAsIHNjYWxlOiAgZnVuY3Rpb24gc2NhbGUodiwgcyl7XG4gICAgICByZXR1cm4gW3ZbMF0gKiBzLCB2WzFdICogc11cbiAgICB9XG5cbiAgLCBlcTogIGZ1bmN0aW9uIGVxKHYsIHcpe1xuICAgICAgcmV0dXJuIHZbMF0gPT0gd1swXSAmJiAgdlsxXSA9PSB3WzFdXG4gICAgfVxuICAsIG1hZ25pdHVkZTogZnVuY3Rpb24gbWFnbml0dWRlKHYpe1xuICAgICAgcmV0dXJuIHB5dGgodlswXSwgdlsxXSlcbiAgICB9XG5cbiAgfVxufSgpXG4iLCJ2b2lkIGZ1bmN0aW9uKCl7XG4gIHZhciBlbnNsYXZlID0gcmVxdWlyZSgnZW5zbGF2ZScpXG4gIHZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlLmpzJylcbiAgdmFyIHVpZCA9IHJlcXVpcmUoJy4uL3V0aWwvdW5pcXVlX2lkLmpzJylcblxuICB2YXIgRWRnZSA9IE5vZGUuZXh0ZW5kKHtcbiAgICBpbml0OiBmdW5jdGlvbihncmFwaCwgc291cmNlLCB0YXJnZXQsIHRyYW5zZm9ybSwgYXR0cnMpe1xuICAgICAgdGhpcy5pZCA9IHVpZCgpXG4gICAgICB0aGlzLnR5cGUgPSAnZWRnZSdcbiAgICAgIHRoaXMuZ3JhcGggPSBncmFwaFxuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2VcbiAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0XG4gICAgfVxuICB9KVxuXG4gIG1vZHVsZS5leHBvcnRzID0gRWRnZVxufSgpXG4iLCJ2b2lkIGZ1bmN0aW9uKCl7XG4gIHZhciB2aXJhbCA9IHJlcXVpcmUoJ3ZpcmFsJylcbiAgdmFyIGVuc2xhdmUgPSByZXF1aXJlKCdlbnNsYXZlJylcbiAgdmFyIGRhZ3JlID0gcmVxdWlyZSgnZGFncmUnKVxuICB2YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcbiAgdmFyIHVpZCA9IHJlcXVpcmUoJy4uL3V0aWwvdW5pcXVlX2lkLmpzJylcbiAgdmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUuanMnKVxuICB2YXIgRWRnZSA9IHJlcXVpcmUoJy4vZWRnZS5qcycpXG5cbiAgZnVuY3Rpb24gYWRkX25vZGUoZ3JhcGgsIGNsYXNzbmFtZSwgdHJhbnNmb3JtLCBjb250ZW50LCBwcmVmUmFuayl7XG4gICAgdmFyIG5vZGUgPSBOb2RlLm1ha2UoZ3JhcGgsIHRyYW5zZm9ybSwge1xuICAgICAgICBjbGFzc25hbWU6IGNsYXNzbmFtZVxuICAgICAgLCBjb250ZW50OiBjb250ZW50XG4gICAgICAsIHJhbms6IHByZWZSYW5rXG4gICAgfSlcblxuICAgIGdyYXBoLmluZ3JhcGguYWRkTm9kZShub2RlLmlkLCBub2RlKVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVfbm9kZShncmFwaCwgbm9kZV9pZCl7XG4gICAgdmFyIGcgPSBncmFwaC5pbmdyYXBoXG4gICAgaWYgKCBnLmhhc05vZGUobm9kZV9pZCkgKSB7XG4gICAgICBjaGFyLmRlbE5vZGUobm9kZV9pZClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gY29ubmVjdChncmFwaCwgY2xhc3NuYW1lLCBzb3VyY2UsIHRhcmdldCwgdHJhbnNmb3JtLCBjb250ZW50KXtcbiAgICB2YXIgZWRnZSA9IEVkZ2UubWFrZShncmFwaCwgc291cmNlLCB0YXJnZXQpXG4gICAgZ3JhcGguaW5ncmFwaC5hZGRFZGdlKGVkZ2UuaWQsIHNvdXJjZS5pZCwgdGFyZ2V0LmlkLCBlZGdlKVxuICAgIHJldHVybiBlZGdlXG4gIH1cblxuICBmdW5jdGlvbiBkaXNjb25uZWN0KGdyYXBoLCBzb3VyY2UsIHRhcmdldCl7XG4gICAgdmFyIGcgPSBncmFwaC5pbmdyYXBoXG4gICAgdmFyIGVkZ2VfaWQgPSBnLm91dEVkZ2VzKHNvdXJjZS5pZCwgdGFyZ2V0LmlkKVxuICAgIGlmICggZy5oYXNFZGdlKGVkZ2VfaWQpICkge1xuICAgICAgZy5kZWxFZGdlKGVkZ2VfaWQpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IHZpcmFsLmV4dGVuZChuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcikuZXh0ZW5kKHtcbiAgICBpbml0OiBmdW5jdGlvbihjZmdvYmope1xuICAgICAgdGhpcy5jb25maWcgPSBjZmdvYmpcbiAgICAgIHRoaXMuaW5ncmFwaCA9ICBuZXcgZGFncmUuRGlncmFwaCgpXG4gICAgfVxuICAsIGFkZF9ub2RlOiBlbnNsYXZlKGFkZF9ub2RlKVxuICAsIGRlbF9ub2RlOiBlbnNsYXZlKHJlbW92ZV9ub2RlKVxuICAsIGNvbm5lY3Q6IGVuc2xhdmUoY29ubmVjdClcbiAgLCBkaXNjb25uZWN0OiBlbnNsYXZlKGRpc2Nvbm5lY3QpXG4gIH0pXG5cbn0oKVxuIiwidm9pZCBmdW5jdGlvbigpe1xuICB2YXIgdmlyYWwgPSByZXF1aXJlKCd2aXJhbCcpXG4gIHZhciBlbnNsYXZlID0gcmVxdWlyZSgnZW5zbGF2ZScpXG4gIHZhciB1aWQgPSByZXF1aXJlKCcuLi91dGlsL3VuaXF1ZV9pZC5qcycpXG5cbiAgZnVuY3Rpb24gc2V0X2F0dHJzKG5vZGUsIGF0dHJzKXtcbiAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgICAgbm9kZVtrZXldID0gYXR0cnNba2V5XVxuICAgIH0pXG4gICAgbm9kZS5ncmFwaC5lbWl0KG5vZGUudHlwZSArICdfYXR0cnMnLCBhdHRycylcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldF9hdHRyKG5vZGUsIGF0dHIsIHZhbHVlKXtcbiAgICBub2RlW2F0dHJdID0gdmFsdWVcbiAgICBub2RlLmdyYXBoLmVtaXQobm9kZS50eXBlICsgJ19hdHRyJywgYXR0ciwgdmFsdWUpXG4gIH1cblxuICBmdW5jdGlvbiBhZGRfYXR0cihub2RlLCBzZWxlY3RvciwgbmFtZSwgdmFsdWUpe1xuICAgIG5vZGUuY29udGVudFtzZWxlY3Rvcl0gPSBub2RlLmNvbnRlbnRbc2VsZWN0b3JdIHx8IHt9XG4gICAgbm9kZS5jb250ZW50W3NlbGVjdG9yXVtuYW1lXSA9IHZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBhZGRfYXR0cnMobm9kZSwgc2VsZWN0b3IsIGF0dHJzKXtcbiAgICBub2RlLmNvbnRlbnRbc2VsZWN0b3JdID0gdmFsdWVcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gdmlyYWwuZXh0ZW5kKHtcbiAgICBpbml0OiBmdW5jdGlvbihncmFwaCwgdHJhbnNmb3JtLCBhdHRycyl7XG4gICAgICB0aGlzLmlkID0gdWlkKClcbiAgICAgIHRoaXMudHlwZSA9ICd2ZXJ0ZXgnXG4gICAgICB0aGlzLmdyYXBoID0gZ3JhcGhcbiAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtLmJpbmQobnVsbCwgdGhpcylcbiAgICAgIHNldF9hdHRycyh0aGlzLCBhdHRycylcbiAgICB9XG4gICwgYXR0cnM6IGVuc2xhdmUoc2V0X2F0dHJzKVxuICAsIGF0dHI6IGVuc2xhdmUoc2V0X2F0dHIpXG4gICwgYWRkX2F0dHI6IGVuc2xhdmUoYWRkX2F0dHIpXG4gICwgYWRkX2F0dHJzOiBlbnNsYXZlKGFkZF9hdHRycylcbiAgfSlcblxufSgpXG4iLCJ2b2lkIGZ1bmN0aW9uKCl7XG4vLyAgdmFyIFNuYXAgPSByZXF1aXJlKCdzbmFwc3ZnJylcbi8vICAgIGluaXQ6IGZ1bmN0aW9uKCl7XG4vLyAgICAgIHRoaXMuc3ZnZWwgPSBTbmFwLmFwcGx5KFNuYXAsIGFyZ3VtZW50cylcbi8vICAgIH1cblxuICBpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuICAgIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vdXRpbC9kZWZhdWx0cy5qcycpXG4gIHZhciBHcmFwaCA9IHJlcXVpcmUoJy4vZ3JhcGgvZ3JhcGguanMnKVxuICB2YXIgRGlhZ3JhbSA9IHJlcXVpcmUoJy4vZGlhZ3JhbS9kaWFncmFtLmpzJylcblxuXG4gIC8qKlxuICAqIFNldCBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgKiBAcGFyYW0gICAgICB7T2JqZWN0fSBvcHRpb25zXG4gICogQHJldHVybiAgICAge09iamVjdH0gb3B0aW9ucyBmaWxsZWQgd2l0aCBkZWZhdWx0c1xuICAqL1xuICBmdW5jdGlvbiBjb25maWcoY2Znb2JqKXtcbiAgICB2YXIgZGVmYXVsdF9jZmcgPSB7XG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGhcbiAgICAsIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgLCBmb250X3NpemU6IDIxXG4gICAgLCBsaW5lX2hlaWdodDogMjYgLy8gZm9yIGZvbnQtc2l6ZSAyMVxuICAgIH1cbiAgICByZXR1cm4gY2Znb2JqID09IG51bGwgPyBkZWZhdWx0X2NmZ1xuICAgICAgICAgOiAgICAgICAgICAgICAgICAgIGRlZmF1bHRzKGNmZ29iaiwgZGVmYXVsdF9jZmcpXG4gIH1cblxuICAvKipcbiAgKiBDcmVhdGUgYSBuZXcgZ3JhcGggb2JqZWN0IHRvIHN0b3JlIGRpYWdyYW0gZGF0YSBpbiBpdFxuICAqIEByZXR1cm4gICAgIHtPYmplY3R9ICAgZ3JhcGggb2JqZWN0XG4gICovXG4gIGZ1bmN0aW9uIGdyYXBoKGNmZ29iail7XG4gICAgcmV0dXJuIEdyYXBoLm1ha2UoY2Znb2JqKVxuICB9XG5cbiAgLyoqXG4gICogSW5pdGlhbGl6ZSBkaWFncmFtIHdpdGggb3B0aW9ucyBhbmQgZ3JhcGggb2JqZWN0XG4gICogYW5kIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gICogQHBhcmFtICAgICAge09iamVjdH0gICBvcHRpb25zXG4gICogQHBhcmFtICAgICAge09iamVjdH0gICBncmFwaCBvYmplY3RcbiAgKiBAcmV0dXJuICAgICB7T2JqZWN0fSAgIGRpYWdyYW1cbiAgKi9cbiAgZnVuY3Rpb24gZGlhZ3JhbShjZmdvYmosIGdyYXBoKXtcbiAgICByZXR1cm4gRGlhZ3JhbS5tYWtlKGNmZ29iaiwgZ3JhcGgpXG4gIH1cblxuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbmZpZzogY29uZmlnXG4gICwgZ3JhcGg6IGdyYXBoXG4gICwgZGlhZ3JhbTogZGlhZ3JhbVxuICB9XG5cbn0oKVxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxMi0yMDEzIENocmlzIFBldHRpdHRcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cbmV4cG9ydHMuRGlncmFwaCA9IHJlcXVpcmUoXCJncmFwaGxpYlwiKS5EaWdyYXBoO1xuZXhwb3J0cy5HcmFwaCA9IHJlcXVpcmUoXCJncmFwaGxpYlwiKS5HcmFwaDtcbmV4cG9ydHMubGF5b3V0ID0gcmVxdWlyZShcIi4vbGliL2xheW91dFwiKTtcbmV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoXCIuL2xpYi92ZXJzaW9uXCIpO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICByYW5rID0gcmVxdWlyZSgnLi9yYW5rJyksXG4gICAgb3JkZXIgPSByZXF1aXJlKCcuL29yZGVyJyksXG4gICAgQ0dyYXBoID0gcmVxdWlyZSgnZ3JhcGhsaWInKS5DR3JhcGgsXG4gICAgQ0RpZ3JhcGggPSByZXF1aXJlKCdncmFwaGxpYicpLkNEaWdyYXBoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAvLyBFeHRlcm5hbCBjb25maWd1cmF0aW9uXG4gIHZhciBjb25maWcgPSB7XG4gICAgLy8gSG93IG11Y2ggZGVidWcgaW5mb3JtYXRpb24gdG8gaW5jbHVkZT9cbiAgICBkZWJ1Z0xldmVsOiAwLFxuICAgIC8vIE1heCBudW1iZXIgb2Ygc3dlZXBzIHRvIHBlcmZvcm0gaW4gb3JkZXIgcGhhc2VcbiAgICBvcmRlck1heFN3ZWVwczogb3JkZXIuREVGQVVMVF9NQVhfU1dFRVBTLFxuICAgIC8vIFVzZSBuZXR3b3JrIHNpbXBsZXggYWxnb3JpdGhtIGluIHJhbmtpbmdcbiAgICByYW5rU2ltcGxleDogZmFsc2UsXG4gICAgLy8gUmFuayBkaXJlY3Rpb24uIFZhbGlkIHZhbHVlcyBhcmUgKFRCLCBMUilcbiAgICByYW5rRGlyOiAnVEInXG4gIH07XG5cbiAgLy8gUGhhc2UgZnVuY3Rpb25zXG4gIHZhciBwb3NpdGlvbiA9IHJlcXVpcmUoJy4vcG9zaXRpb24nKSgpO1xuXG4gIC8vIFRoaXMgbGF5b3V0IG9iamVjdFxuICB2YXIgc2VsZiA9IHt9O1xuXG4gIHNlbGYub3JkZXJJdGVycyA9IHV0aWwucHJvcGVydHlBY2Nlc3NvcihzZWxmLCBjb25maWcsICdvcmRlck1heFN3ZWVwcycpO1xuXG4gIHNlbGYucmFua1NpbXBsZXggPSB1dGlsLnByb3BlcnR5QWNjZXNzb3Ioc2VsZiwgY29uZmlnLCAncmFua1NpbXBsZXgnKTtcblxuICBzZWxmLm5vZGVTZXAgPSBkZWxlZ2F0ZVByb3BlcnR5KHBvc2l0aW9uLm5vZGVTZXApO1xuICBzZWxmLmVkZ2VTZXAgPSBkZWxlZ2F0ZVByb3BlcnR5KHBvc2l0aW9uLmVkZ2VTZXApO1xuICBzZWxmLnVuaXZlcnNhbFNlcCA9IGRlbGVnYXRlUHJvcGVydHkocG9zaXRpb24udW5pdmVyc2FsU2VwKTtcbiAgc2VsZi5yYW5rU2VwID0gZGVsZWdhdGVQcm9wZXJ0eShwb3NpdGlvbi5yYW5rU2VwKTtcbiAgc2VsZi5yYW5rRGlyID0gdXRpbC5wcm9wZXJ0eUFjY2Vzc29yKHNlbGYsIGNvbmZpZywgJ3JhbmtEaXInKTtcbiAgc2VsZi5kZWJ1Z0FsaWdubWVudCA9IGRlbGVnYXRlUHJvcGVydHkocG9zaXRpb24uZGVidWdBbGlnbm1lbnQpO1xuXG4gIHNlbGYuZGVidWdMZXZlbCA9IHV0aWwucHJvcGVydHlBY2Nlc3NvcihzZWxmLCBjb25maWcsICdkZWJ1Z0xldmVsJywgZnVuY3Rpb24oeCkge1xuICAgIHV0aWwubG9nLmxldmVsID0geDtcbiAgICBwb3NpdGlvbi5kZWJ1Z0xldmVsKHgpO1xuICB9KTtcblxuICBzZWxmLnJ1biA9IHV0aWwudGltZSgnVG90YWwgbGF5b3V0JywgcnVuKTtcblxuICBzZWxmLl9ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbiAgcmV0dXJuIHNlbGY7XG5cbiAgLypcbiAgICogQ29uc3RydWN0cyBhbiBhZGphY2VuY3kgZ3JhcGggdXNpbmcgdGhlIG5vZGVzIGFuZCBlZGdlcyBzcGVjaWZpZWQgdGhyb3VnaFxuICAgKiBjb25maWcuIEZvciBlYWNoIG5vZGUgYW5kIGVkZ2Ugd2UgYWRkIGEgcHJvcGVydHkgYGRhZ3JlYCB0aGF0IGNvbnRhaW5zIGFuXG4gICAqIG9iamVjdCB0aGF0IHdpbGwgaG9sZCBpbnRlcm1lZGlhdGUgYW5kIGZpbmFsIGxheW91dCBpbmZvcm1hdGlvbi4gU29tZSBvZlxuICAgKiB0aGUgY29udGVudHMgaW5jbHVkZTpcbiAgICpcbiAgICogIDEpIEEgZ2VuZXJhdGVkIElEIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgb2JqZWN0LlxuICAgKiAgMikgRGltZW5zaW9uIGluZm9ybWF0aW9uIGZvciBub2RlcyAoY29waWVkIGZyb20gdGhlIHNvdXJjZSBub2RlKS5cbiAgICogIDMpIE9wdGlvbmFsIGRpbWVuc2lvbiBpbmZvcm1hdGlvbiBmb3IgZWRnZXMuXG4gICAqXG4gICAqIEFmdGVyIHRoZSBhZGphY2VuY3kgZ3JhcGggaXMgY29uc3RydWN0ZWQgdGhlIGNvZGUgbm8gbG9uZ2VyIG5lZWRzIHRvIHVzZVxuICAgKiB0aGUgb3JpZ2luYWwgbm9kZXMgYW5kIGVkZ2VzIHBhc3NlZCBpbiB2aWEgY29uZmlnLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdExheW91dEdyYXBoKGlucHV0R3JhcGgpIHtcbiAgICB2YXIgZyA9IG5ldyBDRGlncmFwaCgpO1xuXG4gICAgaW5wdXRHcmFwaC5lYWNoTm9kZShmdW5jdGlvbih1LCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0ge307XG4gICAgICBnLmFkZE5vZGUodSwge1xuICAgICAgICB3aWR0aDogdmFsdWUud2lkdGgsXG4gICAgICAgIGhlaWdodDogdmFsdWUuaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgncmFuaycpKSB7XG4gICAgICAgIGcubm9kZSh1KS5wcmVmUmFuayA9IHZhbHVlLnJhbms7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTZXQgdXAgc3ViZ3JhcGhzXG4gICAgaWYgKGlucHV0R3JhcGgucGFyZW50KSB7XG4gICAgICBpbnB1dEdyYXBoLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbih1KSB7XG4gICAgICAgIGcucGFyZW50KHUsIGlucHV0R3JhcGgucGFyZW50KHUpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlucHV0R3JhcGguZWFjaEVkZ2UoZnVuY3Rpb24oZSwgdSwgdiwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB2YWx1ZSA9IHt9O1xuICAgICAgdmFyIG5ld1ZhbHVlID0ge1xuICAgICAgICBlOiBlLFxuICAgICAgICBtaW5MZW46IHZhbHVlLm1pbkxlbiB8fCAxLFxuICAgICAgICB3aWR0aDogdmFsdWUud2lkdGggfHwgMCxcbiAgICAgICAgaGVpZ2h0OiB2YWx1ZS5oZWlnaHQgfHwgMCxcbiAgICAgICAgcG9pbnRzOiBbXVxuICAgICAgfTtcblxuICAgICAgZy5hZGRFZGdlKG51bGwsIHUsIHYsIG5ld1ZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8vIEluaXRpYWwgZ3JhcGggYXR0cmlidXRlc1xuICAgIHZhciBncmFwaFZhbHVlID0gaW5wdXRHcmFwaC5ncmFwaCgpIHx8IHt9O1xuICAgIGcuZ3JhcGgoe1xuICAgICAgcmFua0RpcjogZ3JhcGhWYWx1ZS5yYW5rRGlyIHx8IGNvbmZpZy5yYW5rRGlyLFxuICAgICAgb3JkZXJSZXN0YXJ0czogZ3JhcGhWYWx1ZS5vcmRlclJlc3RhcnRzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bihpbnB1dEdyYXBoKSB7XG4gICAgdmFyIHJhbmtTZXAgPSBzZWxmLnJhbmtTZXAoKTtcbiAgICB2YXIgZztcbiAgICB0cnkge1xuICAgICAgLy8gQnVpbGQgaW50ZXJuYWwgZ3JhcGhcbiAgICAgIGcgPSB1dGlsLnRpbWUoJ2luaXRMYXlvdXRHcmFwaCcsIGluaXRMYXlvdXRHcmFwaCkoaW5wdXRHcmFwaCk7XG5cbiAgICAgIGlmIChnLm9yZGVyKCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3BhY2UgZm9yIGVkZ2UgbGFiZWxzXG4gICAgICBnLmVhY2hFZGdlKGZ1bmN0aW9uKGUsIHMsIHQsIGEpIHtcbiAgICAgICAgYS5taW5MZW4gKj0gMjtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5yYW5rU2VwKHJhbmtTZXAgLyAyKTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSByYW5rIGZvciBlYWNoIG5vZGUuIE5vZGVzIHdpdGggYSBsb3dlciByYW5rIHdpbGwgYXBwZWFyXG4gICAgICAvLyBhYm92ZSBub2RlcyBvZiBoaWdoZXIgcmFuay5cbiAgICAgIHV0aWwudGltZSgncmFuay5ydW4nLCByYW5rLnJ1bikoZywgY29uZmlnLnJhbmtTaW1wbGV4KTtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZSBncmFwaCBieSBlbnN1cmluZyB0aGF0IGV2ZXJ5IGVkZ2UgaXMgcHJvcGVyIChlYWNoIGVkZ2UgaGFzXG4gICAgICAvLyBhIGxlbmd0aCBvZiAxKS4gV2UgYWNoaWV2ZSB0aGlzIGJ5IGFkZGluZyBkdW1teSBub2RlcyB0byBsb25nIGVkZ2VzLFxuICAgICAgLy8gdGh1cyBzaG9ydGVuaW5nIHRoZW0uXG4gICAgICB1dGlsLnRpbWUoJ25vcm1hbGl6ZScsIG5vcm1hbGl6ZSkoZyk7XG5cbiAgICAgIC8vIE9yZGVyIHRoZSBub2RlcyBzbyB0aGF0IGVkZ2UgY3Jvc3NpbmdzIGFyZSBtaW5pbWl6ZWQuXG4gICAgICB1dGlsLnRpbWUoJ29yZGVyJywgb3JkZXIpKGcsIGNvbmZpZy5vcmRlck1heFN3ZWVwcyk7XG5cbiAgICAgIC8vIEZpbmQgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZm9yIGV2ZXJ5IG5vZGUgaW4gdGhlIGdyYXBoLlxuICAgICAgdXRpbC50aW1lKCdwb3NpdGlvbicsIHBvc2l0aW9uLnJ1bikoZyk7XG5cbiAgICAgIC8vIERlLW5vcm1hbGl6ZSB0aGUgZ3JhcGggYnkgcmVtb3ZpbmcgZHVtbXkgbm9kZXMgYW5kIGF1Z21lbnRpbmcgdGhlXG4gICAgICAvLyBvcmlnaW5hbCBsb25nIGVkZ2VzIHdpdGggY29vcmRpbmF0ZSBpbmZvcm1hdGlvbi5cbiAgICAgIHV0aWwudGltZSgndW5kb05vcm1hbGl6ZScsIHVuZG9Ob3JtYWxpemUpKGcpO1xuXG4gICAgICAvLyBSZXZlcnNlcyBwb2ludHMgZm9yIGVkZ2VzIHRoYXQgYXJlIGluIGEgcmV2ZXJzZWQgc3RhdGUuXG4gICAgICB1dGlsLnRpbWUoJ2ZpeHVwRWRnZVBvaW50cycsIGZpeHVwRWRnZVBvaW50cykoZyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgZGVsZXRlIGVkZ2VzIGFuZCByZXZlcnNlIGVkZ2VzIHRoYXQgd2VyZSByZXZlcnNlZCBpbiB0aGUgcmFua1xuICAgICAgLy8gcGhhc2UuXG4gICAgICB1dGlsLnRpbWUoJ3JhbmsucmVzdG9yZUVkZ2VzJywgcmFuay5yZXN0b3JlRWRnZXMpKGcpO1xuXG4gICAgICAvLyBDb25zdHJ1Y3QgZmluYWwgcmVzdWx0IGdyYXBoIGFuZCByZXR1cm4gaXRcbiAgICAgIHJldHVybiB1dGlsLnRpbWUoJ2NyZWF0ZUZpbmFsR3JhcGgnLCBjcmVhdGVGaW5hbEdyYXBoKShnLCBpbnB1dEdyYXBoLmlzRGlyZWN0ZWQoKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNlbGYucmFua1NlcChyYW5rU2VwKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciAnbm9ybWFsaXppbmcnIHRoZSBncmFwaC4gVGhlIHByb2Nlc3Mgb2ZcbiAgICogbm9ybWFsaXphdGlvbiBlbnN1cmVzIHRoYXQgbm8gZWRnZSBpbiB0aGUgZ3JhcGggaGFzIHNwYW5zIG1vcmUgdGhhbiBvbmVcbiAgICogcmFuay4gVG8gZG8gdGhpcyBpdCBpbnNlcnRzIGR1bW15IG5vZGVzIGFzIG5lZWRlZCBhbmQgbGlua3MgdGhlbSBieSBhZGRpbmdcbiAgICogZHVtbXkgZWRnZXMuIFRoaXMgZnVuY3Rpb24ga2VlcHMgZW5vdWdoIGluZm9ybWF0aW9uIGluIHRoZSBkdW1teSBub2RlcyBhbmRcbiAgICogZWRnZXMgdG8gZW5zdXJlIHRoYXQgdGhlIG9yaWdpbmFsIGdyYXBoIGNhbiBiZSByZWNvbnN0cnVjdGVkIGxhdGVyLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoYXQgdGhlIGlucHV0IGdyYXBoIGlzIGN5Y2xlIGZyZWUuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemUoZykge1xuICAgIHZhciBkdW1teUNvdW50ID0gMDtcbiAgICBnLmVhY2hFZGdlKGZ1bmN0aW9uKGUsIHMsIHQsIGEpIHtcbiAgICAgIHZhciBzb3VyY2VSYW5rID0gZy5ub2RlKHMpLnJhbms7XG4gICAgICB2YXIgdGFyZ2V0UmFuayA9IGcubm9kZSh0KS5yYW5rO1xuICAgICAgaWYgKHNvdXJjZVJhbmsgKyAxIDwgdGFyZ2V0UmFuaykge1xuICAgICAgICBmb3IgKHZhciB1ID0gcywgcmFuayA9IHNvdXJjZVJhbmsgKyAxLCBpID0gMDsgcmFuayA8IHRhcmdldFJhbms7ICsrcmFuaywgKytpKSB7XG4gICAgICAgICAgdmFyIHYgPSAnX0QnICsgKCsrZHVtbXlDb3VudCk7XG4gICAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgICB3aWR0aDogYS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYS5oZWlnaHQsXG4gICAgICAgICAgICBlZGdlOiB7IGlkOiBlLCBzb3VyY2U6IHMsIHRhcmdldDogdCwgYXR0cnM6IGEgfSxcbiAgICAgICAgICAgIHJhbms6IHJhbmssXG4gICAgICAgICAgICBkdW1teTogdHJ1ZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIG5vZGUgcmVwcmVzZW50cyBhIGJlbmQgdGhlbiB3ZSB3aWxsIHVzZSBpdCBhcyBhIGNvbnRyb2xcbiAgICAgICAgICAvLyBwb2ludC4gRm9yIGVkZ2VzIHdpdGggMiBzZWdtZW50cyB0aGlzIHdpbGwgYmUgdGhlIGNlbnRlciBkdW1teVxuICAgICAgICAgIC8vIG5vZGUuIEZvciBlZGdlcyB3aXRoIG1vcmUgdGhhbiB0d28gc2VnbWVudHMsIHRoaXMgd2lsbCBiZSB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBhbmQgbGFzdCBkdW1teSBub2RlLlxuICAgICAgICAgIGlmIChpID09PSAwKSBub2RlLmluZGV4ID0gMDtcbiAgICAgICAgICBlbHNlIGlmIChyYW5rICsgMSA9PT0gdGFyZ2V0UmFuaykgbm9kZS5pbmRleCA9IDE7XG5cbiAgICAgICAgICBnLmFkZE5vZGUodiwgbm9kZSk7XG4gICAgICAgICAgZy5hZGRFZGdlKG51bGwsIHUsIHYsIHt9KTtcbiAgICAgICAgICB1ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBnLmFkZEVkZ2UobnVsbCwgdSwgdCwge30pO1xuICAgICAgICBnLmRlbEVkZ2UoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKlxuICAgKiBSZWNvbnN0cnVjdHMgdGhlIGdyYXBoIGFzIGl0IHdhcyBiZWZvcmUgbm9ybWFsaXphdGlvbi4gVGhlIHBvc2l0aW9ucyBvZlxuICAgKiBkdW1teSBub2RlcyBhcmUgdXNlZCB0byBidWlsZCBhbiBhcnJheSBvZiBwb2ludHMgZm9yIHRoZSBvcmlnaW5hbCAnbG9uZydcbiAgICogZWRnZS4gRHVtbXkgbm9kZXMgYW5kIGVkZ2VzIGFyZSByZW1vdmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5kb05vcm1hbGl6ZShnKSB7XG4gICAgZy5lYWNoTm9kZShmdW5jdGlvbih1LCBhKSB7XG4gICAgICBpZiAoYS5kdW1teSkge1xuICAgICAgICBpZiAoJ2luZGV4JyBpbiBhKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBhLmVkZ2U7XG4gICAgICAgICAgaWYgKCFnLmhhc0VkZ2UoZWRnZS5pZCkpIHtcbiAgICAgICAgICAgIGcuYWRkRWRnZShlZGdlLmlkLCBlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQsIGVkZ2UuYXR0cnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcG9pbnRzID0gZy5lZGdlKGVkZ2UuaWQpLnBvaW50cztcbiAgICAgICAgICBwb2ludHNbYS5pbmRleF0gPSB7IHg6IGEueCwgeTogYS55LCB1bDogYS51bCwgdXI6IGEudXIsIGRsOiBhLmRsLCBkcjogYS5kciB9O1xuICAgICAgICB9XG4gICAgICAgIGcuZGVsTm9kZSh1KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qXG4gICAqIEZvciBlYWNoIGVkZ2UgdGhhdCB3YXMgcmV2ZXJzZWQgZHVyaW5nIHRoZSBgYWN5Y2xpY2Agc3RlcCwgcmV2ZXJzZSBpdHNcbiAgICogYXJyYXkgb2YgcG9pbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gZml4dXBFZGdlUG9pbnRzKGcpIHtcbiAgICBnLmVhY2hFZGdlKGZ1bmN0aW9uKGUsIHMsIHQsIGEpIHsgaWYgKGEucmV2ZXJzZWQpIGEucG9pbnRzLnJldmVyc2UoKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGaW5hbEdyYXBoKGcsIGlzRGlyZWN0ZWQpIHtcbiAgICB2YXIgb3V0ID0gaXNEaXJlY3RlZCA/IG5ldyBDRGlncmFwaCgpIDogbmV3IENHcmFwaCgpO1xuICAgIG91dC5ncmFwaChnLmdyYXBoKCkpO1xuICAgIGcuZWFjaE5vZGUoZnVuY3Rpb24odSwgdmFsdWUpIHsgb3V0LmFkZE5vZGUodSwgdmFsdWUpOyB9KTtcbiAgICBnLmVhY2hOb2RlKGZ1bmN0aW9uKHUpIHsgb3V0LnBhcmVudCh1LCBnLnBhcmVudCh1KSk7IH0pO1xuICAgIGcuZWFjaEVkZ2UoZnVuY3Rpb24oZSwgdSwgdiwgdmFsdWUpIHtcbiAgICAgIG91dC5hZGRFZGdlKHZhbHVlLmUsIHUsIHYsIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8vIEF0dGFjaCBib3VuZGluZyBib3ggaW5mb3JtYXRpb25cbiAgICB2YXIgbWF4WCA9IDAsIG1heFkgPSAwO1xuICAgIGcuZWFjaE5vZGUoZnVuY3Rpb24odSwgdmFsdWUpIHtcbiAgICAgIGlmICghZy5jaGlsZHJlbih1KS5sZW5ndGgpIHtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHZhbHVlLnggKyB2YWx1ZS53aWR0aCAvIDIpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgdmFsdWUueSArIHZhbHVlLmhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGcuZWFjaEVkZ2UoZnVuY3Rpb24oZSwgdSwgdiwgdmFsdWUpIHtcbiAgICAgIHZhciBtYXhYUG9pbnRzID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWUucG9pbnRzLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiBwLng7IH0pKTtcbiAgICAgIHZhciBtYXhZUG9pbnRzID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWUucG9pbnRzLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiBwLnk7IH0pKTtcbiAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBtYXhYUG9pbnRzICsgdmFsdWUud2lkdGggLyAyKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBtYXhZUG9pbnRzICsgdmFsdWUuaGVpZ2h0IC8gMik7XG4gICAgfSk7XG4gICAgb3V0LmdyYXBoKCkud2lkdGggPSBtYXhYO1xuICAgIG91dC5ncmFwaCgpLmhlaWdodCA9IG1heFk7XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLypcbiAgICogR2l2ZW4gYSBmdW5jdGlvbiwgYSBuZXcgZnVuY3Rpb24gaXMgcmV0dXJuZWQgdGhhdCBpbnZva2VzIHRoZSBnaXZlblxuICAgKiBmdW5jdGlvbi4gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyBhbHdheXMgdGhlIGBzZWxmYCBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBkZWxlZ2F0ZVByb3BlcnR5KGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmKCk7XG4gICAgICBmLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICB9XG59O1xuXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIGNyb3NzQ291bnQgPSByZXF1aXJlKCcuL29yZGVyL2Nyb3NzQ291bnQnKSxcbiAgICBpbml0TGF5ZXJHcmFwaHMgPSByZXF1aXJlKCcuL29yZGVyL2luaXRMYXllckdyYXBocycpLFxuICAgIGluaXRPcmRlciA9IHJlcXVpcmUoJy4vb3JkZXIvaW5pdE9yZGVyJyksXG4gICAgc29ydExheWVyID0gcmVxdWlyZSgnLi9vcmRlci9zb3J0TGF5ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBvcmRlcjtcblxuLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHN3ZWVwcyB0byBwZXJmb3JtIGJlZm9yZSBmaW5pc2hpbmcgdGhlIG9yZGVyIHBoYXNlLlxudmFyIERFRkFVTFRfTUFYX1NXRUVQUyA9IDI0O1xub3JkZXIuREVGQVVMVF9NQVhfU1dFRVBTID0gREVGQVVMVF9NQVhfU1dFRVBTO1xuXG4vKlxuICogUnVucyB0aGUgb3JkZXIgcGhhc2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGBncmFwaCwgYG1heFN3ZWVwc2AsIGFuZFxuICogYGRlYnVnTGV2ZWxgLiBJZiBgbWF4U3dlZXBzYCBpcyBub3Qgc3BlY2lmaWVkIHdlIHVzZSBgREVGQVVMVF9NQVhfU1dFRVBTYC5cbiAqIElmIGBkZWJ1Z0xldmVsYCBpcyBub3Qgc2V0IHdlIGFzc3VtZSAwLlxuICovXG5mdW5jdGlvbiBvcmRlcihnLCBtYXhTd2VlcHMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgbWF4U3dlZXBzID0gREVGQVVMVF9NQVhfU1dFRVBTO1xuICB9XG5cbiAgdmFyIHJlc3RhcnRzID0gZy5ncmFwaCgpLm9yZGVyUmVzdGFydHMgfHwgMDtcblxuICB2YXIgbGF5ZXJHcmFwaHMgPSBpbml0TGF5ZXJHcmFwaHMoZyk7XG4gIC8vIFRPRE86IHJlbW92ZSB0aGlzIHdoZW4gd2UgYWRkIGJhY2sgc3VwcG9ydCBmb3Igb3JkZXJpbmcgY2x1c3RlcnNcbiAgbGF5ZXJHcmFwaHMuZm9yRWFjaChmdW5jdGlvbihsZykge1xuICAgIGxnID0gbGcuZmlsdGVyTm9kZXMoZnVuY3Rpb24odSkgeyByZXR1cm4gIWcuY2hpbGRyZW4odSkubGVuZ3RoOyB9KTtcbiAgfSk7XG5cbiAgdmFyIGl0ZXJzID0gMCxcbiAgICAgIGN1cnJlbnRCZXN0Q0MsXG4gICAgICBhbGxUaW1lQmVzdENDID0gTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgIGFsbFRpbWVCZXN0ID0ge307XG5cbiAgZnVuY3Rpb24gc2F2ZUFsbFRpbWVCZXN0KCkge1xuICAgIGcuZWFjaE5vZGUoZnVuY3Rpb24odSwgdmFsdWUpIHsgYWxsVGltZUJlc3RbdV0gPSB2YWx1ZS5vcmRlcjsgfSk7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IE51bWJlcihyZXN0YXJ0cykgKyAxICYmIGFsbFRpbWVCZXN0Q0MgIT09IDA7ICsraikge1xuICAgIGN1cnJlbnRCZXN0Q0MgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGluaXRPcmRlcihnLCByZXN0YXJ0cyA+IDApO1xuXG4gICAgdXRpbC5sb2coMiwgJ09yZGVyIHBoYXNlIHN0YXJ0IGNyb3NzIGNvdW50OiAnICsgZy5ncmFwaCgpLm9yZGVySW5pdENDKTtcblxuICAgIHZhciBpLCBsYXN0QmVzdCwgY2M7XG4gICAgZm9yIChpID0gMCwgbGFzdEJlc3QgPSAwOyBsYXN0QmVzdCA8IDQgJiYgaSA8IG1heFN3ZWVwcyAmJiBjdXJyZW50QmVzdENDID4gMDsgKytpLCArK2xhc3RCZXN0LCArK2l0ZXJzKSB7XG4gICAgICBzd2VlcChnLCBsYXllckdyYXBocywgaSk7XG4gICAgICBjYyA9IGNyb3NzQ291bnQoZyk7XG4gICAgICBpZiAoY2MgPCBjdXJyZW50QmVzdENDKSB7XG4gICAgICAgIGxhc3RCZXN0ID0gMDtcbiAgICAgICAgY3VycmVudEJlc3RDQyA9IGNjO1xuICAgICAgICBpZiAoY2MgPCBhbGxUaW1lQmVzdENDKSB7XG4gICAgICAgICAgc2F2ZUFsbFRpbWVCZXN0KCk7XG4gICAgICAgICAgYWxsVGltZUJlc3RDQyA9IGNjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1dGlsLmxvZygzLCAnT3JkZXIgcGhhc2Ugc3RhcnQgJyArIGogKyAnIGl0ZXIgJyArIGkgKyAnIGNyb3NzIGNvdW50OiAnICsgY2MpO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGFsbFRpbWVCZXN0KS5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICBpZiAoIWcuY2hpbGRyZW4gfHwgIWcuY2hpbGRyZW4odSkubGVuZ3RoKSB7XG4gICAgICBnLm5vZGUodSkub3JkZXIgPSBhbGxUaW1lQmVzdFt1XTtcbiAgICB9XG4gIH0pO1xuICBnLmdyYXBoKCkub3JkZXJDQyA9IGFsbFRpbWVCZXN0Q0M7XG5cbiAgdXRpbC5sb2coMiwgJ09yZGVyIGl0ZXJhdGlvbnM6ICcgKyBpdGVycyk7XG4gIHV0aWwubG9nKDIsICdPcmRlciBwaGFzZSBiZXN0IGNyb3NzIGNvdW50OiAnICsgZy5ncmFwaCgpLm9yZGVyQ0MpO1xufVxuXG5mdW5jdGlvbiBwcmVkZWNlc3NvcldlaWdodHMoZywgbm9kZXMpIHtcbiAgdmFyIHdlaWdodHMgPSB7fTtcbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbih1KSB7XG4gICAgd2VpZ2h0c1t1XSA9IGcuaW5FZGdlcyh1KS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGcubm9kZShnLnNvdXJjZShlKSkub3JkZXI7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gd2VpZ2h0cztcbn1cblxuZnVuY3Rpb24gc3VjY2Vzc29yV2VpZ2h0cyhnLCBub2Rlcykge1xuICB2YXIgd2VpZ2h0cyA9IHt9O1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICB3ZWlnaHRzW3VdID0gZy5vdXRFZGdlcyh1KS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGcubm9kZShnLnRhcmdldChlKSkub3JkZXI7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gd2VpZ2h0cztcbn1cblxuZnVuY3Rpb24gc3dlZXAoZywgbGF5ZXJHcmFwaHMsIGl0ZXIpIHtcbiAgaWYgKGl0ZXIgJSAyID09PSAwKSB7XG4gICAgc3dlZXBEb3duKGcsIGxheWVyR3JhcGhzLCBpdGVyKTtcbiAgfSBlbHNlIHtcbiAgICBzd2VlcFVwKGcsIGxheWVyR3JhcGhzLCBpdGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzd2VlcERvd24oZywgbGF5ZXJHcmFwaHMpIHtcbiAgdmFyIGNnO1xuICBmb3IgKGkgPSAxOyBpIDwgbGF5ZXJHcmFwaHMubGVuZ3RoOyArK2kpIHtcbiAgICBjZyA9IHNvcnRMYXllcihsYXllckdyYXBoc1tpXSwgY2csIHByZWRlY2Vzc29yV2VpZ2h0cyhnLCBsYXllckdyYXBoc1tpXS5ub2RlcygpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3dlZXBVcChnLCBsYXllckdyYXBocykge1xuICB2YXIgY2c7XG4gIGZvciAoaSA9IGxheWVyR3JhcGhzLmxlbmd0aCAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgc29ydExheWVyKGxheWVyR3JhcGhzW2ldLCBjZywgc3VjY2Vzc29yV2VpZ2h0cyhnLCBsYXllckdyYXBoc1tpXS5ub2RlcygpKSk7XG4gIH1cbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyb3NzQ291bnQ7XG5cbi8qXG4gKiBSZXR1cm5zIHRoZSBjcm9zcyBjb3VudCBmb3IgdGhlIGdpdmVuIGdyYXBoLlxuICovXG5mdW5jdGlvbiBjcm9zc0NvdW50KGcpIHtcbiAgdmFyIGNjID0gMDtcbiAgdmFyIG9yZGVyaW5nID0gdXRpbC5vcmRlcmluZyhnKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgIGNjICs9IHR3b0xheWVyQ3Jvc3NDb3VudChnLCBvcmRlcmluZ1tpLTFdLCBvcmRlcmluZ1tpXSk7XG4gIH1cbiAgcmV0dXJuIGNjO1xufVxuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBzZWFyY2hlcyB0aHJvdWdoIGEgcmFua2VkIGFuZCBvcmRlcmVkIGdyYXBoIGFuZCBjb3VudHMgdGhlXG4gKiBudW1iZXIgb2YgZWRnZXMgdGhhdCBjcm9zcy4gVGhpcyBhbGdvcml0aG0gaXMgZGVyaXZlZCBmcm9tOlxuICpcbiAqICAgIFcuIEJhcnRoIGV0IGFsLiwgQmlsYXllciBDcm9zcyBDb3VudGluZywgSkdBQSwgOCgyKSAxNznigJMxOTQgKDIwMDQpXG4gKi9cbmZ1bmN0aW9uIHR3b0xheWVyQ3Jvc3NDb3VudChnLCBsYXllcjEsIGxheWVyMikge1xuICB2YXIgaW5kaWNlcyA9IFtdO1xuICBsYXllcjEuZm9yRWFjaChmdW5jdGlvbih1KSB7XG4gICAgdmFyIG5vZGVJbmRpY2VzID0gW107XG4gICAgZy5vdXRFZGdlcyh1KS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHsgbm9kZUluZGljZXMucHVzaChnLm5vZGUoZy50YXJnZXQoZSkpLm9yZGVyKTsgfSk7XG4gICAgbm9kZUluZGljZXMuc29ydChmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4IC0geTsgfSk7XG4gICAgaW5kaWNlcyA9IGluZGljZXMuY29uY2F0KG5vZGVJbmRpY2VzKTtcbiAgfSk7XG5cbiAgdmFyIGZpcnN0SW5kZXggPSAxO1xuICB3aGlsZSAoZmlyc3RJbmRleCA8IGxheWVyMi5sZW5ndGgpIGZpcnN0SW5kZXggPDw9IDE7XG5cbiAgdmFyIHRyZWVTaXplID0gMiAqIGZpcnN0SW5kZXggLSAxO1xuICBmaXJzdEluZGV4IC09IDE7XG5cbiAgdmFyIHRyZWUgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlU2l6ZTsgKytpKSB7IHRyZWVbaV0gPSAwOyB9XG5cbiAgdmFyIGNjID0gMDtcbiAgaW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgdHJlZUluZGV4ID0gaSArIGZpcnN0SW5kZXg7XG4gICAgKyt0cmVlW3RyZWVJbmRleF07XG4gICAgd2hpbGUgKHRyZWVJbmRleCA+IDApIHtcbiAgICAgIGlmICh0cmVlSW5kZXggJSAyKSB7XG4gICAgICAgIGNjICs9IHRyZWVbdHJlZUluZGV4ICsgMV07XG4gICAgICB9XG4gICAgICB0cmVlSW5kZXggPSAodHJlZUluZGV4IC0gMSkgPj4gMTtcbiAgICAgICsrdHJlZVt0cmVlSW5kZXhdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNjO1xufVxuIiwidmFyIG5vZGVzRnJvbUxpc3QgPSByZXF1aXJlKCdncmFwaGxpYicpLmZpbHRlci5ub2Rlc0Zyb21MaXN0LFxuICAgIC8qIGpzaGludCAtVzA3OSAqL1xuICAgIFNldCA9IHJlcXVpcmUoJ2NwLWRhdGEnKS5TZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdExheWVyR3JhcGhzO1xuXG4vKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGNvbXBvdW5kIGxheWVyZWQgZ3JhcGgsIGcsIGFuZCBwcm9kdWNlcyBhbiBhcnJheSBvZlxuICogbGF5ZXIgZ3JhcGhzLiBFYWNoIGVudHJ5IGluIHRoZSBhcnJheSByZXByZXNlbnRzIGEgc3ViZ3JhcGggb2Ygbm9kZXNcbiAqIHJlbGV2YW50IGZvciBwZXJmb3JtaW5nIGNyb3NzaW5nIHJlZHVjdGlvbiBvbiB0aGF0IGxheWVyLlxuICovXG5mdW5jdGlvbiBpbml0TGF5ZXJHcmFwaHMoZykge1xuICB2YXIgcmFua3MgPSBbXTtcblxuICBmdW5jdGlvbiBkZnModSkge1xuICAgIGlmICh1ID09PSBudWxsKSB7XG4gICAgICBnLmNoaWxkcmVuKHUpLmZvckVhY2goZnVuY3Rpb24odikgeyBkZnModik7IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGcubm9kZSh1KTtcbiAgICB2YWx1ZS5taW5SYW5rID0gKCdyYW5rJyBpbiB2YWx1ZSkgPyB2YWx1ZS5yYW5rIDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YWx1ZS5tYXhSYW5rID0gKCdyYW5rJyBpbiB2YWx1ZSkgPyB2YWx1ZS5yYW5rIDogTnVtYmVyLk1JTl9WQUxVRTtcbiAgICB2YXIgdVJhbmtzID0gbmV3IFNldCgpO1xuICAgIGcuY2hpbGRyZW4odSkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgcnMgPSBkZnModik7XG4gICAgICB1UmFua3MgPSBTZXQudW5pb24oW3VSYW5rcywgcnNdKTtcbiAgICAgIHZhbHVlLm1pblJhbmsgPSBNYXRoLm1pbih2YWx1ZS5taW5SYW5rLCBnLm5vZGUodikubWluUmFuayk7XG4gICAgICB2YWx1ZS5tYXhSYW5rID0gTWF0aC5tYXgodmFsdWUubWF4UmFuaywgZy5ub2RlKHYpLm1heFJhbmspO1xuICAgIH0pO1xuXG4gICAgaWYgKCdyYW5rJyBpbiB2YWx1ZSkgdVJhbmtzLmFkZCh2YWx1ZS5yYW5rKTtcblxuICAgIHVSYW5rcy5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBpZiAoIShyIGluIHJhbmtzKSkgcmFua3Nbcl0gPSBbXTtcbiAgICAgIHJhbmtzW3JdLnB1c2godSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdVJhbmtzO1xuICB9XG4gIGRmcyhudWxsKTtcblxuICB2YXIgbGF5ZXJHcmFwaHMgPSBbXTtcbiAgcmFua3MuZm9yRWFjaChmdW5jdGlvbih1cywgcmFuaykge1xuICAgIGxheWVyR3JhcGhzW3JhbmtdID0gZy5maWx0ZXJOb2Rlcyhub2Rlc0Zyb21MaXN0KHVzKSk7XG4gIH0pO1xuXG4gIHJldHVybiBsYXllckdyYXBocztcbn1cbiIsInZhciBjcm9zc0NvdW50ID0gcmVxdWlyZSgnLi9jcm9zc0NvdW50JyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbml0T3JkZXI7XG5cbi8qXG4gKiBHaXZlbiBhIGdyYXBoIHdpdGggYSBzZXQgb2YgbGF5ZXJlZCBub2RlcyAoaS5lLiBub2RlcyB0aGF0IGhhdmUgYSBgcmFua2BcbiAqIGF0dHJpYnV0ZSkgdGhpcyBmdW5jdGlvbiBhdHRhY2hlcyBhbiBgb3JkZXJgIGF0dHJpYnV0ZSB0aGF0IHVuaXF1ZWx5XG4gKiBhcnJhbmdlcyBlYWNoIG5vZGUgb2YgZWFjaCByYW5rLiBJZiBubyBjb25zdHJhaW50IGdyYXBoIGlzIHByb3ZpZGVkIHRoZVxuICogb3JkZXIgb2YgdGhlIG5vZGVzIGluIGVhY2ggcmFuayBpcyBlbnRpcmVseSBhcmJpdHJhcnkuXG4gKi9cbmZ1bmN0aW9uIGluaXRPcmRlcihnLCByYW5kb20pIHtcbiAgdmFyIGxheWVycyA9IFtdO1xuXG4gIGcuZWFjaE5vZGUoZnVuY3Rpb24odSwgdmFsdWUpIHtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbdmFsdWUucmFua107XG4gICAgaWYgKGcuY2hpbGRyZW4gJiYgZy5jaGlsZHJlbih1KS5sZW5ndGggPiAwKSByZXR1cm47XG4gICAgaWYgKCFsYXllcikge1xuICAgICAgbGF5ZXIgPSBsYXllcnNbdmFsdWUucmFua10gPSBbXTtcbiAgICB9XG4gICAgbGF5ZXIucHVzaCh1KTtcbiAgfSk7XG5cbiAgbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICBpZiAocmFuZG9tKSB7XG4gICAgICB1dGlsLnNodWZmbGUobGF5ZXIpO1xuICAgIH1cbiAgICBsYXllci5mb3JFYWNoKGZ1bmN0aW9uKHUsIGkpIHtcbiAgICAgIGcubm9kZSh1KS5vcmRlciA9IGk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciBjYyA9IGNyb3NzQ291bnQoZyk7XG4gIGcuZ3JhcGgoKS5vcmRlckluaXRDQyA9IGNjO1xuICBnLmdyYXBoKCkub3JkZXJDQyA9IE51bWJlci5NQVhfVkFMVUU7XG59XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbi8qXG4gICAgRGlncmFwaCA9IHJlcXVpcmUoJ2dyYXBobGliJykuRGlncmFwaCxcbiAgICB0b3Bzb3J0ID0gcmVxdWlyZSgnZ3JhcGhsaWInKS5hbGcudG9wc29ydCxcbiAgICBub2Rlc0Zyb21MaXN0ID0gcmVxdWlyZSgnZ3JhcGhsaWInKS5maWx0ZXIubm9kZXNGcm9tTGlzdDtcbiovXG5cbm1vZHVsZS5leHBvcnRzID0gc29ydExheWVyO1xuXG4vKlxuZnVuY3Rpb24gc29ydExheWVyKGcsIGNnLCB3ZWlnaHRzKSB7XG4gIHZhciByZXN1bHQgPSBzb3J0TGF5ZXJTdWJncmFwaChnLCBudWxsLCBjZywgd2VpZ2h0cyk7XG4gIHJlc3VsdC5saXN0LmZvckVhY2goZnVuY3Rpb24odSwgaSkge1xuICAgIGcubm9kZSh1KS5vcmRlciA9IGk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0LmNvbnN0cmFpbnRHcmFwaDtcbn1cbiovXG5cbmZ1bmN0aW9uIHNvcnRMYXllcihnLCBjZywgd2VpZ2h0cykge1xuICB2YXIgb3JkZXJpbmcgPSBbXTtcbiAgdmFyIGJzID0ge307XG4gIGcuZWFjaE5vZGUoZnVuY3Rpb24odSwgdmFsdWUpIHtcbiAgICBvcmRlcmluZ1t2YWx1ZS5vcmRlcl0gPSB1O1xuICAgIHZhciB3cyA9IHdlaWdodHNbdV07XG4gICAgaWYgKHdzLmxlbmd0aCkge1xuICAgICAgYnNbdV0gPSB1dGlsLnN1bSh3cykgLyB3cy5sZW5ndGg7XG4gICAgfVxuICB9KTtcblxuICB2YXIgdG9Tb3J0ID0gZy5ub2RlcygpLmZpbHRlcihmdW5jdGlvbih1KSB7IHJldHVybiBic1t1XSAhPT0gdW5kZWZpbmVkOyB9KTtcbiAgdG9Tb3J0LnNvcnQoZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBic1t4XSAtIGJzW3ldIHx8IGcubm9kZSh4KS5vcmRlciAtIGcubm9kZSh5KS5vcmRlcjtcbiAgfSk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSAwLCBqbCA9IHRvU29ydC5sZW5ndGg7IGogPCBqbDsgKytpKSB7XG4gICAgaWYgKGJzW29yZGVyaW5nW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBnLm5vZGUodG9Tb3J0W2orK10pLm9yZGVyID0gaTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVE9PRDogcmUtZW5hYmxlIGNvbnN0cmFpbmVkIHNvcnRpbmcgb25jZSB3ZSBoYXZlIGEgc3RyYXRlZ3kgZm9yIGhhbmRsaW5nXG4vLyB1bmRlZmluZWQgYmFyeWNlbnRlcnMuXG4vKlxuZnVuY3Rpb24gc29ydExheWVyU3ViZ3JhcGgoZywgc2csIGNnLCB3ZWlnaHRzKSB7XG4gIGNnID0gY2cgPyBjZy5maWx0ZXJOb2Rlcyhub2Rlc0Zyb21MaXN0KGcuY2hpbGRyZW4oc2cpKSkgOiBuZXcgRGlncmFwaCgpO1xuXG4gIHZhciBub2RlRGF0YSA9IHt9O1xuICBnLmNoaWxkcmVuKHNnKS5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICBpZiAoZy5jaGlsZHJlbih1KS5sZW5ndGgpIHtcbiAgICAgIG5vZGVEYXRhW3VdID0gc29ydExheWVyU3ViZ3JhcGgoZywgdSwgY2csIHdlaWdodHMpO1xuICAgICAgbm9kZURhdGFbdV0uZmlyc3RTRyA9IHU7XG4gICAgICBub2RlRGF0YVt1XS5sYXN0U0cgPSB1O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgd3MgPSB3ZWlnaHRzW3VdO1xuICAgICAgbm9kZURhdGFbdV0gPSB7XG4gICAgICAgIGRlZ3JlZTogd3MubGVuZ3RoLFxuICAgICAgICBiYXJ5Y2VudGVyOiB3cy5sZW5ndGggPiAwID8gdXRpbC5zdW0od3MpIC8gd3MubGVuZ3RoIDogMCxcbiAgICAgICAgbGlzdDogW3VdXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgcmVzb2x2ZVZpb2xhdGVkQ29uc3RyYWludHMoZywgY2csIG5vZGVEYXRhKTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGVEYXRhKTtcbiAga2V5cy5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gbm9kZURhdGFbeF0uYmFyeWNlbnRlciAtIG5vZGVEYXRhW3ldLmJhcnljZW50ZXI7XG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSAga2V5cy5tYXAoZnVuY3Rpb24odSkgeyByZXR1cm4gbm9kZURhdGFbdV07IH0pXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24obGhzLCByaHMpIHsgcmV0dXJuIG1lcmdlTm9kZURhdGEoZywgbGhzLCByaHMpOyB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLypcbmZ1bmN0aW9uIG1lcmdlTm9kZURhdGEoZywgbGhzLCByaHMpIHtcbiAgdmFyIGNnID0gbWVyZ2VEaWdyYXBocyhsaHMuY29uc3RyYWludEdyYXBoLCByaHMuY29uc3RyYWludEdyYXBoKTtcblxuICBpZiAobGhzLmxhc3RTRyAhPT0gdW5kZWZpbmVkICYmIHJocy5maXJzdFNHICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoY2cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2cgPSBuZXcgRGlncmFwaCgpO1xuICAgIH1cbiAgICBpZiAoIWNnLmhhc05vZGUobGhzLmxhc3RTRykpIHsgY2cuYWRkTm9kZShsaHMubGFzdFNHKTsgfVxuICAgIGNnLmFkZE5vZGUocmhzLmZpcnN0U0cpO1xuICAgIGNnLmFkZEVkZ2UobnVsbCwgbGhzLmxhc3RTRywgcmhzLmZpcnN0U0cpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkZWdyZWU6IGxocy5kZWdyZWUgKyByaHMuZGVncmVlLFxuICAgIGJhcnljZW50ZXI6IChsaHMuYmFyeWNlbnRlciAqIGxocy5kZWdyZWUgKyByaHMuYmFyeWNlbnRlciAqIHJocy5kZWdyZWUpIC9cbiAgICAgICAgICAgICAgICAobGhzLmRlZ3JlZSArIHJocy5kZWdyZWUpLFxuICAgIGxpc3Q6IGxocy5saXN0LmNvbmNhdChyaHMubGlzdCksXG4gICAgZmlyc3RTRzogbGhzLmZpcnN0U0cgIT09IHVuZGVmaW5lZCA/IGxocy5maXJzdFNHIDogcmhzLmZpcnN0U0csXG4gICAgbGFzdFNHOiByaHMubGFzdFNHICE9PSB1bmRlZmluZWQgPyByaHMubGFzdFNHIDogbGhzLmxhc3RTRyxcbiAgICBjb25zdHJhaW50R3JhcGg6IGNnXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGlncmFwaHMobGhzLCByaHMpIHtcbiAgaWYgKGxocyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gcmhzO1xuICBpZiAocmhzID09PSB1bmRlZmluZWQpIHJldHVybiBsaHM7XG5cbiAgbGhzID0gbGhzLmNvcHkoKTtcbiAgcmhzLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbih1KSB7IGxocy5hZGROb2RlKHUpOyB9KTtcbiAgcmhzLmVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbihlLCB1LCB2KSB7IGxocy5hZGRFZGdlKG51bGwsIHUsIHYpOyB9KTtcbiAgcmV0dXJuIGxocztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVZpb2xhdGVkQ29uc3RyYWludHMoZywgY2csIG5vZGVEYXRhKSB7XG4gIC8vIFJlbW92ZXMgbm9kZXMgYHVgIGFuZCBgdmAgZnJvbSBgY2dgIGFuZCBtYWtlcyBhbnkgZWRnZXMgaW5jaWRlbnQgb24gdGhlbVxuICAvLyBpbmNpZGVudCBvbiBgd2AgaW5zdGVhZC5cbiAgZnVuY3Rpb24gY29sbGFwc2VOb2Rlcyh1LCB2LCB3KSB7XG4gICAgLy8gVE9ETyBvcmlnaW5hbCBwYXBlciByZW1vdmVzIHNlbGYgbG9vcHMsIGJ1dCBpdCBpcyBub3Qgb2J2aW91cyB3aGVuIHRoaXMgd291bGQgaGFwcGVuXG4gICAgY2cuaW5FZGdlcyh1KS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIGNnLmRlbEVkZ2UoZSk7XG4gICAgICBjZy5hZGRFZGdlKG51bGwsIGNnLnNvdXJjZShlKSwgdyk7XG4gICAgfSk7XG5cbiAgICBjZy5vdXRFZGdlcyh2KS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIGNnLmRlbEVkZ2UoZSk7XG4gICAgICBjZy5hZGRFZGdlKG51bGwsIHcsIGNnLnRhcmdldChlKSk7XG4gICAgfSk7XG5cbiAgICBjZy5kZWxOb2RlKHUpO1xuICAgIGNnLmRlbE5vZGUodik7XG4gIH1cblxuICB2YXIgdmlvbGF0ZWQ7XG4gIHdoaWxlICgodmlvbGF0ZWQgPSBmaW5kVmlvbGF0ZWRDb25zdHJhaW50KGNnLCBub2RlRGF0YSkpICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gY2cuc291cmNlKHZpb2xhdGVkKSxcbiAgICAgICAgdGFyZ2V0ID0gY2cudGFyZ2V0KHZpb2xhdGVkKTtcblxuICAgIHZhciB2O1xuICAgIHdoaWxlICgodiA9IGNnLmFkZE5vZGUobnVsbCkpICYmIGcuaGFzTm9kZSh2KSkge1xuICAgICAgY2cuZGVsTm9kZSh2KTtcbiAgICB9XG5cbiAgICAvLyBDb2xsYXBzZSBiYXJ5Y2VudGVyIGFuZCBsaXN0XG4gICAgbm9kZURhdGFbdl0gPSBtZXJnZU5vZGVEYXRhKGcsIG5vZGVEYXRhW3NvdXJjZV0sIG5vZGVEYXRhW3RhcmdldF0pO1xuICAgIGRlbGV0ZSBub2RlRGF0YVtzb3VyY2VdO1xuICAgIGRlbGV0ZSBub2RlRGF0YVt0YXJnZXRdO1xuXG4gICAgY29sbGFwc2VOb2Rlcyhzb3VyY2UsIHRhcmdldCwgdik7XG4gICAgaWYgKGNnLmluY2lkZW50RWRnZXModikubGVuZ3RoID09PSAwKSB7IGNnLmRlbE5vZGUodik7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kVmlvbGF0ZWRDb25zdHJhaW50KGNnLCBub2RlRGF0YSkge1xuICB2YXIgdXMgPSB0b3Bzb3J0KGNnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciB1ID0gdXNbaV07XG4gICAgdmFyIGluRWRnZXMgPSBjZy5pbkVkZ2VzKHUpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5FZGdlcy5sZW5ndGg7ICsraikge1xuICAgICAgdmFyIGUgPSBpbkVkZ2VzW2pdO1xuICAgICAgaWYgKG5vZGVEYXRhW2NnLnNvdXJjZShlKV0uYmFyeWNlbnRlciA+PSBub2RlRGF0YVt1XS5iYXJ5Y2VudGVyKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuKi9cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qXG4gKiBUaGUgYWxnb3JpdGhtcyBoZXJlIGFyZSBiYXNlZCBvbiBCcmFuZGVzIGFuZCBLw7ZwZiwgXCJGYXN0IGFuZCBTaW1wbGVcbiAqIEhvcml6b250YWwgQ29vcmRpbmF0ZSBBc3NpZ25tZW50XCIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIC8vIEV4dGVybmFsIGNvbmZpZ3VyYXRpb25cbiAgdmFyIGNvbmZpZyA9IHtcbiAgICBub2RlU2VwOiA1MCxcbiAgICBlZGdlU2VwOiAxMCxcbiAgICB1bml2ZXJzYWxTZXA6IG51bGwsXG4gICAgcmFua1NlcDogMzBcbiAgfTtcblxuICB2YXIgc2VsZiA9IHt9O1xuXG4gIHNlbGYubm9kZVNlcCA9IHV0aWwucHJvcGVydHlBY2Nlc3NvcihzZWxmLCBjb25maWcsICdub2RlU2VwJyk7XG4gIHNlbGYuZWRnZVNlcCA9IHV0aWwucHJvcGVydHlBY2Nlc3NvcihzZWxmLCBjb25maWcsICdlZGdlU2VwJyk7XG4gIC8vIElmIG5vdCBudWxsIHRoaXMgc2VwYXJhdGlvbiB2YWx1ZSBpcyB1c2VkIGZvciBhbGwgbm9kZXMgYW5kIGVkZ2VzXG4gIC8vIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgd2lkdGhzLiBgbm9kZVNlcGAgYW5kIGBlZGdlU2VwYCBhcmUgaWdub3JlZCB3aXRoIHRoaXNcbiAgLy8gb3B0aW9uLlxuICBzZWxmLnVuaXZlcnNhbFNlcCA9IHV0aWwucHJvcGVydHlBY2Nlc3NvcihzZWxmLCBjb25maWcsICd1bml2ZXJzYWxTZXAnKTtcbiAgc2VsZi5yYW5rU2VwID0gdXRpbC5wcm9wZXJ0eUFjY2Vzc29yKHNlbGYsIGNvbmZpZywgJ3JhbmtTZXAnKTtcbiAgc2VsZi5kZWJ1Z0xldmVsID0gdXRpbC5wcm9wZXJ0eUFjY2Vzc29yKHNlbGYsIGNvbmZpZywgJ2RlYnVnTGV2ZWwnKTtcblxuICBzZWxmLnJ1biA9IHJ1bjtcblxuICByZXR1cm4gc2VsZjtcblxuICBmdW5jdGlvbiBydW4oZykge1xuICAgIGcgPSBnLmZpbHRlck5vZGVzKHV0aWwuZmlsdGVyTm9uU3ViZ3JhcGhzKGcpKTtcblxuICAgIHZhciBsYXllcmluZyA9IHV0aWwub3JkZXJpbmcoZyk7XG5cbiAgICB2YXIgY29uZmxpY3RzID0gZmluZENvbmZsaWN0cyhnLCBsYXllcmluZyk7XG5cbiAgICB2YXIgeHNzID0ge307XG4gICAgWyd1JywgJ2QnXS5mb3JFYWNoKGZ1bmN0aW9uKHZlcnREaXIpIHtcbiAgICAgIGlmICh2ZXJ0RGlyID09PSAnZCcpIGxheWVyaW5nLnJldmVyc2UoKTtcblxuICAgICAgWydsJywgJ3InXS5mb3JFYWNoKGZ1bmN0aW9uKGhvcml6RGlyKSB7XG4gICAgICAgIGlmIChob3JpekRpciA9PT0gJ3InKSByZXZlcnNlSW5uZXJPcmRlcihsYXllcmluZyk7XG5cbiAgICAgICAgdmFyIGRpciA9IHZlcnREaXIgKyBob3JpekRpcjtcbiAgICAgICAgdmFyIGFsaWduID0gdmVydGljYWxBbGlnbm1lbnQoZywgbGF5ZXJpbmcsIGNvbmZsaWN0cywgdmVydERpciA9PT0gJ3UnID8gJ3ByZWRlY2Vzc29ycycgOiAnc3VjY2Vzc29ycycpO1xuICAgICAgICB4c3NbZGlyXT0gaG9yaXpvbnRhbENvbXBhY3Rpb24oZywgbGF5ZXJpbmcsIGFsaWduLnBvcywgYWxpZ24ucm9vdCwgYWxpZ24uYWxpZ24pO1xuXG4gICAgICAgIGlmIChjb25maWcuZGVidWdMZXZlbCA+PSAzKVxuICAgICAgICAgIGRlYnVnUG9zaXRpb25pbmcodmVydERpciArIGhvcml6RGlyLCBnLCBsYXllcmluZywgeHNzW2Rpcl0pO1xuXG4gICAgICAgIGlmIChob3JpekRpciA9PT0gJ3InKSBmbGlwSG9yaXpvbnRhbGx5KHhzc1tkaXJdKTtcblxuICAgICAgICBpZiAoaG9yaXpEaXIgPT09ICdyJykgcmV2ZXJzZUlubmVyT3JkZXIobGF5ZXJpbmcpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh2ZXJ0RGlyID09PSAnZCcpIGxheWVyaW5nLnJldmVyc2UoKTtcbiAgICB9KTtcblxuICAgIGJhbGFuY2UoZywgbGF5ZXJpbmcsIHhzcyk7XG5cbiAgICBnLmVhY2hOb2RlKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciB4cyA9IFtdO1xuICAgICAgZm9yICh2YXIgYWxpZ25tZW50IGluIHhzcykge1xuICAgICAgICB2YXIgYWxpZ25tZW50WCA9IHhzc1thbGlnbm1lbnRdW3ZdO1xuICAgICAgICBwb3NYRGVidWcoYWxpZ25tZW50LCBnLCB2LCBhbGlnbm1lbnRYKTtcbiAgICAgICAgeHMucHVzaChhbGlnbm1lbnRYKTtcbiAgICAgIH1cbiAgICAgIHhzLnNvcnQoZnVuY3Rpb24oeCwgeSkgeyByZXR1cm4geCAtIHk7IH0pO1xuICAgICAgcG9zWChnLCB2LCAoeHNbMV0gKyB4c1syXSkgLyAyKTtcbiAgICB9KTtcblxuICAgIC8vIEFsaWduIHkgY29vcmRpbmF0ZXMgd2l0aCByYW5rc1xuICAgIHZhciB5ID0gMCwgcmV2ZXJzZVkgPSBnLmdyYXBoKCkucmFua0RpciA9PT0gJ0JUJyB8fCBnLmdyYXBoKCkucmFua0RpciA9PT0gJ1JMJztcbiAgICBsYXllcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gdXRpbC5tYXgobGF5ZXIubWFwKGZ1bmN0aW9uKHUpIHsgcmV0dXJuIGhlaWdodChnLCB1KTsgfSkpO1xuICAgICAgeSArPSBtYXhIZWlnaHQgLyAyO1xuICAgICAgbGF5ZXIuZm9yRWFjaChmdW5jdGlvbih1KSB7XG4gICAgICAgIHBvc1koZywgdSwgcmV2ZXJzZVkgPyAteSA6IHkpO1xuICAgICAgfSk7XG4gICAgICB5ICs9IG1heEhlaWdodCAvIDIgKyBjb25maWcucmFua1NlcDtcbiAgICB9KTtcblxuICAgIC8vIFRyYW5zbGF0ZSBsYXlvdXQgc28gdGhhdCB0b3AgbGVmdCBjb3JuZXIgb2YgYm91bmRpbmcgcmVjdGFuZ2xlIGhhc1xuICAgIC8vIGNvb3JkaW5hdGUgKDAsIDApLlxuICAgIHZhciBtaW5YID0gdXRpbC5taW4oZy5ub2RlcygpLm1hcChmdW5jdGlvbih1KSB7IHJldHVybiBwb3NYKGcsIHUpIC0gd2lkdGgoZywgdSkgLyAyOyB9KSk7XG4gICAgdmFyIG1pblkgPSB1dGlsLm1pbihnLm5vZGVzKCkubWFwKGZ1bmN0aW9uKHUpIHsgcmV0dXJuIHBvc1koZywgdSkgLSBoZWlnaHQoZywgdSkgLyAyOyB9KSk7XG4gICAgZy5lYWNoTm9kZShmdW5jdGlvbih1KSB7XG4gICAgICBwb3NYKGcsIHUsIHBvc1goZywgdSkgLSBtaW5YKTtcbiAgICAgIHBvc1koZywgdSwgcG9zWShnLCB1KSAtIG1pblkpO1xuICAgIH0pO1xuICB9XG5cbiAgLypcbiAgICogR2VuZXJhdGUgYW4gSUQgdGhhdCBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYW55IHVuZGlyZWN0ZWQgZWRnZSB0aGF0IGlzXG4gICAqIGluY2lkZW50IG9uIGB1YCBhbmQgYHZgLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5kaXJFZGdlSWQodSwgdikge1xuICAgIHJldHVybiB1IDwgdlxuICAgICAgPyB1LnRvU3RyaW5nKCkubGVuZ3RoICsgJzonICsgdSArICctJyArIHZcbiAgICAgIDogdi50b1N0cmluZygpLmxlbmd0aCArICc6JyArIHYgKyAnLScgKyB1O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZENvbmZsaWN0cyhnLCBsYXllcmluZykge1xuICAgIHZhciBjb25mbGljdHMgPSB7fSwgLy8gU2V0IG9mIGNvbmZsaWN0aW5nIGVkZ2UgaWRzXG4gICAgICAgIHBvcyA9IHt9LCAgICAgICAvLyBQb3NpdGlvbiBvZiBub2RlIGluIGl0cyBsYXllclxuICAgICAgICBwcmV2TGF5ZXIsXG4gICAgICAgIGN1cnJMYXllcixcbiAgICAgICAgazAsICAgICAvLyBQb3NpdGlvbiBvZiB0aGUgbGFzdCBpbm5lciBzZWdtZW50IGluIHRoZSBwcmV2aW91cyBsYXllclxuICAgICAgICBsLCAgICAgIC8vIEN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnQgbGF5ZXIgKGZvciBpdGVyYXRpb24gdXAgdG8gYGwxYClcbiAgICAgICAgazE7ICAgICAvLyBQb3NpdGlvbiBvZiB0aGUgbmV4dCBpbm5lciBzZWdtZW50IGluIHRoZSBwcmV2aW91cyBsYXllciBvclxuICAgICAgICAgICAgICAgIC8vIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBwcmV2aW91cyBsYXllclxuXG4gICAgaWYgKGxheWVyaW5nLmxlbmd0aCA8PSAyKSByZXR1cm4gY29uZmxpY3RzO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ29uZmxpY3RzKHYpIHtcbiAgICAgIHZhciBrID0gcG9zW3ZdO1xuICAgICAgaWYgKGsgPCBrMCB8fCBrID4gazEpIHtcbiAgICAgICAgY29uZmxpY3RzW3VuZGlyRWRnZUlkKGN1cnJMYXllcltsXSwgdildID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXllcmluZ1sxXS5mb3JFYWNoKGZ1bmN0aW9uKHUsIGkpIHsgcG9zW3VdID0gaTsgfSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYXllcmluZy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIHByZXZMYXllciA9IGxheWVyaW5nW2ldO1xuICAgICAgY3VyckxheWVyID0gbGF5ZXJpbmdbaSsxXTtcbiAgICAgIGswID0gMDtcbiAgICAgIGwgPSAwO1xuXG4gICAgICAvLyBTY2FuIGN1cnJlbnQgbGF5ZXIgZm9yIG5leHQgbm9kZSB0aGF0IGlzIGluY2lkZW50IHRvIGFuIGlubmVyIHNlZ2VtZW50XG4gICAgICAvLyBiZXR3ZWVuIGxheWVyaW5nW2krMV0gYW5kIGxheWVyaW5nW2ldLlxuICAgICAgZm9yICh2YXIgbDEgPSAwOyBsMSA8IGN1cnJMYXllci5sZW5ndGg7ICsrbDEpIHtcbiAgICAgICAgdmFyIHUgPSBjdXJyTGF5ZXJbbDFdOyAvLyBOZXh0IGlubmVyIHNlZ21lbnQgaW4gdGhlIGN1cnJlbnQgbGF5ZXIgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsYXN0IG5vZGUgaW4gdGhlIGN1cnJlbnQgbGF5ZXJcbiAgICAgICAgcG9zW3VdID0gbDE7XG4gICAgICAgIGsxID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChnLm5vZGUodSkuZHVtbXkpIHtcbiAgICAgICAgICB2YXIgdVByZWQgPSBnLnByZWRlY2Vzc29ycyh1KVswXTtcbiAgICAgICAgICAvLyBOb3RlOiBJbiB0aGUgY2FzZSBvZiBzZWxmIGxvb3BzIGFuZCBzaWRld2F5cyBlZGdlcyBpdCBpcyBwb3NzaWJsZVxuICAgICAgICAgIC8vIGZvciBhIGR1bW15IG5vdCB0byBoYXZlIGEgcHJlZGVjZXNzb3IuXG4gICAgICAgICAgaWYgKHVQcmVkICE9PSB1bmRlZmluZWQgJiYgZy5ub2RlKHVQcmVkKS5kdW1teSlcbiAgICAgICAgICAgIGsxID0gcG9zW3VQcmVkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoazEgPT09IHVuZGVmaW5lZCAmJiBsMSA9PT0gY3VyckxheWVyLmxlbmd0aCAtIDEpXG4gICAgICAgICAgazEgPSBwcmV2TGF5ZXIubGVuZ3RoIC0gMTtcblxuICAgICAgICBpZiAoazEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAoOyBsIDw9IGwxOyArK2wpIHtcbiAgICAgICAgICAgIGcucHJlZGVjZXNzb3JzKGN1cnJMYXllcltsXSkuZm9yRWFjaCh1cGRhdGVDb25mbGljdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrMCA9IGsxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZsaWN0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHZlcnRpY2FsQWxpZ25tZW50KGcsIGxheWVyaW5nLCBjb25mbGljdHMsIHJlbGF0aW9uc2hpcCkge1xuICAgIHZhciBwb3MgPSB7fSwgICAvLyBQb3NpdGlvbiBmb3IgYSBub2RlIGluIGl0cyBsYXllclxuICAgICAgICByb290ID0ge30sICAvLyBSb290IG9mIHRoZSBibG9jayB0aGF0IHRoZSBub2RlIHBhcnRpY2lwYXRlcyBpblxuICAgICAgICBhbGlnbiA9IHt9OyAvLyBQb2ludHMgdG8gdGhlIG5leHQgbm9kZSBpbiB0aGUgYmxvY2sgb3IsIGlmIHRoZSBsYXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaW4gdGhlIGJsb2NrLCBwb2ludHMgdG8gdGhlIGZpcnN0IGJsb2NrJ3Mgcm9vdFxuXG4gICAgbGF5ZXJpbmcuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgbGF5ZXIuZm9yRWFjaChmdW5jdGlvbih1LCBpKSB7XG4gICAgICAgIHJvb3RbdV0gPSB1O1xuICAgICAgICBhbGlnblt1XSA9IHU7XG4gICAgICAgIHBvc1t1XSA9IGk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGxheWVyaW5nLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIHZhciBwcmV2SWR4ID0gLTE7XG4gICAgICBsYXllci5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIHJlbGF0ZWQgPSBnW3JlbGF0aW9uc2hpcF0odiksIC8vIEFkamFjZW50IG5vZGVzIGZyb20gdGhlIHByZXZpb3VzIGxheWVyXG4gICAgICAgICAgICBtaWQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbWlkIHBvaW50IGluIHRoZSByZWxhdGVkIGFycmF5XG5cbiAgICAgICAgaWYgKHJlbGF0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlbGF0ZWQuc29ydChmdW5jdGlvbih4LCB5KSB7IHJldHVybiBwb3NbeF0gLSBwb3NbeV07IH0pO1xuICAgICAgICAgIG1pZCA9IChyZWxhdGVkLmxlbmd0aCAtIDEpIC8gMjtcbiAgICAgICAgICByZWxhdGVkLnNsaWNlKE1hdGguZmxvb3IobWlkKSwgTWF0aC5jZWlsKG1pZCkgKyAxKS5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICAgIGlmIChhbGlnblt2XSA9PT0gdikge1xuICAgICAgICAgICAgICBpZiAoIWNvbmZsaWN0c1t1bmRpckVkZ2VJZCh1LCB2KV0gJiYgcHJldklkeCA8IHBvc1t1XSkge1xuICAgICAgICAgICAgICAgIGFsaWduW3VdID0gdjtcbiAgICAgICAgICAgICAgICBhbGlnblt2XSA9IHJvb3Rbdl0gPSByb290W3VdO1xuICAgICAgICAgICAgICAgIHByZXZJZHggPSBwb3NbdV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBwb3M6IHBvcywgcm9vdDogcm9vdCwgYWxpZ246IGFsaWduIH07XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIGRldmlhdGVzIGZyb20gdGhlIHN0YW5kYXJkIEJLIGFsZ29yaXRobSBpbiB0d28gd2F5cy4gRmlyc3RcbiAgLy8gaXQgdGFrZXMgaW50byBhY2NvdW50IHRoZSBzaXplIG9mIHRoZSBub2Rlcy4gU2Vjb25kIGl0IGluY2x1ZGVzIGEgZml4IHRvXG4gIC8vIHRoZSBvcmlnaW5hbCBhbGdvcml0aG0gdGhhdCBpcyBkZXNjcmliZWQgaW4gQ2Fyc3RlbnMsIFwiTm9kZSBhbmQgTGFiZWxcbiAgLy8gUGxhY2VtZW50IGluIGEgTGF5ZXJlZCBMYXlvdXQgQWxnb3JpdGhtXCIuXG4gIGZ1bmN0aW9uIGhvcml6b250YWxDb21wYWN0aW9uKGcsIGxheWVyaW5nLCBwb3MsIHJvb3QsIGFsaWduKSB7XG4gICAgdmFyIHNpbmsgPSB7fSwgICAgICAgLy8gTWFwcGluZyBvZiBub2RlIGlkIC0+IHNpbmsgbm9kZSBpZCBmb3IgY2xhc3NcbiAgICAgICAgbWF5YmVTaGlmdCA9IHt9LCAvLyBNYXBwaW5nIG9mIHNpbmsgbm9kZSBpZCAtPiB7IGNsYXNzIG5vZGUgaWQsIG1pbiBzaGlmdCB9XG4gICAgICAgIHNoaWZ0ID0ge30sICAgICAgLy8gTWFwcGluZyBvZiBzaW5rIG5vZGUgaWQgLT4gc2hpZnRcbiAgICAgICAgcHJlZCA9IHt9LCAgICAgICAvLyBNYXBwaW5nIG9mIG5vZGUgaWQgLT4gcHJlZGVjZXNzb3Igbm9kZSAob3IgbnVsbClcbiAgICAgICAgeHMgPSB7fTsgICAgICAgICAvLyBDYWxjdWxhdGVkIFggcG9zaXRpb25zXG5cbiAgICBsYXllcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICBsYXllci5mb3JFYWNoKGZ1bmN0aW9uKHUsIGkpIHtcbiAgICAgICAgc2lua1t1XSA9IHU7XG4gICAgICAgIG1heWJlU2hpZnRbdV0gPSB7fTtcbiAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgIHByZWRbdV0gPSBsYXllcltpIC0gMV07XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNoaWZ0KHRvU2hpZnQsIG5laWdoYm9yLCBkZWx0YSkge1xuICAgICAgaWYgKCEobmVpZ2hib3IgaW4gbWF5YmVTaGlmdFt0b1NoaWZ0XSkpIHtcbiAgICAgICAgbWF5YmVTaGlmdFt0b1NoaWZ0XVtuZWlnaGJvcl0gPSBkZWx0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heWJlU2hpZnRbdG9TaGlmdF1bbmVpZ2hib3JdID0gTWF0aC5taW4obWF5YmVTaGlmdFt0b1NoaWZ0XVtuZWlnaGJvcl0sIGRlbHRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwbGFjZUJsb2NrKHYpIHtcbiAgICAgIGlmICghKHYgaW4geHMpKSB7XG4gICAgICAgIHhzW3ZdID0gMDtcbiAgICAgICAgdmFyIHcgPSB2O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHBvc1t3XSA+IDApIHtcbiAgICAgICAgICAgIHZhciB1ID0gcm9vdFtwcmVkW3ddXTtcbiAgICAgICAgICAgIHBsYWNlQmxvY2sodSk7XG4gICAgICAgICAgICBpZiAoc2lua1t2XSA9PT0gdikge1xuICAgICAgICAgICAgICBzaW5rW3ZdID0gc2lua1t1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZWx0YSA9IHNlcChnLCBwcmVkW3ddKSArIHNlcChnLCB3KTtcbiAgICAgICAgICAgIGlmIChzaW5rW3ZdICE9PSBzaW5rW3VdKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZVNoaWZ0KHNpbmtbdV0sIHNpbmtbdl0sIHhzW3ZdIC0geHNbdV0gLSBkZWx0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB4c1t2XSA9IE1hdGgubWF4KHhzW3ZdLCB4c1t1XSArIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdyA9IGFsaWduW3ddO1xuICAgICAgICB9IHdoaWxlICh3ICE9PSB2KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSb290IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHNpbmtcbiAgICB1dGlsLnZhbHVlcyhyb290KS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHBsYWNlQmxvY2sodik7XG4gICAgfSk7XG5cbiAgICAvLyBBYnNvbHV0ZSBjb29yZGluYXRlc1xuICAgIC8vIFRoZXJlIGlzIGFuIGFzc3VtcHRpb24gaGVyZSB0aGF0IHdlJ3ZlIHJlc29sdmVkIHNoaWZ0cyBmb3IgYW55IGNsYXNzZXNcbiAgICAvLyB0aGF0IGJlZ2luIGF0IGFuIGVhcmxpZXIgbGF5ZXIuIFdlIGd1YXJhbnRlZSB0aGlzIGJ5IHZpc2l0aW5nIGxheWVycyBpblxuICAgIC8vIG9yZGVyLlxuICAgIGxheWVyaW5nLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIGxheWVyLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICB4c1t2XSA9IHhzW3Jvb3Rbdl1dO1xuICAgICAgICBpZiAodiA9PT0gcm9vdFt2XSAmJiB2ID09PSBzaW5rW3ZdKSB7XG4gICAgICAgICAgdmFyIG1pblNoaWZ0ID0gMDtcbiAgICAgICAgICBpZiAodiBpbiBtYXliZVNoaWZ0ICYmIE9iamVjdC5rZXlzKG1heWJlU2hpZnRbdl0pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1pblNoaWZ0ID0gdXRpbC5taW4oT2JqZWN0LmtleXMobWF5YmVTaGlmdFt2XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVTaGlmdFt2XVt1XSArICh1IGluIHNoaWZ0ID8gc2hpZnRbdV0gOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNoaWZ0W3ZdID0gbWluU2hpZnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgbGF5ZXJpbmcuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgbGF5ZXIuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIHhzW3ZdICs9IHNoaWZ0W3Npbmtbcm9vdFt2XV1dIHx8IDA7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB4cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRNaW5Db29yZChnLCBsYXllcmluZywgeHMpIHtcbiAgICByZXR1cm4gdXRpbC5taW4obGF5ZXJpbmcubWFwKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICB2YXIgdSA9IGxheWVyWzBdO1xuICAgICAgcmV0dXJuIHhzW3VdO1xuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRNYXhDb29yZChnLCBsYXllcmluZywgeHMpIHtcbiAgICByZXR1cm4gdXRpbC5tYXgobGF5ZXJpbmcubWFwKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICB2YXIgdSA9IGxheWVyW2xheWVyLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHhzW3VdO1xuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhbGFuY2UoZywgbGF5ZXJpbmcsIHhzcykge1xuICAgIHZhciBtaW4gPSB7fSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWluIGNvb3JkaW5hdGUgZm9yIHRoZSBhbGlnbm1lbnRcbiAgICAgICAgbWF4ID0ge30sICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heCBjb29yZGluYXRlIGZvciB0aGUgYWxnaW5tZW50XG4gICAgICAgIHNtYWxsZXN0QWxpZ25tZW50LFxuICAgICAgICBzaGlmdCA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW1vdW50IHRvIHNoaWZ0IGEgZ2l2ZW4gYWxpZ25tZW50XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVBbGlnbm1lbnQodikge1xuICAgICAgeHNzW2FsaWdubWVudF1bdl0gKz0gc2hpZnRbYWxpZ25tZW50XTtcbiAgICB9XG5cbiAgICB2YXIgc21hbGxlc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgZm9yICh2YXIgYWxpZ25tZW50IGluIHhzcykge1xuICAgICAgdmFyIHhzID0geHNzW2FsaWdubWVudF07XG4gICAgICBtaW5bYWxpZ25tZW50XSA9IGZpbmRNaW5Db29yZChnLCBsYXllcmluZywgeHMpO1xuICAgICAgbWF4W2FsaWdubWVudF0gPSBmaW5kTWF4Q29vcmQoZywgbGF5ZXJpbmcsIHhzKTtcbiAgICAgIHZhciB3ID0gbWF4W2FsaWdubWVudF0gLSBtaW5bYWxpZ25tZW50XTtcbiAgICAgIGlmICh3IDwgc21hbGxlc3QpIHtcbiAgICAgICAgc21hbGxlc3QgPSB3O1xuICAgICAgICBzbWFsbGVzdEFsaWdubWVudCA9IGFsaWdubWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgaG93IG11Y2ggdG8gYWRqdXN0IHBvc2l0aW9uaW5nIGZvciBlYWNoIGFsaWdubWVudFxuICAgIFsndScsICdkJ10uZm9yRWFjaChmdW5jdGlvbih2ZXJ0RGlyKSB7XG4gICAgICBbJ2wnLCAnciddLmZvckVhY2goZnVuY3Rpb24oaG9yaXpEaXIpIHtcbiAgICAgICAgdmFyIGFsaWdubWVudCA9IHZlcnREaXIgKyBob3JpekRpcjtcbiAgICAgICAgc2hpZnRbYWxpZ25tZW50XSA9IGhvcml6RGlyID09PSAnbCdcbiAgICAgICAgICAgID8gbWluW3NtYWxsZXN0QWxpZ25tZW50XSAtIG1pblthbGlnbm1lbnRdXG4gICAgICAgICAgICA6IG1heFtzbWFsbGVzdEFsaWdubWVudF0gLSBtYXhbYWxpZ25tZW50XTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gRmluZCBhdmVyYWdlIG9mIG1lZGlhbnMgZm9yIHhzcyBhcnJheVxuICAgIGZvciAoYWxpZ25tZW50IGluIHhzcykge1xuICAgICAgZy5lYWNoTm9kZSh1cGRhdGVBbGlnbm1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsaXBIb3Jpem9udGFsbHkoeHMpIHtcbiAgICBmb3IgKHZhciB1IGluIHhzKSB7XG4gICAgICB4c1t1XSA9IC14c1t1XTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnNlSW5uZXJPcmRlcihsYXllcmluZykge1xuICAgIGxheWVyaW5nLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIGxheWVyLnJldmVyc2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpZHRoKGcsIHUpIHtcbiAgICBzd2l0Y2ggKGcuZ3JhcGgoKS5yYW5rRGlyKSB7XG4gICAgICBjYXNlICdMUic6IHJldHVybiBnLm5vZGUodSkuaGVpZ2h0O1xuICAgICAgY2FzZSAnUkwnOiByZXR1cm4gZy5ub2RlKHUpLmhlaWdodDtcbiAgICAgIGRlZmF1bHQ6ICAgcmV0dXJuIGcubm9kZSh1KS53aWR0aDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoZWlnaHQoZywgdSkge1xuICAgIHN3aXRjaChnLmdyYXBoKCkucmFua0Rpcikge1xuICAgICAgY2FzZSAnTFInOiByZXR1cm4gZy5ub2RlKHUpLndpZHRoO1xuICAgICAgY2FzZSAnUkwnOiByZXR1cm4gZy5ub2RlKHUpLndpZHRoO1xuICAgICAgZGVmYXVsdDogICByZXR1cm4gZy5ub2RlKHUpLmhlaWdodDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXAoZywgdSkge1xuICAgIGlmIChjb25maWcudW5pdmVyc2FsU2VwICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29uZmlnLnVuaXZlcnNhbFNlcDtcbiAgICB9XG4gICAgdmFyIHcgPSB3aWR0aChnLCB1KTtcbiAgICB2YXIgcyA9IGcubm9kZSh1KS5kdW1teSA/IGNvbmZpZy5lZGdlU2VwIDogY29uZmlnLm5vZGVTZXA7XG4gICAgcmV0dXJuICh3ICsgcykgLyAyO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zWChnLCB1LCB4KSB7XG4gICAgaWYgKGcuZ3JhcGgoKS5yYW5rRGlyID09PSAnTFInIHx8IGcuZ3JhcGgoKS5yYW5rRGlyID09PSAnUkwnKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGcubm9kZSh1KS55O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZy5ub2RlKHUpLnkgPSB4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGcubm9kZSh1KS54O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZy5ub2RlKHUpLnggPSB4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc1hEZWJ1ZyhuYW1lLCBnLCB1LCB4KSB7XG4gICAgaWYgKGcuZ3JhcGgoKS5yYW5rRGlyID09PSAnTFInIHx8IGcuZ3JhcGgoKS5yYW5rRGlyID09PSAnUkwnKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGcubm9kZSh1KVtuYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGcubm9kZSh1KVtuYW1lXSA9IHg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gZy5ub2RlKHUpW25hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZy5ub2RlKHUpW25hbWVdID0geDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwb3NZKGcsIHUsIHkpIHtcbiAgICBpZiAoZy5ncmFwaCgpLnJhbmtEaXIgPT09ICdMUicgfHwgZy5ncmFwaCgpLnJhbmtEaXIgPT09ICdSTCcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gZy5ub2RlKHUpLng7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnLm5vZGUodSkueCA9IHk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gZy5ub2RlKHUpLnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnLm5vZGUodSkueSA9IHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVidWdQb3NpdGlvbmluZyhhbGlnbiwgZywgbGF5ZXJpbmcsIHhzKSB7XG4gICAgbGF5ZXJpbmcuZm9yRWFjaChmdW5jdGlvbihsLCBsaSkge1xuICAgICAgdmFyIHUsIHhVO1xuICAgICAgbC5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIHhWID0geHNbdl07XG4gICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgdmFyIHMgPSBzZXAoZywgdSkgKyBzZXAoZywgdik7XG4gICAgICAgICAgaWYgKHhWIC0geFUgPCBzKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Bvc2l0aW9uIHBoYXNlOiBzZXAgdmlvbGF0aW9uLiBBbGlnbjogJyArIGFsaWduICsgJy4gTGF5ZXI6ICcgKyBsaSArICcuICcgK1xuICAgICAgICAgICAgICAnVTogJyArIHUgKyAnIFY6ICcgKyB2ICsgJy4gQWN0dWFsIHNlcDogJyArICh4ViAtIHhVKSArICcgRXhwZWN0ZWQgc2VwOiAnICsgcyk7XG4gICAgICAgIH1cbiAgICAgICAgdSA9IHY7XG4gICAgICAgIHhVID0geFY7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgYWN5Y2xpYyA9IHJlcXVpcmUoJy4vcmFuay9hY3ljbGljJyksXG4gICAgaW5pdFJhbmsgPSByZXF1aXJlKCcuL3JhbmsvaW5pdFJhbmsnKSxcbiAgICBmZWFzaWJsZVRyZWUgPSByZXF1aXJlKCcuL3JhbmsvZmVhc2libGVUcmVlJyksXG4gICAgY29uc3RyYWludHMgPSByZXF1aXJlKCcuL3JhbmsvY29uc3RyYWludHMnKSxcbiAgICBzaW1wbGV4ID0gcmVxdWlyZSgnLi9yYW5rL3NpbXBsZXgnKSxcbiAgICBjb21wb25lbnRzID0gcmVxdWlyZSgnZ3JhcGhsaWInKS5hbGcuY29tcG9uZW50cyxcbiAgICBmaWx0ZXIgPSByZXF1aXJlKCdncmFwaGxpYicpLmZpbHRlcjtcblxuZXhwb3J0cy5ydW4gPSBydW47XG5leHBvcnRzLnJlc3RvcmVFZGdlcyA9IHJlc3RvcmVFZGdlcztcblxuLypcbiAqIEhldXJpc3RpYyBmdW5jdGlvbiB0aGF0IGFzc2lnbnMgYSByYW5rIHRvIGVhY2ggbm9kZSBvZiB0aGUgaW5wdXQgZ3JhcGggd2l0aFxuICogdGhlIGludGVudCBvZiBtaW5pbWl6aW5nIGVkZ2UgbGVuZ3Rocywgd2hpbGUgcmVzcGVjdGluZyB0aGUgYG1pbkxlbmBcbiAqIGF0dHJpYnV0ZSBvZiBpbmNpZGVudCBlZGdlcy5cbiAqXG4gKiBQcmVyZXF1aXNpdGVzOlxuICpcbiAqICAqIEVhY2ggZWRnZSBpbiB0aGUgaW5wdXQgZ3JhcGggbXVzdCBoYXZlIGFuIGFzc2lnbmVkICdtaW5MZW4nIGF0dHJpYnV0ZVxuICovXG5mdW5jdGlvbiBydW4oZywgdXNlU2ltcGxleCkge1xuICBleHBhbmRTZWxmTG9vcHMoZyk7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIHJhbmsgY29uc3RyYWludHMgb24gbm9kZXMsIHRoZW4gYnVpbGQgYSBuZXcgZ3JhcGggdGhhdFxuICAvLyBlbmNvZGVzIHRoZSBjb25zdHJhaW50cy5cbiAgdXRpbC50aW1lKCdjb25zdHJhaW50cy5hcHBseScsIGNvbnN0cmFpbnRzLmFwcGx5KShnKTtcblxuICBleHBhbmRTaWRld2F5c0VkZ2VzKGcpO1xuXG4gIC8vIFJldmVyc2UgZWRnZXMgdG8gZ2V0IGFuIGFjeWNsaWMgZ3JhcGgsIHdlIGtlZXAgdGhlIGdyYXBoIGluIGFuIGFjeWNsaWNcbiAgLy8gc3RhdGUgdW50aWwgdGhlIHZlcnkgZW5kLlxuICB1dGlsLnRpbWUoJ2FjeWNsaWMnLCBhY3ljbGljKShnKTtcblxuICAvLyBDb252ZXJ0IHRoZSBncmFwaCBpbnRvIGEgZmxhdCBncmFwaCBmb3IgcmFua2luZ1xuICB2YXIgZmxhdEdyYXBoID0gZy5maWx0ZXJOb2Rlcyh1dGlsLmZpbHRlck5vblN1YmdyYXBocyhnKSk7XG5cbiAgLy8gQXNzaWduIGFuIGluaXRpYWwgcmFua2luZyB1c2luZyBERlMuXG4gIGluaXRSYW5rKGZsYXRHcmFwaCk7XG5cbiAgLy8gRm9yIGVhY2ggY29tcG9uZW50IGltcHJvdmUgdGhlIGFzc2lnbmVkIHJhbmtzLlxuICBjb21wb25lbnRzKGZsYXRHcmFwaCkuZm9yRWFjaChmdW5jdGlvbihjbXB0KSB7XG4gICAgdmFyIHN1YmdyYXBoID0gZmxhdEdyYXBoLmZpbHRlck5vZGVzKGZpbHRlci5ub2Rlc0Zyb21MaXN0KGNtcHQpKTtcbiAgICByYW5rQ29tcG9uZW50KHN1YmdyYXBoLCB1c2VTaW1wbGV4KTtcbiAgfSk7XG5cbiAgLy8gUmVsYXggb3JpZ2luYWwgY29uc3RyYWludHNcbiAgdXRpbC50aW1lKCdjb25zdHJhaW50cy5yZWxheCcsIGNvbnN0cmFpbnRzLnJlbGF4KGcpKTtcblxuICAvLyBXaGVuIGhhbmRsaW5nIG5vZGVzIHdpdGggY29uc3RyYWluZWQgcmFua3MgaXQgaXMgcG9zc2libGUgdG8gZW5kIHVwIHdpdGhcbiAgLy8gZWRnZXMgdGhhdCBwb2ludCB0byBwcmV2aW91cyByYW5rcy4gTW9zdCBvZiB0aGUgc3Vic2VxdWVudCBhbGdvcml0aG1zIGFzc3VtZVxuICAvLyB0aGF0IGVkZ2VzIGFyZSBwb2ludGluZyB0byBzdWNjZXNzaXZlIHJhbmtzIG9ubHkuIEhlcmUgd2UgcmV2ZXJzZSBhbnkgXCJiYWNrXG4gIC8vIGVkZ2VzXCIgYW5kIG1hcmsgdGhlbSBhcyBzdWNoLiBUaGUgYWN5Y2xpYyBhbGdvcml0aG0gd2lsbCByZXZlcnNlIHRoZW0gYXMgYVxuICAvLyBwb3N0IHByb2Nlc3Npbmcgc3RlcC5cbiAgdXRpbC50aW1lKCdyZW9yaWVudEVkZ2VzJywgcmVvcmllbnRFZGdlcykoZyk7XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVFZGdlcyhnKSB7XG4gIGFjeWNsaWMudW5kbyhnKTtcbn1cblxuLypcbiAqIEV4cGFuZCBzZWxmIGxvb3BzIGludG8gdGhyZWUgZHVtbXkgbm9kZXMuIE9uZSB3aWxsIHNpdCBhYm92ZSB0aGUgaW5jaWRlbnRcbiAqIG5vZGUsIG9uZSB3aWxsIGJlIGF0IHRoZSBzYW1lIGxldmVsLCBhbmQgb25lIGJlbG93LiBUaGUgcmVzdWx0IGxvb2tzIGxpa2U6XG4gKlxuICogICAgICAgICAvLS08LS14LS0tPi0tXFxcbiAqICAgICBub2RlICAgICAgICAgICAgICB5XG4gKiAgICAgICAgIFxcLS08LS16LS0tPi0tL1xuICpcbiAqIER1bW15IG5vZGVzIHgsIHksIHogZ2l2ZSB1cyB0aGUgc2hhcGUgb2YgYSBsb29wIGFuZCBub2RlIHkgaXMgd2hlcmUgd2UgcGxhY2VcbiAqIHRoZSBsYWJlbC5cbiAqXG4gKiBUT0RPOiBjb25zb2xpZGF0ZSBrbm93bGVkZ2Ugb2YgZHVtbXkgbm9kZSBjb25zdHJ1Y3Rpb24uXG4gKiBUT0RPOiBzdXBwb3J0IG1pbkxlbiA9IDJcbiAqL1xuZnVuY3Rpb24gZXhwYW5kU2VsZkxvb3BzKGcpIHtcbiAgZy5lYWNoRWRnZShmdW5jdGlvbihlLCB1LCB2LCBhKSB7XG4gICAgaWYgKHUgPT09IHYpIHtcbiAgICAgIHZhciB4ID0gYWRkRHVtbXlOb2RlKGcsIGUsIHUsIHYsIGEsIDAsIGZhbHNlKSxcbiAgICAgICAgICB5ID0gYWRkRHVtbXlOb2RlKGcsIGUsIHUsIHYsIGEsIDEsIHRydWUpLFxuICAgICAgICAgIHogPSBhZGREdW1teU5vZGUoZywgZSwgdSwgdiwgYSwgMiwgZmFsc2UpO1xuICAgICAgZy5hZGRFZGdlKG51bGwsIHgsIHUsIHttaW5MZW46IDEsIHNlbGZMb29wOiB0cnVlfSk7XG4gICAgICBnLmFkZEVkZ2UobnVsbCwgeCwgeSwge21pbkxlbjogMSwgc2VsZkxvb3A6IHRydWV9KTtcbiAgICAgIGcuYWRkRWRnZShudWxsLCB1LCB6LCB7bWluTGVuOiAxLCBzZWxmTG9vcDogdHJ1ZX0pO1xuICAgICAgZy5hZGRFZGdlKG51bGwsIHksIHosIHttaW5MZW46IDEsIHNlbGZMb29wOiB0cnVlfSk7XG4gICAgICBnLmRlbEVkZ2UoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kU2lkZXdheXNFZGdlcyhnKSB7XG4gIGcuZWFjaEVkZ2UoZnVuY3Rpb24oZSwgdSwgdiwgYSkge1xuICAgIGlmICh1ID09PSB2KSB7XG4gICAgICB2YXIgb3JpZ0VkZ2UgPSBhLm9yaWdpbmFsRWRnZSxcbiAgICAgICAgICBkdW1teSA9IGFkZER1bW15Tm9kZShnLCBvcmlnRWRnZS5lLCBvcmlnRWRnZS51LCBvcmlnRWRnZS52LCBvcmlnRWRnZS52YWx1ZSwgMCwgdHJ1ZSk7XG4gICAgICBnLmFkZEVkZ2UobnVsbCwgdSwgZHVtbXksIHttaW5MZW46IDF9KTtcbiAgICAgIGcuYWRkRWRnZShudWxsLCBkdW1teSwgdiwge21pbkxlbjogMX0pO1xuICAgICAgZy5kZWxFZGdlKGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZER1bW15Tm9kZShnLCBlLCB1LCB2LCBhLCBpbmRleCwgaXNMYWJlbCkge1xuICByZXR1cm4gZy5hZGROb2RlKG51bGwsIHtcbiAgICB3aWR0aDogaXNMYWJlbCA/IGEud2lkdGggOiAwLFxuICAgIGhlaWdodDogaXNMYWJlbCA/IGEuaGVpZ2h0IDogMCxcbiAgICBlZGdlOiB7IGlkOiBlLCBzb3VyY2U6IHUsIHRhcmdldDogdiwgYXR0cnM6IGEgfSxcbiAgICBkdW1teTogdHJ1ZSxcbiAgICBpbmRleDogaW5kZXhcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlb3JpZW50RWRnZXMoZykge1xuICBnLmVhY2hFZGdlKGZ1bmN0aW9uKGUsIHUsIHYsIHZhbHVlKSB7XG4gICAgaWYgKGcubm9kZSh1KS5yYW5rID4gZy5ub2RlKHYpLnJhbmspIHtcbiAgICAgIGcuZGVsRWRnZShlKTtcbiAgICAgIHZhbHVlLnJldmVyc2VkID0gdHJ1ZTtcbiAgICAgIGcuYWRkRWRnZShlLCB2LCB1LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmFua0NvbXBvbmVudChzdWJncmFwaCwgdXNlU2ltcGxleCkge1xuICB2YXIgc3Bhbm5pbmdUcmVlID0gZmVhc2libGVUcmVlKHN1YmdyYXBoKTtcblxuICBpZiAodXNlU2ltcGxleCkge1xuICAgIHV0aWwubG9nKDEsICdVc2luZyBuZXR3b3JrIHNpbXBsZXggZm9yIHJhbmtpbmcnKTtcbiAgICBzaW1wbGV4KHN1YmdyYXBoLCBzcGFubmluZ1RyZWUpO1xuICB9XG4gIG5vcm1hbGl6ZShzdWJncmFwaCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShnKSB7XG4gIHZhciBtID0gdXRpbC5taW4oZy5ub2RlcygpLm1hcChmdW5jdGlvbih1KSB7IHJldHVybiBnLm5vZGUodSkucmFuazsgfSkpO1xuICBnLmVhY2hOb2RlKGZ1bmN0aW9uKHUsIG5vZGUpIHsgbm9kZS5yYW5rIC09IG07IH0pO1xufVxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWN5Y2xpYztcbm1vZHVsZS5leHBvcnRzLnVuZG8gPSB1bmRvO1xuXG4vKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGRpcmVjdGVkIGdyYXBoIHRoYXQgbWF5IGhhdmUgY3ljbGVzIGFuZCByZXZlcnNlcyBlZGdlc1xuICogYXMgYXBwcm9wcmlhdGUgdG8gYnJlYWsgdGhlc2UgY3ljbGVzLiBFYWNoIHJldmVyc2VkIGVkZ2UgaXMgYXNzaWduZWQgYVxuICogYHJldmVyc2VkYCBhdHRyaWJ1dGUgd2l0aCB0aGUgdmFsdWUgYHRydWVgLlxuICpcbiAqIFRoZXJlIHNob3VsZCBiZSBubyBzZWxmIGxvb3BzIGluIHRoZSBncmFwaC5cbiAqL1xuZnVuY3Rpb24gYWN5Y2xpYyhnKSB7XG4gIHZhciBvblN0YWNrID0ge30sXG4gICAgICB2aXNpdGVkID0ge30sXG4gICAgICByZXZlcnNlQ291bnQgPSAwO1xuICBcbiAgZnVuY3Rpb24gZGZzKHUpIHtcbiAgICBpZiAodSBpbiB2aXNpdGVkKSByZXR1cm47XG4gICAgdmlzaXRlZFt1XSA9IG9uU3RhY2tbdV0gPSB0cnVlO1xuICAgIGcub3V0RWRnZXModSkuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdCA9IGcudGFyZ2V0KGUpLFxuICAgICAgICAgIHZhbHVlO1xuXG4gICAgICBpZiAodSA9PT0gdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdXYXJuaW5nOiBmb3VuZCBzZWxmIGxvb3AgXCInICsgZSArICdcIiBmb3Igbm9kZSBcIicgKyB1ICsgJ1wiJyk7XG4gICAgICB9IGVsc2UgaWYgKHQgaW4gb25TdGFjaykge1xuICAgICAgICB2YWx1ZSA9IGcuZWRnZShlKTtcbiAgICAgICAgZy5kZWxFZGdlKGUpO1xuICAgICAgICB2YWx1ZS5yZXZlcnNlZCA9IHRydWU7XG4gICAgICAgICsrcmV2ZXJzZUNvdW50O1xuICAgICAgICBnLmFkZEVkZ2UoZSwgdCwgdSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGZzKHQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVsZXRlIG9uU3RhY2tbdV07XG4gIH1cblxuICBnLmVhY2hOb2RlKGZ1bmN0aW9uKHUpIHsgZGZzKHUpOyB9KTtcblxuICB1dGlsLmxvZygyLCAnQWN5Y2xpYyBQaGFzZTogcmV2ZXJzZWQgJyArIHJldmVyc2VDb3VudCArICcgZWRnZShzKScpO1xuXG4gIHJldHVybiByZXZlcnNlQ291bnQ7XG59XG5cbi8qXG4gKiBHaXZlbiBhIGdyYXBoIHRoYXQgaGFzIGhhZCB0aGUgYWN5Y2xpYyBvcGVyYXRpb24gYXBwbGllZCwgdGhpcyBmdW5jdGlvblxuICogdW5kb2VzIHRoYXQgb3BlcmF0aW9uLiBNb3JlIHNwZWNpZmljYWxseSwgYW55IGVkZ2Ugd2l0aCB0aGUgYHJldmVyc2VkYFxuICogYXR0cmlidXRlIGlzIGFnYWluIHJldmVyc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpcmVjdGlvbiBvZiB0aGUgZWRnZS5cbiAqL1xuZnVuY3Rpb24gdW5kbyhnKSB7XG4gIGcuZWFjaEVkZ2UoZnVuY3Rpb24oZSwgcywgdCwgYSkge1xuICAgIGlmIChhLnJldmVyc2VkKSB7XG4gICAgICBkZWxldGUgYS5yZXZlcnNlZDtcbiAgICAgIGcuZGVsRWRnZShlKTtcbiAgICAgIGcuYWRkRWRnZShlLCB0LCBzLCBhKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiZXhwb3J0cy5hcHBseSA9IGZ1bmN0aW9uKGcpIHtcbiAgZnVuY3Rpb24gZGZzKHNnKSB7XG4gICAgdmFyIHJhbmtTZXRzID0ge307XG4gICAgZy5jaGlsZHJlbihzZykuZm9yRWFjaChmdW5jdGlvbih1KSB7XG4gICAgICBpZiAoZy5jaGlsZHJlbih1KS5sZW5ndGgpIHtcbiAgICAgICAgZGZzKHUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGcubm9kZSh1KSxcbiAgICAgICAgICBwcmVmUmFuayA9IHZhbHVlLnByZWZSYW5rO1xuICAgICAgaWYgKHByZWZSYW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFjaGVja1N1cHBvcnRlZFByZWZSYW5rKHByZWZSYW5rKSkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAoIShwcmVmUmFuayBpbiByYW5rU2V0cykpIHtcbiAgICAgICAgICByYW5rU2V0cy5wcmVmUmFuayA9IFt1XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYW5rU2V0cy5wcmVmUmFuay5wdXNoKHUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1UgPSByYW5rU2V0c1twcmVmUmFua107XG4gICAgICAgIGlmIChuZXdVID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdVID0gcmFua1NldHNbcHJlZlJhbmtdID0gZy5hZGROb2RlKG51bGwsIHsgb3JpZ2luYWxOb2RlczogW10gfSk7XG4gICAgICAgICAgZy5wYXJlbnQobmV3VSwgc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVkaXJlY3RJbkVkZ2VzKGcsIHUsIG5ld1UsIHByZWZSYW5rID09PSAnbWluJyk7XG4gICAgICAgIHJlZGlyZWN0T3V0RWRnZXMoZywgdSwgbmV3VSwgcHJlZlJhbmsgPT09ICdtYXgnKTtcblxuICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIG5vZGUgYW5kIHJlbW92ZSBpdCBmcm9tIHJlZHVjZWQgZ3JhcGhcbiAgICAgICAgZy5ub2RlKG5ld1UpLm9yaWdpbmFsTm9kZXMucHVzaCh7IHU6IHUsIHZhbHVlOiB2YWx1ZSwgcGFyZW50OiBzZyB9KTtcbiAgICAgICAgZy5kZWxOb2RlKHUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkTGlnaHRFZGdlc0Zyb21NaW5Ob2RlKGcsIHNnLCByYW5rU2V0cy5taW4pO1xuICAgIGFkZExpZ2h0RWRnZXNUb01heE5vZGUoZywgc2csIHJhbmtTZXRzLm1heCk7XG4gIH1cblxuICBkZnMobnVsbCk7XG59O1xuXG5mdW5jdGlvbiBjaGVja1N1cHBvcnRlZFByZWZSYW5rKHByZWZSYW5rKSB7XG4gIGlmIChwcmVmUmFuayAhPT0gJ21pbicgJiYgcHJlZlJhbmsgIT09ICdtYXgnICYmIHByZWZSYW5rLmluZGV4T2YoJ3NhbWVfJykgIT09IDApIHtcbiAgICBjb25zb2xlLmVycm9yKCdVbnN1cHBvcnRlZCByYW5rIHR5cGU6ICcgKyBwcmVmUmFuayk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWRpcmVjdEluRWRnZXMoZywgdSwgbmV3VSwgcmV2ZXJzZSkge1xuICBnLmluRWRnZXModSkuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgdmFyIG9yaWdWYWx1ZSA9IGcuZWRnZShlKSxcbiAgICAgICAgdmFsdWU7XG4gICAgaWYgKG9yaWdWYWx1ZS5vcmlnaW5hbEVkZ2UpIHtcbiAgICAgIHZhbHVlID0gb3JpZ1ZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9ICB7XG4gICAgICAgIG9yaWdpbmFsRWRnZTogeyBlOiBlLCB1OiBnLnNvdXJjZShlKSwgdjogZy50YXJnZXQoZSksIHZhbHVlOiBvcmlnVmFsdWUgfSxcbiAgICAgICAgbWluTGVuOiBnLmVkZ2UoZSkubWluTGVuXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIERvIG5vdCByZXZlcnNlIGVkZ2VzIGZvciBzZWxmLWxvb3BzLlxuICAgIGlmIChvcmlnVmFsdWUuc2VsZkxvb3ApIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYWxsIGVkZ2VzIHRvIG1pbiBhcmUgcmV2ZXJzZWRcbiAgICAgIGcuYWRkRWRnZShudWxsLCBuZXdVLCBnLnNvdXJjZShlKSwgdmFsdWUpO1xuICAgICAgdmFsdWUucmV2ZXJzZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBnLmFkZEVkZ2UobnVsbCwgZy5zb3VyY2UoZSksIG5ld1UsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWRpcmVjdE91dEVkZ2VzKGcsIHUsIG5ld1UsIHJldmVyc2UpIHtcbiAgZy5vdXRFZGdlcyh1KS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgb3JpZ1ZhbHVlID0gZy5lZGdlKGUpLFxuICAgICAgICB2YWx1ZTtcbiAgICBpZiAob3JpZ1ZhbHVlLm9yaWdpbmFsRWRnZSkge1xuICAgICAgdmFsdWUgPSBvcmlnVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gIHtcbiAgICAgICAgb3JpZ2luYWxFZGdlOiB7IGU6IGUsIHU6IGcuc291cmNlKGUpLCB2OiBnLnRhcmdldChlKSwgdmFsdWU6IG9yaWdWYWx1ZSB9LFxuICAgICAgICBtaW5MZW46IGcuZWRnZShlKS5taW5MZW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IHJldmVyc2UgZWRnZXMgZm9yIHNlbGYtbG9vcHMuXG4gICAgaWYgKG9yaWdWYWx1ZS5zZWxmTG9vcCkge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBhbGwgZWRnZXMgZnJvbSBtYXggYXJlIHJldmVyc2VkXG4gICAgICBnLmFkZEVkZ2UobnVsbCwgZy50YXJnZXQoZSksIG5ld1UsIHZhbHVlKTtcbiAgICAgIHZhbHVlLnJldmVyc2VkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZy5hZGRFZGdlKG51bGwsIG5ld1UsIGcudGFyZ2V0KGUpLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkTGlnaHRFZGdlc0Zyb21NaW5Ob2RlKGcsIHNnLCBtaW5Ob2RlKSB7XG4gIGlmIChtaW5Ob2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBnLmNoaWxkcmVuKHNnKS5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICAgIC8vIFRoZSBkdW1teSBjaGVjayBlbnN1cmVzIHdlIGRvbid0IGFkZCBhbiBlZGdlIGlmIHRoZSBub2RlIGlzIGludm9sdmVkXG4gICAgICAvLyBpbiBhIHNlbGYgbG9vcCBvciBzaWRld2F5cyBlZGdlLlxuICAgICAgaWYgKHUgIT09IG1pbk5vZGUgJiYgIWcub3V0RWRnZXMobWluTm9kZSwgdSkubGVuZ3RoICYmICFnLm5vZGUodSkuZHVtbXkpIHtcbiAgICAgICAgZy5hZGRFZGdlKG51bGwsIG1pbk5vZGUsIHUsIHsgbWluTGVuOiAwIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZExpZ2h0RWRnZXNUb01heE5vZGUoZywgc2csIG1heE5vZGUpIHtcbiAgaWYgKG1heE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGcuY2hpbGRyZW4oc2cpLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgLy8gVGhlIGR1bW15IGNoZWNrIGVuc3VyZXMgd2UgZG9uJ3QgYWRkIGFuIGVkZ2UgaWYgdGhlIG5vZGUgaXMgaW52b2x2ZWRcbiAgICAgIC8vIGluIGEgc2VsZiBsb29wIG9yIHNpZGV3YXlzIGVkZ2UuXG4gICAgICBpZiAodSAhPT0gbWF4Tm9kZSAmJiAhZy5vdXRFZGdlcyh1LCBtYXhOb2RlKS5sZW5ndGggJiYgIWcubm9kZSh1KS5kdW1teSkge1xuICAgICAgICBnLmFkZEVkZ2UobnVsbCwgdSwgbWF4Tm9kZSwgeyBtaW5MZW46IDAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gXCJyZWxheGVzXCIgdGhlIGNvbnN0cmFpbnRzIGFwcGxpZWQgcHJldmlvdXNseSBieSB0aGUgXCJhcHBseVwiXG4gKiBmdW5jdGlvbi4gSXQgZXhwYW5kcyBhbnkgbm9kZXMgdGhhdCB3ZXJlIGNvbGxhcHNlZCBhbmQgYXNzaWducyB0aGUgcmFuayBvZlxuICogdGhlIGNvbGxhcHNlZCBub2RlIHRvIGVhY2ggb2YgdGhlIGV4cGFuZGVkIG5vZGVzLiBJdCBhbHNvIHJlc3RvcmVzIHRoZVxuICogb3JpZ2luYWwgZWRnZXMgYW5kIHJlbW92ZXMgYW55IGR1bW15IGVkZ2VzIHBvaW50aW5nIGF0IHRoZSBjb2xsYXBzZWQgbm9kZXMuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBwcm9jZXNzIG9mIHJlbW92aW5nIGNvbGxhcHNlZCBub2RlcyBhbHNvIHJlbW92ZXMgZHVtbXkgZWRnZXNcbiAqIGF1dG9tYXRpY2FsbHkuXG4gKi9cbmV4cG9ydHMucmVsYXggPSBmdW5jdGlvbihnKSB7XG4gIC8vIFNhdmUgb3JpZ2luYWwgZWRnZXNcbiAgdmFyIG9yaWdpbmFsRWRnZXMgPSBbXTtcbiAgZy5lYWNoRWRnZShmdW5jdGlvbihlLCB1LCB2LCB2YWx1ZSkge1xuICAgIHZhciBvcmlnaW5hbEVkZ2UgPSB2YWx1ZS5vcmlnaW5hbEVkZ2U7XG4gICAgaWYgKG9yaWdpbmFsRWRnZSkge1xuICAgICAgb3JpZ2luYWxFZGdlcy5wdXNoKG9yaWdpbmFsRWRnZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBFeHBhbmQgY29sbGFwc2VkIG5vZGVzXG4gIGcuZWFjaE5vZGUoZnVuY3Rpb24odSwgdmFsdWUpIHtcbiAgICB2YXIgb3JpZ2luYWxOb2RlcyA9IHZhbHVlLm9yaWdpbmFsTm9kZXM7XG4gICAgaWYgKG9yaWdpbmFsTm9kZXMpIHtcbiAgICAgIG9yaWdpbmFsTm9kZXMuZm9yRWFjaChmdW5jdGlvbihvcmlnaW5hbE5vZGUpIHtcbiAgICAgICAgb3JpZ2luYWxOb2RlLnZhbHVlLnJhbmsgPSB2YWx1ZS5yYW5rO1xuICAgICAgICBnLmFkZE5vZGUob3JpZ2luYWxOb2RlLnUsIG9yaWdpbmFsTm9kZS52YWx1ZSk7XG4gICAgICAgIGcucGFyZW50KG9yaWdpbmFsTm9kZS51LCBvcmlnaW5hbE5vZGUucGFyZW50KTtcbiAgICAgIH0pO1xuICAgICAgZy5kZWxOb2RlKHUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gUmVzdG9yZSBvcmlnaW5hbCBlZGdlc1xuICBvcmlnaW5hbEVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSkge1xuICAgIGcuYWRkRWRnZShlZGdlLmUsIGVkZ2UudSwgZWRnZS52LCBlZGdlLnZhbHVlKTtcbiAgfSk7XG59O1xuIiwiLyoganNoaW50IC1XMDc5ICovXG52YXIgU2V0ID0gcmVxdWlyZSgnY3AtZGF0YScpLlNldCxcbi8qIGpzaGludCArVzA3OSAqL1xuICAgIERpZ3JhcGggPSByZXF1aXJlKCdncmFwaGxpYicpLkRpZ3JhcGgsXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmZWFzaWJsZVRyZWU7XG5cbi8qXG4gKiBHaXZlbiBhbiBhY3ljbGljIGdyYXBoIHdpdGggZWFjaCBub2RlIGFzc2lnbmVkIGEgYHJhbmtgIGF0dHJpYnV0ZSwgdGhpc1xuICogZnVuY3Rpb24gY29uc3RydWN0cyBhbmQgcmV0dXJucyBhIHNwYW5uaW5nIHRyZWUuIFRoaXMgZnVuY3Rpb24gbWF5IHJlZHVjZVxuICogdGhlIGxlbmd0aCBvZiBzb21lIGVkZ2VzIGZyb20gdGhlIGluaXRpYWwgcmFuayBhc3NpZ25tZW50IHdoaWxlIG1haW50YWluaW5nXG4gKiB0aGUgYG1pbkxlbmAgc3BlY2lmaWVkIGJ5IGVhY2ggZWRnZS5cbiAqXG4gKiBQcmVyZXF1aXNpdGVzOlxuICpcbiAqICogVGhlIGlucHV0IGdyYXBoIGlzIGFjeWNsaWNcbiAqICogRWFjaCBub2RlIGluIHRoZSBpbnB1dCBncmFwaCBoYXMgYW4gYXNzaWduZWQgYHJhbmtgIGF0dHJpYnV0ZVxuICogKiBFYWNoIGVkZ2UgaW4gdGhlIGlucHV0IGdyYXBoIGhhcyBhbiBhc3NpZ25lZCBgbWluTGVuYCBhdHRyaWJ1dGVcbiAqXG4gKiBPdXRwdXRzOlxuICpcbiAqIEEgZmVhc2libGUgc3Bhbm5pbmcgdHJlZSBmb3IgdGhlIGlucHV0IGdyYXBoIChpLmUuIGEgc3Bhbm5pbmcgdHJlZSB0aGF0XG4gKiByZXNwZWN0cyBlYWNoIGdyYXBoIGVkZ2UncyBgbWluTGVuYCBhdHRyaWJ1dGUpIHJlcHJlc2VudGVkIGFzIGEgRGlncmFwaCB3aXRoXG4gKiBhIGByb290YCBhdHRyaWJ1dGUgb24gZ3JhcGguXG4gKlxuICogTm9kZXMgaGF2ZSB0aGUgc2FtZSBpZCBhbmQgdmFsdWUgYXMgdGhhdCBpbiB0aGUgaW5wdXQgZ3JhcGguXG4gKlxuICogRWRnZXMgaW4gdGhlIHRyZWUgaGF2ZSBhcmJpdHJhcmlseSBhc3NpZ25lZCBpZHMuIFRoZSBhdHRyaWJ1dGVzIGZvciBlZGdlc1xuICogaW5jbHVkZSBgcmV2ZXJzZWRgLiBgcmV2ZXJzZWRgIGluZGljYXRlcyB0aGF0IHRoZSBlZGdlIGlzIGFcbiAqIGJhY2sgZWRnZSBpbiB0aGUgaW5wdXQgZ3JhcGguXG4gKi9cbmZ1bmN0aW9uIGZlYXNpYmxlVHJlZShnKSB7XG4gIHZhciByZW1haW5pbmcgPSBuZXcgU2V0KGcubm9kZXMoKSksXG4gICAgICB0cmVlID0gbmV3IERpZ3JhcGgoKTtcblxuICBpZiAocmVtYWluaW5nLnNpemUoKSA9PT0gMSkge1xuICAgIHZhciByb290ID0gZy5ub2RlcygpWzBdO1xuICAgIHRyZWUuYWRkTm9kZShyb290LCB7fSk7XG4gICAgdHJlZS5ncmFwaCh7IHJvb3Q6IHJvb3QgfSk7XG4gICAgcmV0dXJuIHRyZWU7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUaWdodEVkZ2VzKHYpIHtcbiAgICB2YXIgY29udGludWVUb1NjYW4gPSB0cnVlO1xuICAgIGcucHJlZGVjZXNzb3JzKHYpLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgaWYgKHJlbWFpbmluZy5oYXModSkgJiYgIXNsYWNrKGcsIHUsIHYpKSB7XG4gICAgICAgIGlmIChyZW1haW5pbmcuaGFzKHYpKSB7XG4gICAgICAgICAgdHJlZS5hZGROb2RlKHYsIHt9KTtcbiAgICAgICAgICByZW1haW5pbmcucmVtb3ZlKHYpO1xuICAgICAgICAgIHRyZWUuZ3JhcGgoeyByb290OiB2IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJlZS5hZGROb2RlKHUsIHt9KTtcbiAgICAgICAgdHJlZS5hZGRFZGdlKG51bGwsIHUsIHYsIHsgcmV2ZXJzZWQ6IHRydWUgfSk7XG4gICAgICAgIHJlbWFpbmluZy5yZW1vdmUodSk7XG4gICAgICAgIGFkZFRpZ2h0RWRnZXModSk7XG4gICAgICAgIGNvbnRpbnVlVG9TY2FuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBnLnN1Y2Nlc3NvcnModikuZm9yRWFjaChmdW5jdGlvbih3KSAge1xuICAgICAgaWYgKHJlbWFpbmluZy5oYXModykgJiYgIXNsYWNrKGcsIHYsIHcpKSB7XG4gICAgICAgIGlmIChyZW1haW5pbmcuaGFzKHYpKSB7XG4gICAgICAgICAgdHJlZS5hZGROb2RlKHYsIHt9KTtcbiAgICAgICAgICByZW1haW5pbmcucmVtb3ZlKHYpO1xuICAgICAgICAgIHRyZWUuZ3JhcGgoeyByb290OiB2IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJlZS5hZGROb2RlKHcsIHt9KTtcbiAgICAgICAgdHJlZS5hZGRFZGdlKG51bGwsIHYsIHcsIHt9KTtcbiAgICAgICAgcmVtYWluaW5nLnJlbW92ZSh3KTtcbiAgICAgICAgYWRkVGlnaHRFZGdlcyh3KTtcbiAgICAgICAgY29udGludWVUb1NjYW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29udGludWVUb1NjYW47XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVUaWdodEVkZ2UoKSB7XG4gICAgdmFyIG1pblNsYWNrID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICByZW1haW5pbmcua2V5cygpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgZy5wcmVkZWNlc3NvcnModikuZm9yRWFjaChmdW5jdGlvbih1KSB7XG4gICAgICAgIGlmICghcmVtYWluaW5nLmhhcyh1KSkge1xuICAgICAgICAgIHZhciBlZGdlU2xhY2sgPSBzbGFjayhnLCB1LCB2KTtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZWRnZVNsYWNrKSA8IE1hdGguYWJzKG1pblNsYWNrKSkge1xuICAgICAgICAgICAgbWluU2xhY2sgPSAtZWRnZVNsYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGcuc3VjY2Vzc29ycyh2KS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgaWYgKCFyZW1haW5pbmcuaGFzKHcpKSB7XG4gICAgICAgICAgdmFyIGVkZ2VTbGFjayA9IHNsYWNrKGcsIHYsIHcpO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhlZGdlU2xhY2spIDwgTWF0aC5hYnMobWluU2xhY2spKSB7XG4gICAgICAgICAgICBtaW5TbGFjayA9IGVkZ2VTbGFjaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdHJlZS5lYWNoTm9kZShmdW5jdGlvbih1KSB7IGcubm9kZSh1KS5yYW5rIC09IG1pblNsYWNrOyB9KTtcbiAgfVxuXG4gIHdoaWxlIChyZW1haW5pbmcuc2l6ZSgpKSB7XG4gICAgdmFyIG5vZGVzVG9TZWFyY2ggPSAhdHJlZS5vcmRlcigpID8gcmVtYWluaW5nLmtleXMoKSA6IHRyZWUubm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBub2Rlc1RvU2VhcmNoLmxlbmd0aDtcbiAgICAgICAgIGkgPCBpbCAmJiBhZGRUaWdodEVkZ2VzKG5vZGVzVG9TZWFyY2hbaV0pO1xuICAgICAgICAgKytpKTtcbiAgICBpZiAocmVtYWluaW5nLnNpemUoKSkge1xuICAgICAgY3JlYXRlVGlnaHRFZGdlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRyZWU7XG59XG5cbmZ1bmN0aW9uIHNsYWNrKGcsIHUsIHYpIHtcbiAgdmFyIHJhbmtEaWZmID0gZy5ub2RlKHYpLnJhbmsgLSBnLm5vZGUodSkucmFuaztcbiAgdmFyIG1heE1pbkxlbiA9IHV0aWwubWF4KGcub3V0RWRnZXModSwgdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGcuZWRnZShlKS5taW5MZW47IH0pKTtcbiAgcmV0dXJuIHJhbmtEaWZmIC0gbWF4TWluTGVuO1xufVxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgdG9wc29ydCA9IHJlcXVpcmUoJ2dyYXBobGliJykuYWxnLnRvcHNvcnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdFJhbms7XG5cbi8qXG4gKiBBc3NpZ25zIGEgYHJhbmtgIGF0dHJpYnV0ZSB0byBlYWNoIG5vZGUgaW4gdGhlIGlucHV0IGdyYXBoIGFuZCBlbnN1cmVzIHRoYXRcbiAqIHRoaXMgcmFuayByZXNwZWN0cyB0aGUgYG1pbkxlbmAgYXR0cmlidXRlIG9mIGluY2lkZW50IGVkZ2VzLlxuICpcbiAqIFByZXJlcXVpc2l0ZXM6XG4gKlxuICogICogVGhlIGlucHV0IGdyYXBoIG11c3QgYmUgYWN5Y2xpY1xuICogICogRWFjaCBlZGdlIGluIHRoZSBpbnB1dCBncmFwaCBtdXN0IGhhdmUgYW4gYXNzaWduZWQgJ21pbkxlbicgYXR0cmlidXRlXG4gKi9cbmZ1bmN0aW9uIGluaXRSYW5rKGcpIHtcbiAgdmFyIHNvcnRlZCA9IHRvcHNvcnQoZyk7XG5cbiAgc29ydGVkLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgIHZhciBpbkVkZ2VzID0gZy5pbkVkZ2VzKHUpO1xuICAgIGlmIChpbkVkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZy5ub2RlKHUpLnJhbmsgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtaW5MZW5zID0gaW5FZGdlcy5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGcubm9kZShnLnNvdXJjZShlKSkucmFuayArIGcuZWRnZShlKS5taW5MZW47XG4gICAgfSk7XG4gICAgZy5ub2RlKHUpLnJhbmsgPSB1dGlsLm1heChtaW5MZW5zKTtcbiAgfSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2xhY2s6IHNsYWNrXG59O1xuXG4vKlxuICogQSBoZWxwZXIgdG8gY2FsY3VsYXRlIHRoZSBzbGFjayBiZXR3ZWVuIHR3byBub2RlcyAoYHVgIGFuZCBgdmApIGdpdmVuIGFcbiAqIGBtaW5MZW5gIGNvbnN0cmFpbnQuIFRoZSBzbGFjayByZXByZXNlbnRzIGhvdyBtdWNoIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGB1YFxuICogYW5kIGB2YCBjb3VsZCBzaHJpbmsgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGBtaW5MZW5gIGNvbnN0cmFpbnQuIElmIHRoZSB2YWx1ZVxuICogaXMgbmVnYXRpdmUgdGhlbiB0aGUgY29uc3RyYWludCBpcyBjdXJyZW50bHkgdmlvbGF0ZWQuXG4gKlxuICBUaGlzIGZ1bmN0aW9uIHJlcXVpcmVzIHRoYXQgYHVgIGFuZCBgdmAgYXJlIGluIGBncmFwaGAgYW5kIHRoZXkgYm90aCBoYXZlIGFcbiAgYHJhbmtgIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gc2xhY2soZ3JhcGgsIHUsIHYsIG1pbkxlbikge1xuICByZXR1cm4gTWF0aC5hYnMoZ3JhcGgubm9kZSh1KS5yYW5rIC0gZ3JhcGgubm9kZSh2KS5yYW5rKSAtIG1pbkxlbjtcbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICAgIHJhbmtVdGlsID0gcmVxdWlyZSgnLi9yYW5rVXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNpbXBsZXg7XG5cbmZ1bmN0aW9uIHNpbXBsZXgoZ3JhcGgsIHNwYW5uaW5nVHJlZSkge1xuICAvLyBUaGUgbmV0d29yayBzaW1wbGV4IGFsZ29yaXRobSByZXBlYXRlZGx5IHJlcGxhY2VzIGVkZ2VzIG9mXG4gIC8vIHRoZSBzcGFubmluZyB0cmVlIHdpdGggbmVnYXRpdmUgY3V0IHZhbHVlcyB1bnRpbCBubyBzdWNoXG4gIC8vIGVkZ2UgZXhpc3RzLlxuICBpbml0Q3V0VmFsdWVzKGdyYXBoLCBzcGFubmluZ1RyZWUpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBlID0gbGVhdmVFZGdlKHNwYW5uaW5nVHJlZSk7XG4gICAgaWYgKGUgPT09IG51bGwpIGJyZWFrO1xuICAgIHZhciBmID0gZW50ZXJFZGdlKGdyYXBoLCBzcGFubmluZ1RyZWUsIGUpO1xuICAgIGV4Y2hhbmdlKGdyYXBoLCBzcGFubmluZ1RyZWUsIGUsIGYpO1xuICB9XG59XG5cbi8qXG4gKiBTZXQgdGhlIGN1dCB2YWx1ZXMgb2YgZWRnZXMgaW4gdGhlIHNwYW5uaW5nIHRyZWUgYnkgYSBkZXB0aC1maXJzdFxuICogcG9zdG9yZGVyIHRyYXZlcnNhbC4gIFRoZSBjdXQgdmFsdWUgY29ycmVzcG9uZHMgdG8gdGhlIGNvc3QsIGluXG4gKiB0ZXJtcyBvZiBhIHJhbmtpbmcncyBlZGdlIGxlbmd0aCBzdW0sIG9mIGxlbmd0aGVuaW5nIGFuIGVkZ2UuXG4gKiBOZWdhdGl2ZSBjdXQgdmFsdWVzIHR5cGljYWxseSBpbmRpY2F0ZSBlZGdlcyB0aGF0IHdvdWxkIHlpZWxkIGFcbiAqIHNtYWxsZXIgZWRnZSBsZW5ndGggc3VtIGlmIHRoZXkgd2VyZSBsZW5ndGhlbmVkLlxuICovXG5mdW5jdGlvbiBpbml0Q3V0VmFsdWVzKGdyYXBoLCBzcGFubmluZ1RyZWUpIHtcbiAgY29tcHV0ZUxvd0xpbShzcGFubmluZ1RyZWUpO1xuXG4gIHNwYW5uaW5nVHJlZS5lYWNoRWRnZShmdW5jdGlvbihpZCwgdSwgdiwgdHJlZVZhbHVlKSB7XG4gICAgdHJlZVZhbHVlLmN1dFZhbHVlID0gMDtcbiAgfSk7XG5cbiAgLy8gUHJvcGFnYXRlIGN1dCB2YWx1ZXMgdXAgdGhlIHRyZWUuXG4gIGZ1bmN0aW9uIGRmcyhuKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gc3Bhbm5pbmdUcmVlLnN1Y2Nlc3NvcnMobik7XG4gICAgZm9yICh2YXIgYyBpbiBjaGlsZHJlbikge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bY107XG4gICAgICBkZnMoY2hpbGQpO1xuICAgIH1cbiAgICBpZiAobiAhPT0gc3Bhbm5pbmdUcmVlLmdyYXBoKCkucm9vdCkge1xuICAgICAgc2V0Q3V0VmFsdWUoZ3JhcGgsIHNwYW5uaW5nVHJlZSwgbik7XG4gICAgfVxuICB9XG4gIGRmcyhzcGFubmluZ1RyZWUuZ3JhcGgoKS5yb290KTtcbn1cblxuLypcbiAqIFBlcmZvcm0gYSBERlMgcG9zdG9yZGVyIHRyYXZlcnNhbCwgbGFiZWxpbmcgZWFjaCBub2RlIHYgd2l0aFxuICogaXRzIHRyYXZlcnNhbCBvcmRlciAnbGltKHYpJyBhbmQgdGhlIG1pbmltdW0gdHJhdmVyc2FsIG51bWJlclxuICogb2YgYW55IG9mIGl0cyBkZXNjZW5kYW50cyAnbG93KHYpJy4gIFRoaXMgcHJvdmlkZXMgYW4gZWZmaWNpZW50XG4gKiB3YXkgdG8gdGVzdCB3aGV0aGVyIHUgaXMgYW4gYW5jZXN0b3Igb2YgdiBzaW5jZVxuICogbG93KHUpIDw9IGxpbSh2KSA8PSBsaW0odSkgaWYgYW5kIG9ubHkgaWYgdSBpcyBhbiBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUxvd0xpbSh0cmVlKSB7XG4gIHZhciBwb3N0T3JkZXJOdW0gPSAwO1xuICBcbiAgZnVuY3Rpb24gZGZzKG4pIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0cmVlLnN1Y2Nlc3NvcnMobik7XG4gICAgdmFyIGxvdyA9IHBvc3RPcmRlck51bTtcbiAgICBmb3IgKHZhciBjIGluIGNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltjXTtcbiAgICAgIGRmcyhjaGlsZCk7XG4gICAgICBsb3cgPSBNYXRoLm1pbihsb3csIHRyZWUubm9kZShjaGlsZCkubG93KTtcbiAgICB9XG4gICAgdHJlZS5ub2RlKG4pLmxvdyA9IGxvdztcbiAgICB0cmVlLm5vZGUobikubGltID0gcG9zdE9yZGVyTnVtKys7XG4gIH1cblxuICBkZnModHJlZS5ncmFwaCgpLnJvb3QpO1xufVxuXG4vKlxuICogVG8gY29tcHV0ZSB0aGUgY3V0IHZhbHVlIG9mIHRoZSBlZGdlIHBhcmVudCAtPiBjaGlsZCwgd2UgY29uc2lkZXJcbiAqIGl0IGFuZCBhbnkgb3RoZXIgZ3JhcGggZWRnZXMgdG8gb3IgZnJvbSB0aGUgY2hpbGQuXG4gKiAgICAgICAgICBwYXJlbnRcbiAqICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICBjaGlsZFxuICogICAgICAgICAgLyAgICAgIFxcXG4gKiAgICAgICAgIHUgICAgICAgIHZcbiAqL1xuZnVuY3Rpb24gc2V0Q3V0VmFsdWUoZ3JhcGgsIHRyZWUsIGNoaWxkKSB7XG4gIHZhciBwYXJlbnRFZGdlID0gdHJlZS5pbkVkZ2VzKGNoaWxkKVswXTtcblxuICAvLyBMaXN0IG9mIGNoaWxkJ3MgY2hpbGRyZW4gaW4gdGhlIHNwYW5uaW5nIHRyZWUuXG4gIHZhciBncmFuZGNoaWxkcmVuID0gW107XG4gIHZhciBncmFuZGNoaWxkRWRnZXMgPSB0cmVlLm91dEVkZ2VzKGNoaWxkKTtcbiAgZm9yICh2YXIgZ2NlIGluIGdyYW5kY2hpbGRFZGdlcykge1xuICAgIGdyYW5kY2hpbGRyZW4ucHVzaCh0cmVlLnRhcmdldChncmFuZGNoaWxkRWRnZXNbZ2NlXSkpO1xuICB9XG5cbiAgdmFyIGN1dFZhbHVlID0gMDtcblxuICAvLyBUT0RPOiBSZXBsYWNlIHVuaXQgaW5jcmVtZW50L2RlY3JlbWVudCB3aXRoIGVkZ2Ugd2VpZ2h0cy5cbiAgdmFyIEUgPSAwOyAgICAvLyBFZGdlcyBmcm9tIGNoaWxkIHRvIGdyYW5kY2hpbGQncyBzdWJ0cmVlLlxuICB2YXIgRiA9IDA7ICAgIC8vIEVkZ2VzIHRvIGNoaWxkIGZyb20gZ3JhbmRjaGlsZCdzIHN1YnRyZWUuXG4gIHZhciBHID0gMDsgICAgLy8gRWRnZXMgZnJvbSBjaGlsZCB0byBub2RlcyBvdXRzaWRlIG9mIGNoaWxkJ3Mgc3VidHJlZS5cbiAgdmFyIEggPSAwOyAgICAvLyBFZGdlcyBmcm9tIG5vZGVzIG91dHNpZGUgb2YgY2hpbGQncyBzdWJ0cmVlIHRvIGNoaWxkLlxuXG4gIC8vIENvbnNpZGVyIGFsbCBncmFwaCBlZGdlcyBmcm9tIGNoaWxkLlxuICB2YXIgb3V0RWRnZXMgPSBncmFwaC5vdXRFZGdlcyhjaGlsZCk7XG4gIHZhciBnYztcbiAgZm9yICh2YXIgb2UgaW4gb3V0RWRnZXMpIHtcbiAgICB2YXIgc3VjYyA9IGdyYXBoLnRhcmdldChvdXRFZGdlc1tvZV0pO1xuICAgIGZvciAoZ2MgaW4gZ3JhbmRjaGlsZHJlbikge1xuICAgICAgaWYgKGluU3VidHJlZSh0cmVlLCBzdWNjLCBncmFuZGNoaWxkcmVuW2djXSkpIHtcbiAgICAgICAgRSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluU3VidHJlZSh0cmVlLCBzdWNjLCBjaGlsZCkpIHtcbiAgICAgIEcrKztcbiAgICB9XG4gIH1cblxuICAvLyBDb25zaWRlciBhbGwgZ3JhcGggZWRnZXMgdG8gY2hpbGQuXG4gIHZhciBpbkVkZ2VzID0gZ3JhcGguaW5FZGdlcyhjaGlsZCk7XG4gIGZvciAodmFyIGllIGluIGluRWRnZXMpIHtcbiAgICB2YXIgcHJlZCA9IGdyYXBoLnNvdXJjZShpbkVkZ2VzW2llXSk7XG4gICAgZm9yIChnYyBpbiBncmFuZGNoaWxkcmVuKSB7XG4gICAgICBpZiAoaW5TdWJ0cmVlKHRyZWUsIHByZWQsIGdyYW5kY2hpbGRyZW5bZ2NdKSkge1xuICAgICAgICBGKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW5TdWJ0cmVlKHRyZWUsIHByZWQsIGNoaWxkKSkge1xuICAgICAgSCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnRyaWJ1dGlvbnMgZGVwZW5kIG9uIHRoZSBhbGlnbm1lbnQgb2YgdGhlIHBhcmVudCAtPiBjaGlsZCBlZGdlXG4gIC8vIGFuZCB0aGUgY2hpbGQgLT4gdSBvciB2IGVkZ2VzLlxuICB2YXIgZ3JhbmRjaGlsZEN1dFN1bSA9IDA7XG4gIGZvciAoZ2MgaW4gZ3JhbmRjaGlsZHJlbikge1xuICAgIHZhciBjdiA9IHRyZWUuZWRnZShncmFuZGNoaWxkRWRnZXNbZ2NdKS5jdXRWYWx1ZTtcbiAgICBpZiAoIXRyZWUuZWRnZShncmFuZGNoaWxkRWRnZXNbZ2NdKS5yZXZlcnNlZCkge1xuICAgICAgZ3JhbmRjaGlsZEN1dFN1bSArPSBjdjtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JhbmRjaGlsZEN1dFN1bSAtPSBjdjtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRyZWUuZWRnZShwYXJlbnRFZGdlKS5yZXZlcnNlZCkge1xuICAgIGN1dFZhbHVlICs9IGdyYW5kY2hpbGRDdXRTdW0gLSBFICsgRiAtIEcgKyBIO1xuICB9IGVsc2Uge1xuICAgIGN1dFZhbHVlIC09IGdyYW5kY2hpbGRDdXRTdW0gLSBFICsgRiAtIEcgKyBIO1xuICB9XG5cbiAgdHJlZS5lZGdlKHBhcmVudEVkZ2UpLmN1dFZhbHVlID0gY3V0VmFsdWU7XG59XG5cbi8qXG4gKiBSZXR1cm4gd2hldGhlciBuIGlzIGEgbm9kZSBpbiB0aGUgc3VidHJlZSB3aXRoIHRoZSBnaXZlblxuICogcm9vdC5cbiAqL1xuZnVuY3Rpb24gaW5TdWJ0cmVlKHRyZWUsIG4sIHJvb3QpIHtcbiAgcmV0dXJuICh0cmVlLm5vZGUocm9vdCkubG93IDw9IHRyZWUubm9kZShuKS5saW0gJiZcbiAgICAgICAgICB0cmVlLm5vZGUobikubGltIDw9IHRyZWUubm9kZShyb290KS5saW0pO1xufVxuXG4vKlxuICogUmV0dXJuIGFuIGVkZ2UgZnJvbSB0aGUgdHJlZSB3aXRoIGEgbmVnYXRpdmUgY3V0IHZhbHVlLCBvciBudWxsIGlmIHRoZXJlXG4gKiBpcyBub25lLlxuICovXG5mdW5jdGlvbiBsZWF2ZUVkZ2UodHJlZSkge1xuICB2YXIgZWRnZXMgPSB0cmVlLmVkZ2VzKCk7XG4gIGZvciAodmFyIG4gaW4gZWRnZXMpIHtcbiAgICB2YXIgZSA9IGVkZ2VzW25dO1xuICAgIHZhciB0cmVlVmFsdWUgPSB0cmVlLmVkZ2UoZSk7XG4gICAgaWYgKHRyZWVWYWx1ZS5jdXRWYWx1ZSA8IDApIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLypcbiAqIFRoZSBlZGdlIGUgc2hvdWxkIGJlIGFuIGVkZ2UgaW4gdGhlIHRyZWUsIHdpdGggYW4gdW5kZXJseWluZyBlZGdlXG4gKiBpbiB0aGUgZ3JhcGgsIHdpdGggYSBuZWdhdGl2ZSBjdXQgdmFsdWUuICBPZiB0aGUgdHdvIG5vZGVzIGluY2lkZW50XG4gKiBvbiB0aGUgZWRnZSwgdGFrZSB0aGUgbG93ZXIgb25lLiAgZW50ZXJFZGdlIHJldHVybnMgYW4gZWRnZSB3aXRoXG4gKiBtaW5pbXVtIHNsYWNrIGdvaW5nIGZyb20gb3V0c2lkZSBvZiB0aGF0IG5vZGUncyBzdWJ0cmVlIHRvIGluc2lkZVxuICogb2YgdGhhdCBub2RlJ3Mgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gZW50ZXJFZGdlKGdyYXBoLCB0cmVlLCBlKSB7XG4gIHZhciBzb3VyY2UgPSB0cmVlLnNvdXJjZShlKTtcbiAgdmFyIHRhcmdldCA9IHRyZWUudGFyZ2V0KGUpO1xuICB2YXIgbG93ZXIgPSB0cmVlLm5vZGUodGFyZ2V0KS5saW0gPCB0cmVlLm5vZGUoc291cmNlKS5saW0gPyB0YXJnZXQgOiBzb3VyY2U7XG5cbiAgLy8gSXMgdGhlIHRyZWUgZWRnZSBhbGlnbmVkIHdpdGggdGhlIGdyYXBoIGVkZ2U/XG4gIHZhciBhbGlnbmVkID0gIXRyZWUuZWRnZShlKS5yZXZlcnNlZDtcblxuICB2YXIgbWluU2xhY2sgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIHZhciBtaW5TbGFja0VkZ2U7XG4gIGlmIChhbGlnbmVkKSB7XG4gICAgZ3JhcGguZWFjaEVkZ2UoZnVuY3Rpb24oaWQsIHUsIHYsIHZhbHVlKSB7XG4gICAgICBpZiAoaWQgIT09IGUgJiYgaW5TdWJ0cmVlKHRyZWUsIHUsIGxvd2VyKSAmJiAhaW5TdWJ0cmVlKHRyZWUsIHYsIGxvd2VyKSkge1xuICAgICAgICB2YXIgc2xhY2sgPSByYW5rVXRpbC5zbGFjayhncmFwaCwgdSwgdiwgdmFsdWUubWluTGVuKTtcbiAgICAgICAgaWYgKHNsYWNrIDwgbWluU2xhY2spIHtcbiAgICAgICAgICBtaW5TbGFjayA9IHNsYWNrO1xuICAgICAgICAgIG1pblNsYWNrRWRnZSA9IGlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZ3JhcGguZWFjaEVkZ2UoZnVuY3Rpb24oaWQsIHUsIHYsIHZhbHVlKSB7XG4gICAgICBpZiAoaWQgIT09IGUgJiYgIWluU3VidHJlZSh0cmVlLCB1LCBsb3dlcikgJiYgaW5TdWJ0cmVlKHRyZWUsIHYsIGxvd2VyKSkge1xuICAgICAgICB2YXIgc2xhY2sgPSByYW5rVXRpbC5zbGFjayhncmFwaCwgdSwgdiwgdmFsdWUubWluTGVuKTtcbiAgICAgICAgaWYgKHNsYWNrIDwgbWluU2xhY2spIHtcbiAgICAgICAgICBtaW5TbGFjayA9IHNsYWNrO1xuICAgICAgICAgIG1pblNsYWNrRWRnZSA9IGlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAobWluU2xhY2tFZGdlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgb3V0c2lkZSA9IFtdO1xuICAgIHZhciBpbnNpZGUgPSBbXTtcbiAgICBncmFwaC5lYWNoTm9kZShmdW5jdGlvbihpZCkge1xuICAgICAgaWYgKCFpblN1YnRyZWUodHJlZSwgaWQsIGxvd2VyKSkge1xuICAgICAgICBvdXRzaWRlLnB1c2goaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zaWRlLnB1c2goaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gZWRnZSBmb3VuZCBmcm9tIG91dHNpZGUgb2YgdHJlZSB0byBpbnNpZGUnKTtcbiAgfVxuXG4gIHJldHVybiBtaW5TbGFja0VkZ2U7XG59XG5cbi8qXG4gKiBSZXBsYWNlIGVkZ2UgZSB3aXRoIGVkZ2UgZiBpbiB0aGUgdHJlZSwgcmVjYWxjdWxhdGluZyB0aGUgdHJlZSByb290LFxuICogdGhlIG5vZGVzJyBsb3cgYW5kIGxpbSBwcm9wZXJ0aWVzIGFuZCB0aGUgZWRnZXMnIGN1dCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGV4Y2hhbmdlKGdyYXBoLCB0cmVlLCBlLCBmKSB7XG4gIHRyZWUuZGVsRWRnZShlKTtcbiAgdmFyIHNvdXJjZSA9IGdyYXBoLnNvdXJjZShmKTtcbiAgdmFyIHRhcmdldCA9IGdyYXBoLnRhcmdldChmKTtcblxuICAvLyBSZWRpcmVjdCBlZGdlcyBzbyB0aGF0IHRhcmdldCBpcyB0aGUgcm9vdCBvZiBpdHMgc3VidHJlZS5cbiAgZnVuY3Rpb24gcmVkaXJlY3Qodikge1xuICAgIHZhciBlZGdlcyA9IHRyZWUuaW5FZGdlcyh2KTtcbiAgICBmb3IgKHZhciBpIGluIGVkZ2VzKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIHUgPSB0cmVlLnNvdXJjZShlKTtcbiAgICAgIHZhciB2YWx1ZSA9IHRyZWUuZWRnZShlKTtcbiAgICAgIHJlZGlyZWN0KHUpO1xuICAgICAgdHJlZS5kZWxFZGdlKGUpO1xuICAgICAgdmFsdWUucmV2ZXJzZWQgPSAhdmFsdWUucmV2ZXJzZWQ7XG4gICAgICB0cmVlLmFkZEVkZ2UoZSwgdiwgdSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJlZGlyZWN0KHRhcmdldCk7XG5cbiAgdmFyIHJvb3QgPSBzb3VyY2U7XG4gIHZhciBlZGdlcyA9IHRyZWUuaW5FZGdlcyhyb290KTtcbiAgd2hpbGUgKGVkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICByb290ID0gdHJlZS5zb3VyY2UoZWRnZXNbMF0pO1xuICAgIGVkZ2VzID0gdHJlZS5pbkVkZ2VzKHJvb3QpO1xuICB9XG5cbiAgdHJlZS5ncmFwaCgpLnJvb3QgPSByb290O1xuXG4gIHRyZWUuYWRkRWRnZShudWxsLCBzb3VyY2UsIHRhcmdldCwge2N1dFZhbHVlOiAwfSk7XG5cbiAgaW5pdEN1dFZhbHVlcyhncmFwaCwgdHJlZSk7XG5cbiAgYWRqdXN0UmFua3MoZ3JhcGgsIHRyZWUpO1xufVxuXG4vKlxuICogUmVzZXQgdGhlIHJhbmtzIG9mIGFsbCBub2RlcyBiYXNlZCBvbiB0aGUgY3VycmVudCBzcGFubmluZyB0cmVlLlxuICogVGhlIHJhbmsgb2YgdGhlIHRyZWUncyByb290IHJlbWFpbnMgdW5jaGFuZ2VkLCB3aGlsZSBhbGwgb3RoZXJcbiAqIG5vZGVzIGFyZSBzZXQgdG8gdGhlIHN1bSBvZiBtaW5pbXVtIGxlbmd0aCBjb25zdHJhaW50cyBhbG9uZ1xuICogdGhlIHBhdGggZnJvbSB0aGUgcm9vdC5cbiAqL1xuZnVuY3Rpb24gYWRqdXN0UmFua3MoZ3JhcGgsIHRyZWUpIHtcbiAgZnVuY3Rpb24gZGZzKHApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0cmVlLnN1Y2Nlc3NvcnMocCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgbWluTGVuID0gbWluaW11bUxlbmd0aChncmFwaCwgcCwgYyk7XG4gICAgICBncmFwaC5ub2RlKGMpLnJhbmsgPSBncmFwaC5ub2RlKHApLnJhbmsgKyBtaW5MZW47XG4gICAgICBkZnMoYyk7XG4gICAgfSk7XG4gIH1cblxuICBkZnModHJlZS5ncmFwaCgpLnJvb3QpO1xufVxuXG4vKlxuICogSWYgdSBhbmQgdiBhcmUgY29ubmVjdGVkIGJ5IHNvbWUgZWRnZXMgaW4gdGhlIGdyYXBoLCByZXR1cm4gdGhlXG4gKiBtaW5pbXVtIGxlbmd0aCBvZiB0aG9zZSBlZGdlcywgYXMgYSBwb3NpdGl2ZSBudW1iZXIgaWYgdiBzdWNjZWVkc1xuICogdSBhbmQgYXMgYSBuZWdhdGl2ZSBudW1iZXIgaWYgdiBwcmVjZWRlcyB1LlxuICovXG5mdW5jdGlvbiBtaW5pbXVtTGVuZ3RoKGdyYXBoLCB1LCB2KSB7XG4gIHZhciBvdXRFZGdlcyA9IGdyYXBoLm91dEVkZ2VzKHUsIHYpO1xuICBpZiAob3V0RWRnZXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB1dGlsLm1heChvdXRFZGdlcy5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGdyYXBoLmVkZ2UoZSkubWluTGVuO1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBpbkVkZ2VzID0gZ3JhcGguaW5FZGdlcyh1LCB2KTtcbiAgaWYgKGluRWRnZXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAtdXRpbC5tYXgoaW5FZGdlcy5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGdyYXBoLmVkZ2UoZSkubWluTGVuO1xuICAgIH0pKTtcbiAgfVxufVxuIiwiLypcbiAqIFJldHVybnMgdGhlIHNtYWxsZXN0IHZhbHVlIGluIHRoZSBhcnJheS5cbiAqL1xuZXhwb3J0cy5taW4gPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XG59O1xuXG4vKlxuICogUmV0dXJucyB0aGUgbGFyZ2VzdCB2YWx1ZSBpbiB0aGUgYXJyYXkuXG4gKi9cbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xufTtcblxuLypcbiAqIFJldHVybnMgYHRydWVgIG9ubHkgaWYgYGYoeClgIGlzIGB0cnVlYCBmb3IgYWxsIGB4YCBpbiBgeHNgLiBPdGhlcndpc2VcbiAqIHJldHVybnMgYGZhbHNlYC4gVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBpbW1lZGlhdGVseSBpZiBpdCBmaW5kcyBhXG4gKiBjYXNlIHdoZXJlIGBmKHgpYCBkb2VzIG5vdCBob2xkLlxuICovXG5leHBvcnRzLmFsbCA9IGZ1bmN0aW9uKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIWYoeHNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLypcbiAqIEFjY3VtdWxhdGVzIHRoZSBzdW0gb2YgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGFycmF5IHVzaW5nIHRoZSBgK2Agb3BlcmF0b3IuXG4gKi9cbmV4cG9ydHMuc3VtID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uKGFjYywgeCkgeyByZXR1cm4gYWNjICsgeDsgfSwgMCk7XG59O1xuXG4vKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdmFsdWVzIGluIHRoZSBnaXZlbiBvYmplY3QuXG4gKi9cbmV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7IHJldHVybiBvYmpba107IH0pO1xufTtcblxuZXhwb3J0cy5zaHVmZmxlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgZm9yIChpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IC0taSkge1xuICAgIHZhciBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgdmFyIGFqID0gYXJyYXlbal07XG4gICAgYXJyYXlbal0gPSBhcnJheVtpXTtcbiAgICBhcnJheVtpXSA9IGFqO1xuICB9XG59O1xuXG5leHBvcnRzLnByb3BlcnR5QWNjZXNzb3IgPSBmdW5jdGlvbihzZWxmLCBjb25maWcsIGZpZWxkLCBzZXRIb29rKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29uZmlnW2ZpZWxkXTtcbiAgICBjb25maWdbZmllbGRdID0geDtcbiAgICBpZiAoc2V0SG9vaykgc2V0SG9vayh4KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcbn07XG5cbi8qXG4gKiBHaXZlbiBhIGxheWVyZWQsIGRpcmVjdGVkIGdyYXBoIHdpdGggYHJhbmtgIGFuZCBgb3JkZXJgIG5vZGUgYXR0cmlidXRlcyxcbiAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBhcnJheSBvZiBvcmRlcmVkIHJhbmtzLiBFYWNoIHJhbmsgY29udGFpbnMgYW4gYXJyYXlcbiAqIG9mIHRoZSBpZHMgb2YgdGhlIG5vZGVzIGluIHRoYXQgcmFuayBpbiB0aGUgb3JkZXIgc3BlY2lmaWVkIGJ5IHRoZSBgb3JkZXJgXG4gKiBhdHRyaWJ1dGUuXG4gKi9cbmV4cG9ydHMub3JkZXJpbmcgPSBmdW5jdGlvbihnKSB7XG4gIHZhciBvcmRlcmluZyA9IFtdO1xuICBnLmVhY2hOb2RlKGZ1bmN0aW9uKHUsIHZhbHVlKSB7XG4gICAgdmFyIHJhbmsgPSBvcmRlcmluZ1t2YWx1ZS5yYW5rXSB8fCAob3JkZXJpbmdbdmFsdWUucmFua10gPSBbXSk7XG4gICAgcmFua1t2YWx1ZS5vcmRlcl0gPSB1O1xuICB9KTtcbiAgcmV0dXJuIG9yZGVyaW5nO1xufTtcblxuLypcbiAqIEEgZmlsdGVyIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBgZmlsdGVyTm9kZXNgIHRvIGdldCBhIGdyYXBoIHRoYXQgb25seVxuICogaW5jbHVkZXMgbm9kZXMgdGhhdCBkbyBub3QgY29udGFpbiBvdGhlcnMgbm9kZXMuXG4gKi9cbmV4cG9ydHMuZmlsdGVyTm9uU3ViZ3JhcGhzID0gZnVuY3Rpb24oZykge1xuICByZXR1cm4gZnVuY3Rpb24odSkge1xuICAgIHJldHVybiBnLmNoaWxkcmVuKHUpLmxlbmd0aCA9PT0gMDtcbiAgfTtcbn07XG5cbi8qXG4gKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHdpdGggYSB0aW1lci4gVGhlIHdyYXBwZXIgbG9ncyB0aGVcbiAqIHRpbWUgaXQgdGFrZXMgdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb24uXG4gKlxuICogVGhlIHRpbWVyIHdpbGwgYmUgZW5hYmxlZCBwcm92aWRlZCBgbG9nLmxldmVsID49IDFgLlxuICovXG5mdW5jdGlvbiB0aW1lKG5hbWUsIGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBsb2coMSwgbmFtZSArICcgdGltZTogJyArIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0KSArICdtcycpO1xuICAgIH1cbiAgfTtcbn1cbnRpbWUuZW5hYmxlZCA9IGZhbHNlO1xuXG5leHBvcnRzLnRpbWUgPSB0aW1lO1xuXG4vKlxuICogQSBnbG9iYWwgbG9nZ2VyIHdpdGggdGhlIHNwZWNpZmljYXRpb24gYGxvZyhsZXZlbCwgbWVzc2FnZSwgLi4uKWAgdGhhdFxuICogd2lsbCBsb2cgYSBtZXNzYWdlIHRvIHRoZSBjb25zb2xlIGlmIGBsb2cubGV2ZWwgPj0gbGV2ZWxgLlxuICovXG5mdW5jdGlvbiBsb2cobGV2ZWwpIHtcbiAgaWYgKGxvZy5sZXZlbCA+PSBsZXZlbCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9XG59XG5sb2cubGV2ZWwgPSAwO1xuXG5leHBvcnRzLmxvZyA9IGxvZztcbiIsIm1vZHVsZS5leHBvcnRzID0gJzAuNC41JztcbiIsImV4cG9ydHMuU2V0ID0gcmVxdWlyZSgnLi9saWIvU2V0Jyk7XG5leHBvcnRzLlByaW9yaXR5UXVldWUgPSByZXF1aXJlKCcuL2xpYi9Qcmlvcml0eVF1ZXVlJyk7XG5leHBvcnRzLnZlcnNpb24gPSByZXF1aXJlKCcuL2xpYi92ZXJzaW9uJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5UXVldWU7XG5cbi8qKlxuICogQSBtaW4tcHJpb3JpdHkgcXVldWUgZGF0YSBzdHJ1Y3R1cmUuIFRoaXMgYWxnb3JpdGhtIGlzIGRlcml2ZWQgZnJvbSBDb3JtZW4sXG4gKiBldCBhbC4sIFwiSW50cm9kdWN0aW9uIHRvIEFsZ29yaXRobXNcIi4gVGhlIGJhc2ljIGlkZWEgb2YgYSBtaW4tcHJpb3JpdHlcbiAqIHF1ZXVlIGlzIHRoYXQgeW91IGNhbiBlZmZpY2llbnRseSAoaW4gTygxKSB0aW1lKSBnZXQgdGhlIHNtYWxsZXN0IGtleSBpblxuICogdGhlIHF1ZXVlLiBBZGRpbmcgYW5kIHJlbW92aW5nIGVsZW1lbnRzIHRha2VzIE8obG9nIG4pIHRpbWUuIEEga2V5IGNhblxuICogaGF2ZSBpdHMgcHJpb3JpdHkgZGVjcmVhc2VkIGluIE8obG9nIG4pIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIFByaW9yaXR5UXVldWUoKSB7XG4gIHRoaXMuX2FyciA9IFtdO1xuICB0aGlzLl9rZXlJbmRpY2VzID0ge307XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS4gVGFrZXMgYE8oMSlgIHRpbWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Fyci5sZW5ndGg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtleXMgdGhhdCBhcmUgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTyhuKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXJyLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiB4LmtleTsgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmICoqa2V5KiogaXMgaW4gdGhlIHF1ZXVlIGFuZCBgZmFsc2VgIGlmIG5vdC5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gIHJldHVybiBrZXkgaW4gdGhpcy5fa2V5SW5kaWNlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJpb3JpdHkgZm9yICoqa2V5KiouIElmICoqa2V5KiogaXMgbm90IHByZXNlbnQgaW4gdGhlIHF1ZXVlXG4gKiB0aGVuIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYC4gVGFrZXMgYE8oMSlgIHRpbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5wcmlvcml0eSA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9rZXlJbmRpY2VzW2tleV07XG4gIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgbWluaW11bSBlbGVtZW50IGluIHRoaXMgcXVldWUuIElmIHRoZSBxdWV1ZSBpc1xuICogZW1wdHkgdGhpcyBmdW5jdGlvbiB0aHJvd3MgYW4gRXJyb3IuIFRha2VzIGBPKDEpYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc2l6ZSgpID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUXVldWUgdW5kZXJmbG93XCIpO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJbMF0ua2V5O1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgbmV3IGtleSBpbnRvIHRoZSBwcmlvcml0eSBxdWV1ZS4gSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0cyBpblxuICogdGhlIHF1ZXVlIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgOyBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gYHRydWVgLlxuICogVGFrZXMgYE8obilgIHRpbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleSB0aGUga2V5IHRvIGFkZFxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IHRoZSBpbml0aWFsIHByaW9yaXR5IGZvciB0aGUga2V5XG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleUluZGljZXMgPSB0aGlzLl9rZXlJbmRpY2VzO1xuICBpZiAoIShrZXkgaW4ga2V5SW5kaWNlcykpIHtcbiAgICB2YXIgYXJyID0gdGhpcy5fYXJyO1xuICAgIHZhciBpbmRleCA9IGFyci5sZW5ndGg7XG4gICAga2V5SW5kaWNlc1trZXldID0gaW5kZXg7XG4gICAgYXJyLnB1c2goe2tleToga2V5LCBwcmlvcml0eTogcHJpb3JpdHl9KTtcbiAgICB0aGlzLl9kZWNyZWFzZShpbmRleCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBzbWFsbGVzdCBrZXkgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTyhsb2cgbilgIHRpbWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnJlbW92ZU1pbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zd2FwKDAsIHRoaXMuX2Fyci5sZW5ndGggLSAxKTtcbiAgdmFyIG1pbiA9IHRoaXMuX2Fyci5wb3AoKTtcbiAgZGVsZXRlIHRoaXMuX2tleUluZGljZXNbbWluLmtleV07XG4gIHRoaXMuX2hlYXBpZnkoMCk7XG4gIHJldHVybiBtaW4ua2V5O1xufTtcblxuLyoqXG4gKiBEZWNyZWFzZXMgdGhlIHByaW9yaXR5IGZvciAqKmtleSoqIHRvICoqcHJpb3JpdHkqKi4gSWYgdGhlIG5ldyBwcmlvcml0eSBpc1xuICogZ3JlYXRlciB0aGFuIHRoZSBwcmV2aW91cyBwcmlvcml0eSwgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXkgdGhlIGtleSBmb3Igd2hpY2ggdG8gcmFpc2UgcHJpb3JpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eSB0aGUgbmV3IHByaW9yaXR5IGZvciB0aGUga2V5XG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmRlY3JlYXNlID0gZnVuY3Rpb24oa2V5LCBwcmlvcml0eSkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9rZXlJbmRpY2VzW2tleV07XG4gIGlmIChwcmlvcml0eSA+IHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXcgcHJpb3JpdHkgaXMgZ3JlYXRlciB0aGFuIGN1cnJlbnQgcHJpb3JpdHkuIFwiICtcbiAgICAgICAgXCJLZXk6IFwiICsga2V5ICsgXCIgT2xkOiBcIiArIHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHkgKyBcIiBOZXc6IFwiICsgcHJpb3JpdHkpO1xuICB9XG4gIHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgdGhpcy5fZGVjcmVhc2UoaW5kZXgpO1xufTtcblxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX2hlYXBpZnkgPSBmdW5jdGlvbihpKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBsID0gMiAqIGksXG4gICAgICByID0gbCArIDEsXG4gICAgICBsYXJnZXN0ID0gaTtcbiAgaWYgKGwgPCBhcnIubGVuZ3RoKSB7XG4gICAgbGFyZ2VzdCA9IGFycltsXS5wcmlvcml0eSA8IGFycltsYXJnZXN0XS5wcmlvcml0eSA/IGwgOiBsYXJnZXN0O1xuICAgIGlmIChyIDwgYXJyLmxlbmd0aCkge1xuICAgICAgbGFyZ2VzdCA9IGFycltyXS5wcmlvcml0eSA8IGFycltsYXJnZXN0XS5wcmlvcml0eSA/IHIgOiBsYXJnZXN0O1xuICAgIH1cbiAgICBpZiAobGFyZ2VzdCAhPT0gaSkge1xuICAgICAgdGhpcy5fc3dhcChpLCBsYXJnZXN0KTtcbiAgICAgIHRoaXMuX2hlYXBpZnkobGFyZ2VzdCk7XG4gICAgfVxuICB9XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5fZGVjcmVhc2UgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgYXJyID0gdGhpcy5fYXJyO1xuICB2YXIgcHJpb3JpdHkgPSBhcnJbaW5kZXhdLnByaW9yaXR5O1xuICB2YXIgcGFyZW50O1xuICB3aGlsZSAoaW5kZXggIT09IDApIHtcbiAgICBwYXJlbnQgPSBpbmRleCA+PiAxO1xuICAgIGlmIChhcnJbcGFyZW50XS5wcmlvcml0eSA8IHByaW9yaXR5KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fc3dhcChpbmRleCwgcGFyZW50KTtcbiAgICBpbmRleCA9IHBhcmVudDtcbiAgfVxufTtcblxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX3N3YXAgPSBmdW5jdGlvbihpLCBqKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBrZXlJbmRpY2VzID0gdGhpcy5fa2V5SW5kaWNlcztcbiAgdmFyIG9yaWdBcnJJID0gYXJyW2ldO1xuICB2YXIgb3JpZ0FyckogPSBhcnJbal07XG4gIGFycltpXSA9IG9yaWdBcnJKO1xuICBhcnJbal0gPSBvcmlnQXJySTtcbiAga2V5SW5kaWNlc1tvcmlnQXJySi5rZXldID0gaTtcbiAga2V5SW5kaWNlc1tvcmlnQXJySS5rZXldID0gajtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFNldCB3aXRoIGFuIG9wdGlvbmFsIHNldCBvZiBgaW5pdGlhbEtleXNgLlxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQga2V5cyBhcmUgY29lcmNlZCB0byBTdHJpbmcgZm9yIG1vc3QgcHVycG9zZXNcbiAqIHdpdGggdGhpcyBvYmplY3QsIHNpbWlsYXIgdG8gdGhlIGJlaGF2aW9yIG9mIEphdmFTY3JpcHQncyBPYmplY3QuIEZvclxuICogZXhhbXBsZSwgdGhlIGZvbGxvd2luZyB3aWxsIGFkZCBvbmx5IG9uZSBrZXk6XG4gKlxuICogICAgIHZhciBzID0gbmV3IFNldCgpO1xuICogICAgIHMuYWRkKDEpO1xuICogICAgIHMuYWRkKFwiMVwiKTtcbiAqXG4gKiBIb3dldmVyLCB0aGUgdHlwZSBvZiB0aGUga2V5IGlzIHByZXNlcnZlZCBpbnRlcm5hbGx5IHNvIHRoYXQgYGtleXNgIHJldHVybnNcbiAqIHRoZSBvcmlnaW5hbCBrZXkgc2V0IHVuY29lcmNlZC4gRm9yIHRoZSBhYm92ZSBleGFtcGxlLCBga2V5c2Agd291bGQgcmV0dXJuXG4gKiBgWzFdYC5cbiAqL1xuZnVuY3Rpb24gU2V0KGluaXRpYWxLZXlzKSB7XG4gIHRoaXMuX3NpemUgPSAwO1xuICB0aGlzLl9rZXlzID0ge307XG5cbiAgaWYgKGluaXRpYWxLZXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gaW5pdGlhbEtleXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdGhpcy5hZGQoaW5pdGlhbEtleXNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgU2V0IHRoYXQgcmVwcmVzZW50cyB0aGUgc2V0IGludGVyc2VjdGlvbiBvZiB0aGUgYXJyYXkgb2YgZ2l2ZW5cbiAqIHNldHMuXG4gKi9cblNldC5pbnRlcnNlY3QgPSBmdW5jdGlvbihzZXRzKSB7XG4gIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgU2V0KCk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFNldCghdXRpbC5pc0FycmF5KHNldHNbMF0pID8gc2V0c1swXS5rZXlzKCkgOiBzZXRzWzBdKTtcbiAgZm9yICh2YXIgaSA9IDEsIGlsID0gc2V0cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgdmFyIHJlc3VsdEtleXMgPSByZXN1bHQua2V5cygpLFxuICAgICAgICBvdGhlciA9ICF1dGlsLmlzQXJyYXkoc2V0c1tpXSkgPyBzZXRzW2ldIDogbmV3IFNldChzZXRzW2ldKTtcbiAgICBmb3IgKHZhciBqID0gMCwgamwgPSByZXN1bHRLZXlzLmxlbmd0aDsgaiA8IGpsOyArK2opIHtcbiAgICAgIHZhciBrZXkgPSByZXN1bHRLZXlzW2pdO1xuICAgICAgaWYgKCFvdGhlci5oYXMoa2V5KSkge1xuICAgICAgICByZXN1bHQucmVtb3ZlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBTZXQgdGhhdCByZXByZXNlbnRzIHRoZSBzZXQgdW5pb24gb2YgdGhlIGFycmF5IG9mIGdpdmVuIHNldHMuXG4gKi9cblNldC51bmlvbiA9IGZ1bmN0aW9uKHNldHMpIHtcbiAgdmFyIHRvdGFsRWxlbXMgPSB1dGlsLnJlZHVjZShzZXRzLCBmdW5jdGlvbihsaHMsIHJocykge1xuICAgIHJldHVybiBsaHMgKyAocmhzLnNpemUgPyByaHMuc2l6ZSgpIDogcmhzLmxlbmd0aCk7XG4gIH0sIDApO1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRvdGFsRWxlbXMpO1xuXG4gIHZhciBrID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGlsID0gc2V0cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgdmFyIGN1ciA9IHNldHNbaV0sXG4gICAgICAgIGtleXMgPSAhdXRpbC5pc0FycmF5KGN1cikgPyBjdXIua2V5cygpIDogY3VyO1xuICAgIGZvciAodmFyIGogPSAwLCBqbCA9IGtleXMubGVuZ3RoOyBqIDwgamw7ICsraikge1xuICAgICAgYXJyW2srK10gPSBrZXlzW2pdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2V0KGFycik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhpcyBzZXQgaW4gYE8oMSlgIHRpbWUuXG4gKi9cblNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2V5cyBpbiB0aGlzIHNldC4gVGFrZXMgYE8obilgIHRpbWUuXG4gKi9cblNldC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdmFsdWVzKHRoaXMuX2tleXMpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiBhIGtleSBpcyBwcmVzZW50IGluIHRoaXMgU2V0LiBSZXR1cm5zIGB0cnVlYCBpZiBpdCBpcyBhbmQgYGZhbHNlYFxuICogaWYgbm90LiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIGtleSBpbiB0aGlzLl9rZXlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgbmV3IGtleSB0byB0aGlzIFNldCBpZiBpdCBpcyBub3QgYWxyZWFkeSBwcmVzZW50LiBSZXR1cm5zIGB0cnVlYCBpZlxuICogdGhlIGtleSB3YXMgYWRkZWQgYW5kIGBmYWxzZWAgaWYgaXQgd2FzIGFscmVhZHkgcHJlc2VudC4gVGFrZXMgYE8oMSlgIHRpbWUuXG4gKi9cblNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oa2V5KSB7XG4gIGlmICghKGtleSBpbiB0aGlzLl9rZXlzKSkge1xuICAgIHRoaXMuX2tleXNba2V5XSA9IGtleTtcbiAgICArK3RoaXMuX3NpemU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEga2V5IGZyb20gdGhpcyBTZXQuIElmIHRoZSBrZXkgd2FzIHJlbW92ZWQgdGhpcyBmdW5jdGlvbiByZXR1cm5zXG4gKiBgdHJ1ZWAuIElmIG5vdCwgaXQgcmV0dXJucyBgZmFsc2VgLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihrZXkpIHtcbiAgaWYgKGtleSBpbiB0aGlzLl9rZXlzKSB7XG4gICAgZGVsZXRlIHRoaXMuX2tleXNba2V5XTtcbiAgICAtLXRoaXMuX3NpemU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLypcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHZhbHVlcyBmb3IgcHJvcGVydGllcyBvZiAqKm8qKi5cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG8pIHtcbiAgdmFyIGtzID0gT2JqZWN0LmtleXMobyksXG4gICAgICBsZW4gPSBrcy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuKSxcbiAgICAgIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IG9ba3NbaV1dO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCIvKlxuICogVGhpcyBwb2x5ZmlsbCBjb21lcyBmcm9tXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG4gKi9cbmlmKCFBcnJheS5pc0FycmF5KSB7XG4gIGV4cG9ydHMuaXNBcnJheSA9IGZ1bmN0aW9uICh2QXJnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2QXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn0gZWxzZSB7XG4gIGV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG59XG5cbi8qXG4gKiBTbGlnaHRseSBhZGFwdGVkIHBvbHlmaWxsIGZyb21cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L1JlZHVjZVxuICovXG5pZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UpIHtcbiAgZXhwb3J0cy5yZWR1Y2UgPSBmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIG9wdF9pbml0aWFsVmFsdWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKG51bGwgPT09IGFycmF5IHx8ICd1bmRlZmluZWQnID09PSB0eXBlb2YgYXJyYXkpIHtcbiAgICAgIC8vIEF0IHRoZSBtb21lbnQgYWxsIG1vZGVybiBicm93c2VycywgdGhhdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBoYXZlXG4gICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgQXJyYXkucHJvdG90eXBlLnJlZHVjZS4gRm9yIGluc3RhbmNlLCBJRThcbiAgICAgIC8vIGRvZXMgbm90IHN1cHBvcnQgc3RyaWN0IG1vZGUsIHNvIHRoaXMgY2hlY2sgaXMgYWN0dWFsbHkgdXNlbGVzcy5cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2UgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBpbmRleCwgdmFsdWUsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgaXNWYWx1ZVNldCA9IGZhbHNlO1xuICAgIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBvcHRfaW5pdGlhbFZhbHVlO1xuICAgICAgaXNWYWx1ZVNldCA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaW5kZXggPSAwOyBsZW5ndGggPiBpbmRleDsgKytpbmRleCkge1xuICAgICAgaWYgKGFycmF5Lmhhc093blByb3BlcnR5KGluZGV4KSkge1xuICAgICAgICBpZiAoaXNWYWx1ZVNldCkge1xuICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgICBpc1ZhbHVlU2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzVmFsdWVTZXQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufSBlbHNlIHtcbiAgZXhwb3J0cy5yZWR1Y2UgPSBmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIG9wdF9pbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKGNhbGxiYWNrLCBvcHRfaW5pdGlhbFZhbHVlKTtcbiAgfTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gJzEuMS4zJztcbiIsImV4cG9ydHMuR3JhcGggPSByZXF1aXJlKFwiLi9saWIvR3JhcGhcIik7XG5leHBvcnRzLkRpZ3JhcGggPSByZXF1aXJlKFwiLi9saWIvRGlncmFwaFwiKTtcbmV4cG9ydHMuQ0dyYXBoID0gcmVxdWlyZShcIi4vbGliL0NHcmFwaFwiKTtcbmV4cG9ydHMuQ0RpZ3JhcGggPSByZXF1aXJlKFwiLi9saWIvQ0RpZ3JhcGhcIik7XG5yZXF1aXJlKFwiLi9saWIvZ3JhcGgtY29udmVydGVyc1wiKTtcblxuZXhwb3J0cy5hbGcgPSB7XG4gIGlzQWN5Y2xpYzogcmVxdWlyZShcIi4vbGliL2FsZy9pc0FjeWNsaWNcIiksXG4gIGNvbXBvbmVudHM6IHJlcXVpcmUoXCIuL2xpYi9hbGcvY29tcG9uZW50c1wiKSxcbiAgZGlqa3N0cmE6IHJlcXVpcmUoXCIuL2xpYi9hbGcvZGlqa3N0cmFcIiksXG4gIGRpamtzdHJhQWxsOiByZXF1aXJlKFwiLi9saWIvYWxnL2RpamtzdHJhQWxsXCIpLFxuICBmaW5kQ3ljbGVzOiByZXF1aXJlKFwiLi9saWIvYWxnL2ZpbmRDeWNsZXNcIiksXG4gIGZsb3lkV2Fyc2hhbGw6IHJlcXVpcmUoXCIuL2xpYi9hbGcvZmxveWRXYXJzaGFsbFwiKSxcbiAgcG9zdG9yZGVyOiByZXF1aXJlKFwiLi9saWIvYWxnL3Bvc3RvcmRlclwiKSxcbiAgcHJlb3JkZXI6IHJlcXVpcmUoXCIuL2xpYi9hbGcvcHJlb3JkZXJcIiksXG4gIHByaW06IHJlcXVpcmUoXCIuL2xpYi9hbGcvcHJpbVwiKSxcbiAgdGFyamFuOiByZXF1aXJlKFwiLi9saWIvYWxnL3RhcmphblwiKSxcbiAgdG9wc29ydDogcmVxdWlyZShcIi4vbGliL2FsZy90b3Bzb3J0XCIpXG59O1xuXG5leHBvcnRzLmNvbnZlcnRlciA9IHtcbiAganNvbjogcmVxdWlyZShcIi4vbGliL2NvbnZlcnRlci9qc29uLmpzXCIpXG59O1xuXG52YXIgZmlsdGVyID0gcmVxdWlyZShcIi4vbGliL2ZpbHRlclwiKTtcbmV4cG9ydHMuZmlsdGVyID0ge1xuICBhbGw6IGZpbHRlci5hbGwsXG4gIG5vZGVzRnJvbUxpc3Q6IGZpbHRlci5ub2Rlc0Zyb21MaXN0XG59O1xuXG5leHBvcnRzLnZlcnNpb24gPSByZXF1aXJlKFwiLi9saWIvdmVyc2lvblwiKTtcbiIsIi8qIGpzaGludCAtVzA3OSAqL1xudmFyIFNldCA9IHJlcXVpcmUoXCJjcC1kYXRhXCIpLlNldDtcbi8qIGpzaGludCArVzA3OSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VHcmFwaDtcblxuZnVuY3Rpb24gQmFzZUdyYXBoKCkge1xuICAvLyBUaGUgdmFsdWUgYXNzaWduZWQgdG8gdGhlIGdyYXBoIGl0c2VsZi5cbiAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgLy8gTWFwIG9mIG5vZGUgaWQgLT4geyBpZCwgdmFsdWUgfVxuICB0aGlzLl9ub2RlcyA9IHt9O1xuXG4gIC8vIE1hcCBvZiBlZGdlIGlkIC0+IHsgaWQsIHUsIHYsIHZhbHVlIH1cbiAgdGhpcy5fZWRnZXMgPSB7fTtcblxuICAvLyBVc2VkIHRvIGdlbmVyYXRlIGEgdW5pcXVlIGlkIGluIHRoZSBncmFwaFxuICB0aGlzLl9uZXh0SWQgPSAwO1xufVxuXG4vLyBOdW1iZXIgb2Ygbm9kZXNcbkJhc2VHcmFwaC5wcm90b3R5cGUub3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX25vZGVzKS5sZW5ndGg7XG59O1xuXG4vLyBOdW1iZXIgb2YgZWRnZXNcbkJhc2VHcmFwaC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZWRnZXMpLmxlbmd0aDtcbn07XG5cbi8vIEFjY2Vzc29yIGZvciBncmFwaCBsZXZlbCB2YWx1ZVxuQmFzZUdyYXBoLnByb3RvdHlwZS5ncmFwaCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG59O1xuXG5CYXNlR3JhcGgucHJvdG90eXBlLmhhc05vZGUgPSBmdW5jdGlvbih1KSB7XG4gIHJldHVybiB1IGluIHRoaXMuX25vZGVzO1xufTtcblxuQmFzZUdyYXBoLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24odSwgdmFsdWUpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLl9zdHJpY3RHZXROb2RlKHUpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9XG4gIG5vZGUudmFsdWUgPSB2YWx1ZTtcbn07XG5cbkJhc2VHcmFwaC5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gW107XG4gIHRoaXMuZWFjaE5vZGUoZnVuY3Rpb24oaWQpIHsgbm9kZXMucHVzaChpZCk7IH0pO1xuICByZXR1cm4gbm9kZXM7XG59O1xuXG5CYXNlR3JhcGgucHJvdG90eXBlLmVhY2hOb2RlID0gZnVuY3Rpb24oZnVuYykge1xuICBmb3IgKHZhciBrIGluIHRoaXMuX25vZGVzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1trXTtcbiAgICBmdW5jKG5vZGUuaWQsIG5vZGUudmFsdWUpO1xuICB9XG59O1xuXG5CYXNlR3JhcGgucHJvdG90eXBlLmhhc0VkZ2UgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlIGluIHRoaXMuX2VkZ2VzO1xufTtcblxuQmFzZUdyYXBoLnByb3RvdHlwZS5lZGdlID0gZnVuY3Rpb24oZSwgdmFsdWUpIHtcbiAgdmFyIGVkZ2UgPSB0aGlzLl9zdHJpY3RHZXRFZGdlKGUpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBlZGdlLnZhbHVlO1xuICB9XG4gIGVkZ2UudmFsdWUgPSB2YWx1ZTtcbn07XG5cbkJhc2VHcmFwaC5wcm90b3R5cGUuZWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVzID0gW107XG4gIHRoaXMuZWFjaEVkZ2UoZnVuY3Rpb24oaWQpIHsgZXMucHVzaChpZCk7IH0pO1xuICByZXR1cm4gZXM7XG59O1xuXG5CYXNlR3JhcGgucHJvdG90eXBlLmVhY2hFZGdlID0gZnVuY3Rpb24oZnVuYykge1xuICBmb3IgKHZhciBrIGluIHRoaXMuX2VkZ2VzKSB7XG4gICAgdmFyIGVkZ2UgPSB0aGlzLl9lZGdlc1trXTtcbiAgICBmdW5jKGVkZ2UuaWQsIGVkZ2UudSwgZWRnZS52LCBlZGdlLnZhbHVlKTtcbiAgfVxufTtcblxuQmFzZUdyYXBoLnByb3RvdHlwZS5pbmNpZGVudE5vZGVzID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZWRnZSA9IHRoaXMuX3N0cmljdEdldEVkZ2UoZSk7XG4gIHJldHVybiBbZWRnZS51LCBlZGdlLnZdO1xufTtcblxuQmFzZUdyYXBoLnByb3RvdHlwZS5hZGROb2RlID0gZnVuY3Rpb24odSwgdmFsdWUpIHtcbiAgaWYgKHUgPT09IHVuZGVmaW5lZCB8fCB1ID09PSBudWxsKSB7XG4gICAgZG8ge1xuICAgICAgdSA9IFwiX1wiICsgKCsrdGhpcy5fbmV4dElkKTtcbiAgICB9IHdoaWxlICh0aGlzLmhhc05vZGUodSkpO1xuICB9IGVsc2UgaWYgKHRoaXMuaGFzTm9kZSh1KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkdyYXBoIGFscmVhZHkgaGFzIG5vZGUgJ1wiICsgdSArIFwiJ1wiKTtcbiAgfVxuICB0aGlzLl9ub2Rlc1t1XSA9IHsgaWQ6IHUsIHZhbHVlOiB2YWx1ZSB9O1xuICByZXR1cm4gdTtcbn07XG5cbkJhc2VHcmFwaC5wcm90b3R5cGUuZGVsTm9kZSA9IGZ1bmN0aW9uKHUpIHtcbiAgdGhpcy5fc3RyaWN0R2V0Tm9kZSh1KTtcbiAgdGhpcy5pbmNpZGVudEVkZ2VzKHUpLmZvckVhY2goZnVuY3Rpb24oZSkgeyB0aGlzLmRlbEVkZ2UoZSk7IH0sIHRoaXMpO1xuICBkZWxldGUgdGhpcy5fbm9kZXNbdV07XG59O1xuXG4vLyBpbk1hcCBhbmQgb3V0TWFwIGFyZSBvcHBvc2l0ZSBzaWRlcyBvZiBhbiBpbmNpZGVuY2UgbWFwLiBGb3IgZXhhbXBsZSwgZm9yXG4vLyBHcmFwaCB0aGVzZSB3b3VsZCBib3RoIGNvbWUgZnJvbSB0aGUgX2luY2lkZW50RWRnZXMgbWFwLCB3aGlsZSBmb3IgRGlncmFwaFxuLy8gdGhleSB3b3VsZCBjb21lIGZyb20gX2luRWRnZXMgYW5kIF9vdXRFZGdlcy5cbkJhc2VHcmFwaC5wcm90b3R5cGUuX2FkZEVkZ2UgPSBmdW5jdGlvbihlLCB1LCB2LCB2YWx1ZSwgaW5NYXAsIG91dE1hcCkge1xuICB0aGlzLl9zdHJpY3RHZXROb2RlKHUpO1xuICB0aGlzLl9zdHJpY3RHZXROb2RlKHYpO1xuXG4gIGlmIChlID09PSB1bmRlZmluZWQgfHwgZSA9PT0gbnVsbCkge1xuICAgIGRvIHtcbiAgICAgIGUgPSBcIl9cIiArICgrK3RoaXMuX25leHRJZCk7XG4gICAgfSB3aGlsZSAodGhpcy5oYXNFZGdlKGUpKTtcbiAgfVxuICBlbHNlIGlmICh0aGlzLmhhc0VkZ2UoZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJHcmFwaCBhbHJlYWR5IGhhcyBlZGdlICdcIiArIGUgKyBcIidcIik7XG4gIH1cblxuICB0aGlzLl9lZGdlc1tlXSA9IHsgaWQ6IGUsIHU6IHUsIHY6IHYsIHZhbHVlOiB2YWx1ZSB9O1xuICBhZGRFZGdlVG9NYXAoaW5NYXBbdl0sIHUsIGUpO1xuICBhZGRFZGdlVG9NYXAob3V0TWFwW3VdLCB2LCBlKTtcblxuICByZXR1cm4gZTtcbn07XG5cbi8vIFNlZSBub3RlIGZvciBfYWRkRWRnZSByZWdhcmRpbmcgaW5NYXAgYW5kIG91dE1hcC5cbkJhc2VHcmFwaC5wcm90b3R5cGUuX2RlbEVkZ2UgPSBmdW5jdGlvbihlLCBpbk1hcCwgb3V0TWFwKSB7XG4gIHZhciBlZGdlID0gdGhpcy5fc3RyaWN0R2V0RWRnZShlKTtcbiAgZGVsRWRnZUZyb21NYXAoaW5NYXBbZWRnZS52XSwgZWRnZS51LCBlKTtcbiAgZGVsRWRnZUZyb21NYXAob3V0TWFwW2VkZ2UudV0sIGVkZ2UudiwgZSk7XG4gIGRlbGV0ZSB0aGlzLl9lZGdlc1tlXTtcbn07XG5cbkJhc2VHcmFwaC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29weSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gIGNvcHkuZ3JhcGgodGhpcy5ncmFwaCgpKTtcbiAgdGhpcy5lYWNoTm9kZShmdW5jdGlvbih1LCB2YWx1ZSkgeyBjb3B5LmFkZE5vZGUodSwgdmFsdWUpOyB9KTtcbiAgdGhpcy5lYWNoRWRnZShmdW5jdGlvbihlLCB1LCB2LCB2YWx1ZSkgeyBjb3B5LmFkZEVkZ2UoZSwgdSwgdiwgdmFsdWUpOyB9KTtcbiAgY29weS5fbmV4dElkID0gdGhpcy5fbmV4dElkO1xuICByZXR1cm4gY29weTtcbn07XG5cbkJhc2VHcmFwaC5wcm90b3R5cGUuZmlsdGVyTm9kZXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgdmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICBjb3B5LmdyYXBoKHRoaXMuZ3JhcGgoKSk7XG4gIHRoaXMuZWFjaE5vZGUoZnVuY3Rpb24odSwgdmFsdWUpIHtcbiAgICBpZiAoZmlsdGVyKHUpKSB7XG4gICAgICBjb3B5LmFkZE5vZGUodSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuZWFjaEVkZ2UoZnVuY3Rpb24oZSwgdSwgdiwgdmFsdWUpIHtcbiAgICBpZiAoY29weS5oYXNOb2RlKHUpICYmIGNvcHkuaGFzTm9kZSh2KSkge1xuICAgICAgY29weS5hZGRFZGdlKGUsIHUsIHYsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29weTtcbn07XG5cbkJhc2VHcmFwaC5wcm90b3R5cGUuX3N0cmljdEdldE5vZGUgPSBmdW5jdGlvbih1KSB7XG4gIHZhciBub2RlID0gdGhpcy5fbm9kZXNbdV07XG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlICdcIiArIHUgKyBcIicgaXMgbm90IGluIGdyYXBoXCIpO1xuICB9XG4gIHJldHVybiBub2RlO1xufTtcblxuQmFzZUdyYXBoLnByb3RvdHlwZS5fc3RyaWN0R2V0RWRnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGVkZ2UgPSB0aGlzLl9lZGdlc1tlXTtcbiAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVkZ2UgJ1wiICsgZSArIFwiJyBpcyBub3QgaW4gZ3JhcGhcIik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59O1xuXG5mdW5jdGlvbiBhZGRFZGdlVG9NYXAobWFwLCB2LCBlKSB7XG4gIChtYXBbdl0gfHwgKG1hcFt2XSA9IG5ldyBTZXQoKSkpLmFkZChlKTtcbn1cblxuZnVuY3Rpb24gZGVsRWRnZUZyb21NYXAobWFwLCB2LCBlKSB7XG4gIHZhciB2RW50cnkgPSBtYXBbdl07XG4gIHZFbnRyeS5yZW1vdmUoZSk7XG4gIGlmICh2RW50cnkuc2l6ZSgpID09PSAwKSB7XG4gICAgZGVsZXRlIG1hcFt2XTtcbiAgfVxufVxuXG4iLCJ2YXIgRGlncmFwaCA9IHJlcXVpcmUoXCIuL0RpZ3JhcGhcIiksXG4gICAgY29tcG91bmRpZnkgPSByZXF1aXJlKFwiLi9jb21wb3VuZGlmeVwiKTtcblxudmFyIENEaWdyYXBoID0gY29tcG91bmRpZnkoRGlncmFwaCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ0RpZ3JhcGg7XG5cbkNEaWdyYXBoLmZyb21EaWdyYXBoID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciBnID0gbmV3IENEaWdyYXBoKCksXG4gICAgICBncmFwaFZhbHVlID0gc3JjLmdyYXBoKCk7XG5cbiAgaWYgKGdyYXBoVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGcuZ3JhcGgoZ3JhcGhWYWx1ZSk7XG4gIH1cblxuICBzcmMuZWFjaE5vZGUoZnVuY3Rpb24odSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZy5hZGROb2RlKHUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnLmFkZE5vZGUodSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHNyYy5lYWNoRWRnZShmdW5jdGlvbihlLCB1LCB2LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBnLmFkZEVkZ2UobnVsbCwgdSwgdik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGcuYWRkRWRnZShudWxsLCB1LCB2LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGc7XG59O1xuXG5DRGlncmFwaC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiQ0RpZ3JhcGggXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAyKTtcbn07XG4iLCJ2YXIgR3JhcGggPSByZXF1aXJlKFwiLi9HcmFwaFwiKSxcbiAgICBjb21wb3VuZGlmeSA9IHJlcXVpcmUoXCIuL2NvbXBvdW5kaWZ5XCIpO1xuXG52YXIgQ0dyYXBoID0gY29tcG91bmRpZnkoR3JhcGgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENHcmFwaDtcblxuQ0dyYXBoLmZyb21HcmFwaCA9IGZ1bmN0aW9uKHNyYykge1xuICB2YXIgZyA9IG5ldyBDR3JhcGgoKSxcbiAgICAgIGdyYXBoVmFsdWUgPSBzcmMuZ3JhcGgoKTtcblxuICBpZiAoZ3JhcGhWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZy5ncmFwaChncmFwaFZhbHVlKTtcbiAgfVxuXG4gIHNyYy5lYWNoTm9kZShmdW5jdGlvbih1LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBnLmFkZE5vZGUodSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGcuYWRkTm9kZSh1LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgc3JjLmVhY2hFZGdlKGZ1bmN0aW9uKGUsIHUsIHYsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGcuYWRkRWRnZShudWxsLCB1LCB2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZy5hZGRFZGdlKG51bGwsIHUsIHYsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZztcbn07XG5cbkNHcmFwaC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiQ0dyYXBoIFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcywgbnVsbCwgMik7XG59O1xuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBvcmdhbml6ZWQgd2l0aCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICpcbiAqIEV4cG9ydHNcbiAqIEdyYXBoIGNvbnN0cnVjdG9yc1xuICogR3JhcGggcXVlcmllcyAoZS5nLiBub2RlcygpLCBlZGdlcygpXG4gKiBHcmFwaCBtdXRhdG9yc1xuICogSGVscGVyIGZ1bmN0aW9uc1xuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBCYXNlR3JhcGggPSByZXF1aXJlKFwiLi9CYXNlR3JhcGhcIiksXG4vKiBqc2hpbnQgLVcwNzkgKi9cbiAgICBTZXQgPSByZXF1aXJlKFwiY3AtZGF0YVwiKS5TZXQ7XG4vKiBqc2hpbnQgK1cwNzkgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBEaWdyYXBoO1xuXG4vKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgbmV3IGRpcmVjdGVkIG11bHRpLWdyYXBoLlxuICovXG5mdW5jdGlvbiBEaWdyYXBoKCkge1xuICBCYXNlR3JhcGguY2FsbCh0aGlzKTtcblxuICAvKiEgTWFwIG9mIHNvdXJjZUlkIC0+IHt0YXJnZXRJZCAtPiBTZXQgb2YgZWRnZSBpZHN9ICovXG4gIHRoaXMuX2luRWRnZXMgPSB7fTtcblxuICAvKiEgTWFwIG9mIHRhcmdldElkIC0+IHtzb3VyY2VJZCAtPiBTZXQgb2YgZWRnZSBpZHN9ICovXG4gIHRoaXMuX291dEVkZ2VzID0ge307XG59XG5cbkRpZ3JhcGgucHJvdG90eXBlID0gbmV3IEJhc2VHcmFwaCgpO1xuRGlncmFwaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaWdyYXBoO1xuXG4vKlxuICogQWx3YXlzIHJldHVybnMgYHRydWVgLlxuICovXG5EaWdyYXBoLnByb3RvdHlwZS5pc0RpcmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLypcbiAqIFJldHVybnMgYWxsIHN1Y2Nlc3NvcnMgb2YgdGhlIG5vZGUgd2l0aCB0aGUgaWQgYHVgLiBUaGF0IGlzLCBhbGwgbm9kZXNcbiAqIHRoYXQgaGF2ZSB0aGUgbm9kZSBgdWAgYXMgdGhlaXIgc291cmNlIGFyZSByZXR1cm5lZC5cbiAqIFxuICogSWYgbm8gbm9kZSBgdWAgZXhpc3RzIGluIHRoZSBncmFwaCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBFcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdSBhIG5vZGUgaWRcbiAqL1xuRGlncmFwaC5wcm90b3R5cGUuc3VjY2Vzc29ycyA9IGZ1bmN0aW9uKHUpIHtcbiAgdGhpcy5fc3RyaWN0R2V0Tm9kZSh1KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX291dEVkZ2VzW3VdKVxuICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB0aGlzLl9ub2Rlc1t2XS5pZDsgfSwgdGhpcyk7XG59O1xuXG4vKlxuICogUmV0dXJucyBhbGwgcHJlZGVjZXNzb3JzIG9mIHRoZSBub2RlIHdpdGggdGhlIGlkIGB1YC4gVGhhdCBpcywgYWxsIG5vZGVzXG4gKiB0aGF0IGhhdmUgdGhlIG5vZGUgYHVgIGFzIHRoZWlyIHRhcmdldCBhcmUgcmV0dXJuZWQuXG4gKiBcbiAqIElmIG5vIG5vZGUgYHVgIGV4aXN0cyBpbiB0aGUgZ3JhcGggdGhpcyBmdW5jdGlvbiB0aHJvd3MgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHUgYSBub2RlIGlkXG4gKi9cbkRpZ3JhcGgucHJvdG90eXBlLnByZWRlY2Vzc29ycyA9IGZ1bmN0aW9uKHUpIHtcbiAgdGhpcy5fc3RyaWN0R2V0Tm9kZSh1KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2luRWRnZXNbdV0pXG4gICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHRoaXMuX25vZGVzW3ZdLmlkOyB9LCB0aGlzKTtcbn07XG5cbi8qXG4gKiBSZXR1cm5zIGFsbCBub2RlcyB0aGF0IGFyZSBhZGphY2VudCB0byB0aGUgbm9kZSB3aXRoIHRoZSBpZCBgdWAuIEluIG90aGVyXG4gKiB3b3JkcywgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBzZXQgb2YgYWxsIHN1Y2Nlc3NvcnMgYW5kIHByZWRlY2Vzc29ycyBvZlxuICogbm9kZSBgdWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHUgYSBub2RlIGlkXG4gKi9cbkRpZ3JhcGgucHJvdG90eXBlLm5laWdoYm9ycyA9IGZ1bmN0aW9uKHUpIHtcbiAgcmV0dXJuIFNldC51bmlvbihbdGhpcy5zdWNjZXNzb3JzKHUpLCB0aGlzLnByZWRlY2Vzc29ycyh1KV0pLmtleXMoKTtcbn07XG5cbi8qXG4gKiBSZXR1cm5zIGFsbCBub2RlcyBpbiB0aGUgZ3JhcGggdGhhdCBoYXZlIG5vIGluLWVkZ2VzLlxuICovXG5EaWdyYXBoLnByb3RvdHlwZS5zb3VyY2VzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuX2ZpbHRlck5vZGVzKGZ1bmN0aW9uKHUpIHtcbiAgICAvLyBUaGlzIGNvdWxkIGhhdmUgYmV0dGVyIHNwYWNlIGNoYXJhY3RlcmlzdGljcyBpZiB3ZSBoYWQgYW4gaW5EZWdyZWUgZnVuY3Rpb24uXG4gICAgcmV0dXJuIHNlbGYuaW5FZGdlcyh1KS5sZW5ndGggPT09IDA7XG4gIH0pO1xufTtcblxuLypcbiAqIFJldHVybnMgYWxsIG5vZGVzIGluIHRoZSBncmFwaCB0aGF0IGhhdmUgbm8gb3V0LWVkZ2VzLlxuICovXG5EaWdyYXBoLnByb3RvdHlwZS5zaW5rcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLl9maWx0ZXJOb2RlcyhmdW5jdGlvbih1KSB7XG4gICAgLy8gVGhpcyBjb3VsZCBoYXZlIGJldHRlciBzcGFjZSBjaGFyYWN0ZXJpc3RpY3MgaWYgd2UgaGF2ZSBhbiBvdXREZWdyZWUgZnVuY3Rpb24uXG4gICAgcmV0dXJuIHNlbGYub3V0RWRnZXModSkubGVuZ3RoID09PSAwO1xuICB9KTtcbn07XG5cbi8qXG4gKiBSZXR1cm5zIHRoZSBzb3VyY2Ugbm9kZSBpbmNpZGVudCBvbiB0aGUgZWRnZSBpZGVudGlmaWVkIGJ5IHRoZSBpZCBgZWAuIElmIG5vXG4gKiBzdWNoIGVkZ2UgZXhpc3RzIGluIHRoZSBncmFwaCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBFcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZSBhbiBlZGdlIGlkXG4gKi9cbkRpZ3JhcGgucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHRoaXMuX3N0cmljdEdldEVkZ2UoZSkudTtcbn07XG5cbi8qXG4gKiBSZXR1cm5zIHRoZSB0YXJnZXQgbm9kZSBpbmNpZGVudCBvbiB0aGUgZWRnZSBpZGVudGlmaWVkIGJ5IHRoZSBpZCBgZWAuIElmIG5vXG4gKiBzdWNoIGVkZ2UgZXhpc3RzIGluIHRoZSBncmFwaCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBFcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZSBhbiBlZGdlIGlkXG4gKi9cbkRpZ3JhcGgucHJvdG90eXBlLnRhcmdldCA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHRoaXMuX3N0cmljdEdldEVkZ2UoZSkudjtcbn07XG5cbi8qXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGlkcyBmb3IgYWxsIGVkZ2VzIGluIHRoZSBncmFwaCB0aGF0IGhhdmUgdGhlIG5vZGVcbiAqIGB0YXJnZXRgIGFzIHRoZWlyIHRhcmdldC4gSWYgdGhlIG5vZGUgYHRhcmdldGAgaXMgbm90IGluIHRoZSBncmFwaCB0aGlzXG4gKiBmdW5jdGlvbiByYWlzZXMgYW4gRXJyb3IuXG4gKlxuICogT3B0aW9uYWxseSBhIGBzb3VyY2VgIG5vZGUgY2FuIGFsc28gYmUgc3BlY2lmaWVkLiBUaGlzIGNhdXNlcyB0aGUgcmVzdWx0c1xuICogdG8gYmUgZmlsdGVyZWQgc3VjaCB0aGF0IG9ubHkgZWRnZXMgZnJvbSBgc291cmNlYCB0byBgdGFyZ2V0YCBhcmUgaW5jbHVkZWQuXG4gKiBJZiB0aGUgbm9kZSBgc291cmNlYCBpcyBzcGVjaWZpZWQgYnV0IGlzIG5vdCBpbiB0aGUgZ3JhcGggdGhlbiB0aGlzIGZ1bmN0aW9uXG4gKiByYWlzZXMgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldCB0aGUgdGFyZ2V0IG5vZGUgaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc291cmNlXSBhbiBvcHRpb25hbCBzb3VyY2Ugbm9kZSBpZFxuICovXG5EaWdyYXBoLnByb3RvdHlwZS5pbkVkZ2VzID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgdGhpcy5fc3RyaWN0R2V0Tm9kZSh0YXJnZXQpO1xuICB2YXIgcmVzdWx0cyA9IFNldC51bmlvbih1dGlsLnZhbHVlcyh0aGlzLl9pbkVkZ2VzW3RhcmdldF0pKS5rZXlzKCk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRoaXMuX3N0cmljdEdldE5vZGUoc291cmNlKTtcbiAgICByZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5zb3VyY2UoZSkgPT09IHNvdXJjZTsgfSwgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBpZHMgZm9yIGFsbCBlZGdlcyBpbiB0aGUgZ3JhcGggdGhhdCBoYXZlIHRoZSBub2RlXG4gKiBgc291cmNlYCBhcyB0aGVpciBzb3VyY2UuIElmIHRoZSBub2RlIGBzb3VyY2VgIGlzIG5vdCBpbiB0aGUgZ3JhcGggdGhpc1xuICogZnVuY3Rpb24gcmFpc2VzIGFuIEVycm9yLlxuICpcbiAqIE9wdGlvbmFsbHkgYSBgdGFyZ2V0YCBub2RlIG1heSBhbHNvIGJlIHNwZWNpZmllZC4gVGhpcyBjYXVzZXMgdGhlIHJlc3VsdHNcbiAqIHRvIGJlIGZpbHRlcmVkIHN1Y2ggdGhhdCBvbmx5IGVkZ2VzIGZyb20gYHNvdXJjZWAgdG8gYHRhcmdldGAgYXJlIGluY2x1ZGVkLlxuICogSWYgdGhlIG5vZGUgYHRhcmdldGAgaXMgc3BlY2lmaWVkIGJ1dCBpcyBub3QgaW4gdGhlIGdyYXBoIHRoZW4gdGhpcyBmdW5jdGlvblxuICogcmFpc2VzIGFuIEVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgdGhlIHNvdXJjZSBub2RlIGlkXG4gKiBAcGFyYW0ge1N0cmluZ30gW3RhcmdldF0gYW4gb3B0aW9uYWwgdGFyZ2V0IG5vZGUgaWRcbiAqL1xuRGlncmFwaC5wcm90b3R5cGUub3V0RWRnZXMgPSBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCkge1xuICB0aGlzLl9zdHJpY3RHZXROb2RlKHNvdXJjZSk7XG4gIHZhciByZXN1bHRzID0gU2V0LnVuaW9uKHV0aWwudmFsdWVzKHRoaXMuX291dEVkZ2VzW3NvdXJjZV0pKS5rZXlzKCk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRoaXMuX3N0cmljdEdldE5vZGUodGFyZ2V0KTtcbiAgICByZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy50YXJnZXQoZSkgPT09IHRhcmdldDsgfSwgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBpZHMgZm9yIGFsbCBlZGdlcyBpbiB0aGUgZ3JhcGggdGhhdCBoYXZlIHRoZSBgdWAgYXNcbiAqIHRoZWlyIHNvdXJjZSBvciB0aGVpciB0YXJnZXQuIElmIHRoZSBub2RlIGB1YCBpcyBub3QgaW4gdGhlIGdyYXBoIHRoaXNcbiAqIGZ1bmN0aW9uIHJhaXNlcyBhbiBFcnJvci5cbiAqXG4gKiBPcHRpb25hbGx5IGEgYHZgIG5vZGUgbWF5IGFsc28gYmUgc3BlY2lmaWVkLiBUaGlzIGNhdXNlcyB0aGUgcmVzdWx0cyB0byBiZVxuICogZmlsdGVyZWQgc3VjaCB0aGF0IG9ubHkgZWRnZXMgYmV0d2VlbiBgdWAgYW5kIGB2YCAtIGluIGVpdGhlciBkaXJlY3Rpb24gLVxuICogYXJlIGluY2x1ZGVkLiBJRiB0aGUgbm9kZSBgdmAgaXMgc3BlY2lmaWVkIGJ1dCBub3QgaW4gdGhlIGdyYXBoIHRoZW4gdGhpc1xuICogZnVuY3Rpb24gcmFpc2VzIGFuIEVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1IHRoZSBub2RlIGZvciB3aGljaCB0byBmaW5kIGluY2lkZW50IGVkZ2VzXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ZdIG9wdGlvbiBub2RlIHRoYXQgbXVzdCBiZSBhZGphY2VudCB0byBgdWBcbiAqL1xuRGlncmFwaC5wcm90b3R5cGUuaW5jaWRlbnRFZGdlcyA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIFNldC51bmlvbihbdGhpcy5vdXRFZGdlcyh1LCB2KSwgdGhpcy5vdXRFZGdlcyh2LCB1KV0pLmtleXMoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gU2V0LnVuaW9uKFt0aGlzLmluRWRnZXModSksIHRoaXMub3V0RWRnZXModSldKS5rZXlzKCk7XG4gIH1cbn07XG5cbi8qXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZ3JhcGguXG4gKi9cbkRpZ3JhcGgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcIkRpZ3JhcGggXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAyKTtcbn07XG5cbi8qXG4gKiBBZGRzIGEgbmV3IG5vZGUgd2l0aCB0aGUgaWQgYHVgIHRvIHRoZSBncmFwaCBhbmQgYXNzaWducyBpdCB0aGUgdmFsdWVcbiAqIGB2YWx1ZWAuIElmIGEgbm9kZSB3aXRoIHRoZSBpZCBpcyBhbHJlYWR5IGEgcGFydCBvZiB0aGUgZ3JhcGggdGhpcyBmdW5jdGlvblxuICogdGhyb3dzIGFuIEVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1IGEgbm9kZSBpZFxuICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZV0gYW4gb3B0aW9uYWwgdmFsdWUgdG8gYXR0YWNoIHRvIHRoZSBub2RlXG4gKi9cbkRpZ3JhcGgucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbih1LCB2YWx1ZSkge1xuICB1ID0gQmFzZUdyYXBoLnByb3RvdHlwZS5hZGROb2RlLmNhbGwodGhpcywgdSwgdmFsdWUpO1xuICB0aGlzLl9pbkVkZ2VzW3VdID0ge307XG4gIHRoaXMuX291dEVkZ2VzW3VdID0ge307XG4gIHJldHVybiB1O1xufTtcblxuLypcbiAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhlIGdyYXBoIHRoYXQgaGFzIHRoZSBpZCBgdWAuIEFueSBlZGdlcyBpbmNpZGVudCBvbiB0aGVcbiAqIG5vZGUgYXJlIGFsc28gcmVtb3ZlZC4gSWYgdGhlIGdyYXBoIGRvZXMgbm90IGNvbnRhaW4gYSBub2RlIHdpdGggdGhlIGlkIHRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHUgYSBub2RlIGlkXG4gKi9cbkRpZ3JhcGgucHJvdG90eXBlLmRlbE5vZGUgPSBmdW5jdGlvbih1KSB7XG4gIEJhc2VHcmFwaC5wcm90b3R5cGUuZGVsTm9kZS5jYWxsKHRoaXMsIHUpO1xuICBkZWxldGUgdGhpcy5faW5FZGdlc1t1XTtcbiAgZGVsZXRlIHRoaXMuX291dEVkZ2VzW3VdO1xufTtcblxuLypcbiAqIEFkZHMgYSBuZXcgZWRnZSB0byB0aGUgZ3JhcGggd2l0aCB0aGUgaWQgYGVgIGZyb20gYSBub2RlIHdpdGggdGhlIGlkIGBzb3VyY2VgXG4gKiB0byBhIG5vZGUgd2l0aCBhbiBpZCBgdGFyZ2V0YCBhbmQgYXNzaWducyBpdCB0aGUgdmFsdWUgYHZhbHVlYC4gVGhpcyBncmFwaFxuICogYWxsb3dzIG1vcmUgdGhhbiBvbmUgZWRnZSBmcm9tIGBzb3VyY2VgIHRvIGB0YXJnZXRgIGFzIGxvbmcgYXMgdGhlIGlkIGBlYFxuICogaXMgdW5pcXVlIGluIHRoZSBzZXQgb2YgZWRnZXMuIElmIGBlYCBpcyBgbnVsbGAgdGhlIGdyYXBoIHdpbGwgYXNzaWduIGFcbiAqIHVuaXF1ZSBpZGVudGlmaWVyIHRvIHRoZSBlZGdlLlxuICpcbiAqIElmIGBzb3VyY2VgIG9yIGB0YXJnZXRgIGFyZSBub3QgcHJlc2VudCBpbiB0aGUgZ3JhcGggdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiB0aHJvdyBhbiBFcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW2VdIGFuIGVkZ2UgaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgdGhlIHNvdXJjZSBub2RlIGlkXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0IHRoZSB0YXJnZXQgbm9kZSBpZFxuICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZV0gYW4gb3B0aW9uYWwgdmFsdWUgdG8gYXR0YWNoIHRvIHRoZSBlZGdlXG4gKi9cbkRpZ3JhcGgucHJvdG90eXBlLmFkZEVkZ2UgPSBmdW5jdGlvbihlLCBzb3VyY2UsIHRhcmdldCwgdmFsdWUpIHtcbiAgcmV0dXJuIEJhc2VHcmFwaC5wcm90b3R5cGUuX2FkZEVkZ2UuY2FsbCh0aGlzLCBlLCBzb3VyY2UsIHRhcmdldCwgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5FZGdlcywgdGhpcy5fb3V0RWRnZXMpO1xufTtcblxuLypcbiAqIFJlbW92ZXMgYW4gZWRnZSBpbiB0aGUgZ3JhcGggd2l0aCB0aGUgaWQgYGVgLiBJZiBubyBlZGdlIGluIHRoZSBncmFwaCBoYXNcbiAqIHRoZSBpZCBgZWAgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlIGFuIGVkZ2UgaWRcbiAqL1xuRGlncmFwaC5wcm90b3R5cGUuZGVsRWRnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgQmFzZUdyYXBoLnByb3RvdHlwZS5fZGVsRWRnZS5jYWxsKHRoaXMsIGUsIHRoaXMuX2luRWRnZXMsIHRoaXMuX291dEVkZ2VzKTtcbn07XG5cbi8vIFVubGlrZSBCYXNlR3JhcGguZmlsdGVyTm9kZXMsIHRoaXMgaGVscGVyIGp1c3QgcmV0dXJucyBub2RlcyB0aGF0XG4vLyBzYXRpc2Z5IGEgcHJlZGljYXRlLlxuRGlncmFwaC5wcm90b3R5cGUuX2ZpbHRlck5vZGVzID0gZnVuY3Rpb24ocHJlZCkge1xuICB2YXIgZmlsdGVyZWQgPSBbXTtcbiAgdGhpcy5lYWNoTm9kZShmdW5jdGlvbih1KSB7XG4gICAgaWYgKHByZWQodSkpIHtcbiAgICAgIGZpbHRlcmVkLnB1c2godSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZpbHRlcmVkO1xufTtcblxuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBvcmdhbml6ZWQgd2l0aCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICpcbiAqIEV4cG9ydHNcbiAqIEdyYXBoIGNvbnN0cnVjdG9yc1xuICogR3JhcGggcXVlcmllcyAoZS5nLiBub2RlcygpLCBlZGdlcygpXG4gKiBHcmFwaCBtdXRhdG9yc1xuICogSGVscGVyIGZ1bmN0aW9uc1xuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBCYXNlR3JhcGggPSByZXF1aXJlKFwiLi9CYXNlR3JhcGhcIiksXG4vKiBqc2hpbnQgLVcwNzkgKi9cbiAgICBTZXQgPSByZXF1aXJlKFwiY3AtZGF0YVwiKS5TZXQ7XG4vKiBqc2hpbnQgK1cwNzkgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcblxuLypcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIG5ldyB1bmRpcmVjdGVkIG11bHRpLWdyYXBoLlxuICovXG5mdW5jdGlvbiBHcmFwaCgpIHtcbiAgQmFzZUdyYXBoLmNhbGwodGhpcyk7XG5cbiAgLyohIE1hcCBvZiBub2RlSWQgLT4geyBvdGhlck5vZGVJZCAtPiBTZXQgb2YgZWRnZSBpZHMgfSAqL1xuICB0aGlzLl9pbmNpZGVudEVkZ2VzID0ge307XG59XG5cbkdyYXBoLnByb3RvdHlwZSA9IG5ldyBCYXNlR3JhcGgoKTtcbkdyYXBoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyYXBoO1xuXG4vKlxuICogQWx3YXlzIHJldHVybnMgYGZhbHNlYC5cbiAqL1xuR3JhcGgucHJvdG90eXBlLmlzRGlyZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLypcbiAqIFJldHVybnMgYWxsIG5vZGVzIHRoYXQgYXJlIGFkamFjZW50IHRvIHRoZSBub2RlIHdpdGggdGhlIGlkIGB1YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdSBhIG5vZGUgaWRcbiAqL1xuR3JhcGgucHJvdG90eXBlLm5laWdoYm9ycyA9IGZ1bmN0aW9uKHUpIHtcbiAgdGhpcy5fc3RyaWN0R2V0Tm9kZSh1KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2luY2lkZW50RWRnZXNbdV0pXG4gICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHRoaXMuX25vZGVzW3ZdLmlkOyB9LCB0aGlzKTtcbn07XG5cbi8qXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGlkcyBmb3IgYWxsIGVkZ2VzIGluIHRoZSBncmFwaCB0aGF0IGFyZSBpbmNpZGVudCBvbiBgdWAuXG4gKiBJZiB0aGUgbm9kZSBgdWAgaXMgbm90IGluIHRoZSBncmFwaCB0aGlzIGZ1bmN0aW9uIHJhaXNlcyBhbiBFcnJvci5cbiAqXG4gKiBPcHRpb25hbGx5IGEgYHZgIG5vZGUgbWF5IGFsc28gYmUgc3BlY2lmaWVkLiBUaGlzIGNhdXNlcyB0aGUgcmVzdWx0cyB0byBiZVxuICogZmlsdGVyZWQgc3VjaCB0aGF0IG9ubHkgZWRnZXMgYmV0d2VlbiBgdWAgYW5kIGB2YCBhcmUgaW5jbHVkZWQuIElmIHRoZSBub2RlXG4gKiBgdmAgaXMgc3BlY2lmaWVkIGJ1dCBub3QgaW4gdGhlIGdyYXBoIHRoZW4gdGhpcyBmdW5jdGlvbiByYWlzZXMgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHUgdGhlIG5vZGUgZm9yIHdoaWNoIHRvIGZpbmQgaW5jaWRlbnQgZWRnZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdl0gb3B0aW9uIG5vZGUgdGhhdCBtdXN0IGJlIGFkamFjZW50IHRvIGB1YFxuICovXG5HcmFwaC5wcm90b3R5cGUuaW5jaWRlbnRFZGdlcyA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgdGhpcy5fc3RyaWN0R2V0Tm9kZSh1KTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgdGhpcy5fc3RyaWN0R2V0Tm9kZSh2KTtcbiAgICByZXR1cm4gdiBpbiB0aGlzLl9pbmNpZGVudEVkZ2VzW3VdID8gdGhpcy5faW5jaWRlbnRFZGdlc1t1XVt2XS5rZXlzKCkgOiBbXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gU2V0LnVuaW9uKHV0aWwudmFsdWVzKHRoaXMuX2luY2lkZW50RWRnZXNbdV0pKS5rZXlzKCk7XG4gIH1cbn07XG5cbi8qXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZ3JhcGguXG4gKi9cbkdyYXBoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJHcmFwaCBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMsIG51bGwsIDIpO1xufTtcblxuLypcbiAqIEFkZHMgYSBuZXcgbm9kZSB3aXRoIHRoZSBpZCBgdWAgdG8gdGhlIGdyYXBoIGFuZCBhc3NpZ25zIGl0IHRoZSB2YWx1ZVxuICogYHZhbHVlYC4gSWYgYSBub2RlIHdpdGggdGhlIGlkIGlzIGFscmVhZHkgYSBwYXJ0IG9mIHRoZSBncmFwaCB0aGlzIGZ1bmN0aW9uXG4gKiB0aHJvd3MgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHUgYSBub2RlIGlkXG4gKiBAcGFyYW0ge09iamVjdH0gW3ZhbHVlXSBhbiBvcHRpb25hbCB2YWx1ZSB0byBhdHRhY2ggdG8gdGhlIG5vZGVcbiAqL1xuR3JhcGgucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbih1LCB2YWx1ZSkge1xuICB1ID0gQmFzZUdyYXBoLnByb3RvdHlwZS5hZGROb2RlLmNhbGwodGhpcywgdSwgdmFsdWUpO1xuICB0aGlzLl9pbmNpZGVudEVkZ2VzW3VdID0ge307XG4gIHJldHVybiB1O1xufTtcblxuLypcbiAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhlIGdyYXBoIHRoYXQgaGFzIHRoZSBpZCBgdWAuIEFueSBlZGdlcyBpbmNpZGVudCBvbiB0aGVcbiAqIG5vZGUgYXJlIGFsc28gcmVtb3ZlZC4gSWYgdGhlIGdyYXBoIGRvZXMgbm90IGNvbnRhaW4gYSBub2RlIHdpdGggdGhlIGlkIHRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHUgYSBub2RlIGlkXG4gKi9cbkdyYXBoLnByb3RvdHlwZS5kZWxOb2RlID0gZnVuY3Rpb24odSkge1xuICBCYXNlR3JhcGgucHJvdG90eXBlLmRlbE5vZGUuY2FsbCh0aGlzLCB1KTtcbiAgZGVsZXRlIHRoaXMuX2luY2lkZW50RWRnZXNbdV07XG59O1xuXG4vKlxuICogQWRkcyBhIG5ldyBlZGdlIHRvIHRoZSBncmFwaCB3aXRoIHRoZSBpZCBgZWAgYmV0d2VlbiBhIG5vZGUgd2l0aCB0aGUgaWQgYHVgXG4gKiBhbmQgYSBub2RlIHdpdGggYW4gaWQgYHZgIGFuZCBhc3NpZ25zIGl0IHRoZSB2YWx1ZSBgdmFsdWVgLiBUaGlzIGdyYXBoXG4gKiBhbGxvd3MgbW9yZSB0aGFuIG9uZSBlZGdlIGJldHdlZW4gYHVgIGFuZCBgdmAgYXMgbG9uZyBhcyB0aGUgaWQgYGVgXG4gKiBpcyB1bmlxdWUgaW4gdGhlIHNldCBvZiBlZGdlcy4gSWYgYGVgIGlzIGBudWxsYCB0aGUgZ3JhcGggd2lsbCBhc3NpZ24gYVxuICogdW5pcXVlIGlkZW50aWZpZXIgdG8gdGhlIGVkZ2UuXG4gKlxuICogSWYgYHVgIG9yIGB2YCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIGdyYXBoIHRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhblxuICogRXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtlXSBhbiBlZGdlIGlkXG4gKiBAcGFyYW0ge1N0cmluZ30gdSB0aGUgbm9kZSBpZCBvZiBvbmUgb2YgdGhlIGFkamFjZW50IG5vZGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdiB0aGUgbm9kZSBpZCBvZiB0aGUgb3RoZXIgYWRqYWNlbnQgbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZV0gYW4gb3B0aW9uYWwgdmFsdWUgdG8gYXR0YWNoIHRvIHRoZSBlZGdlXG4gKi9cbkdyYXBoLnByb3RvdHlwZS5hZGRFZGdlID0gZnVuY3Rpb24oZSwgdSwgdiwgdmFsdWUpIHtcbiAgcmV0dXJuIEJhc2VHcmFwaC5wcm90b3R5cGUuX2FkZEVkZ2UuY2FsbCh0aGlzLCBlLCB1LCB2LCB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmNpZGVudEVkZ2VzLCB0aGlzLl9pbmNpZGVudEVkZ2VzKTtcbn07XG5cbi8qXG4gKiBSZW1vdmVzIGFuIGVkZ2UgaW4gdGhlIGdyYXBoIHdpdGggdGhlIGlkIGBlYC4gSWYgbm8gZWRnZSBpbiB0aGUgZ3JhcGggaGFzXG4gKiB0aGUgaWQgYGVgIHRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZSBhbiBlZGdlIGlkXG4gKi9cbkdyYXBoLnByb3RvdHlwZS5kZWxFZGdlID0gZnVuY3Rpb24oZSkge1xuICBCYXNlR3JhcGgucHJvdG90eXBlLl9kZWxFZGdlLmNhbGwodGhpcywgZSwgdGhpcy5faW5jaWRlbnRFZGdlcywgdGhpcy5faW5jaWRlbnRFZGdlcyk7XG59O1xuXG4iLCIvKiBqc2hpbnQgLVcwNzkgKi9cbnZhciBTZXQgPSByZXF1aXJlKFwiY3AtZGF0YVwiKS5TZXQ7XG4vKiBqc2hpbnQgK1cwNzkgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wb25lbnRzO1xuXG4vKipcbiAqIEZpbmRzIGFsbCBbY29ubmVjdGVkIGNvbXBvbmVudHNdW10gaW4gYSBncmFwaCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVzZVxuICogY29tcG9uZW50cy4gRWFjaCBjb21wb25lbnQgaXMgaXRzZWxmIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIGlkcyBvZiBub2Rlc1xuICogaW4gdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG9ubHkgd29ya3Mgd2l0aCB1bmRpcmVjdGVkIEdyYXBocy5cbiAqXG4gKiBbY29ubmVjdGVkIGNvbXBvbmVudHNdOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nvbm5lY3RlZF9jb21wb25lbnRfKGdyYXBoX3RoZW9yeSlcbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBnIHRoZSBncmFwaCB0byBzZWFyY2ggZm9yIGNvbXBvbmVudHNcbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50cyhnKSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuXG4gIGZ1bmN0aW9uIGRmcyh2LCBjb21wb25lbnQpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKHYpKSB7XG4gICAgICB2aXNpdGVkLmFkZCh2KTtcbiAgICAgIGNvbXBvbmVudC5wdXNoKHYpO1xuICAgICAgZy5uZWlnaGJvcnModikuZm9yRWFjaChmdW5jdGlvbih3KSB7XG4gICAgICAgIGRmcyh3LCBjb21wb25lbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIHZhciBjb21wb25lbnQgPSBbXTtcbiAgICBkZnModiwgY29tcG9uZW50KTtcbiAgICBpZiAoY29tcG9uZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdHMucHVzaChjb21wb25lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4iLCJ2YXIgUHJpb3JpdHlRdWV1ZSA9IHJlcXVpcmUoXCJjcC1kYXRhXCIpLlByaW9yaXR5UXVldWU7XG5cbm1vZHVsZS5leHBvcnRzID0gZGlqa3N0cmE7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBbRGlqa3N0cmEncyBhbGdvcml0aG1dW10gd2hpY2ggZmluZHNcbiAqIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gKipzb3VyY2UqKiB0byBhbGwgb3RoZXIgbm9kZXMgaW4gKipnKiouIFRoaXNcbiAqIGZ1bmN0aW9uIHJldHVybnMgYSBtYXAgb2YgYHUgLT4geyBkaXN0YW5jZSwgcHJlZGVjZXNzb3IgfWAuIFRoZSBkaXN0YW5jZVxuICogcHJvcGVydHkgaG9sZHMgdGhlIHN1bSBvZiB0aGUgd2VpZ2h0cyBmcm9tICoqc291cmNlKiogdG8gYHVgIGFsb25nIHRoZVxuICogc2hvcnRlc3QgcGF0aCBvciBgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZYCBpZiB0aGVyZSBpcyBubyBwYXRoIGZyb21cbiAqICoqc291cmNlKiouIFRoZSBwcmVkZWNlc3NvciBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byB3YWxrIHRoZSBpbmRpdmlkdWFsXG4gKiBlbGVtZW50cyBvZiB0aGUgcGF0aCBmcm9tICoqc291cmNlKiogdG8gKip1KiogaW4gcmV2ZXJzZSBvcmRlci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIG9wdGlvbmFsIGB3ZWlnaHRGdW5jKGUpYCB3aGljaCByZXR1cm5zIHRoZVxuICogd2VpZ2h0IG9mIHRoZSBlZGdlIGBlYC4gSWYgbm8gd2VpZ2h0RnVuYyBpcyBzdXBwbGllZCB0aGVuIGVhY2ggZWRnZSBpc1xuICogYXNzdW1lZCB0byBoYXZlIGEgd2VpZ2h0IG9mIDEuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIEVycm9yIGlmIGFueSBvZlxuICogdGhlIHRyYXZlcnNlZCBlZGdlcyBoYXZlIGEgbmVnYXRpdmUgZWRnZSB3ZWlnaHQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBvcHRpb25hbCBgaW5jaWRlbnRGdW5jKHUpYCB3aGljaCByZXR1cm5zIHRoZSBpZHMgb2ZcbiAqIGFsbCBlZGdlcyBpbmNpZGVudCB0byB0aGUgbm9kZSBgdWAgZm9yIHRoZSBwdXJwb3NlcyBvZiBzaG9ydGVzdCBwYXRoXG4gKiB0cmF2ZXJzYWwuIEJ5IGRlZmF1bHQgdGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBgZy5vdXRFZGdlc2AgZm9yIERpZ3JhcGhzIGFuZFxuICogYGcuaW5jaWRlbnRFZGdlc2AgZm9yIEdyYXBocy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGBPKCh8RXwgKyB8VnwpICogbG9nIHxWfClgIHRpbWUuXG4gKlxuICogW0RpamtzdHJhJ3MgYWxnb3JpdGhtXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaWprc3RyYSUyN3NfYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gZyB0aGUgZ3JhcGggdG8gc2VhcmNoIGZvciBzaG9ydGVzdCBwYXRocyBmcm9tICoqc291cmNlKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgdGhlIHNvdXJjZSBmcm9tIHdoaWNoIHRvIHN0YXJ0IHRoZSBzZWFyY2hcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt3ZWlnaHRGdW5jXSBvcHRpb25hbCB3ZWlnaHQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbmNpZGVudEZ1bmNdIG9wdGlvbmFsIGluY2lkZW50IGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRpamtzdHJhKGcsIHNvdXJjZSwgd2VpZ2h0RnVuYywgaW5jaWRlbnRGdW5jKSB7XG4gIHZhciByZXN1bHRzID0ge30sXG4gICAgICBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlTmVpZ2hib3JzKGUpIHtcbiAgICB2YXIgaW5jaWRlbnROb2RlcyA9IGcuaW5jaWRlbnROb2RlcyhlKSxcbiAgICAgICAgdiA9IGluY2lkZW50Tm9kZXNbMF0gIT09IHUgPyBpbmNpZGVudE5vZGVzWzBdIDogaW5jaWRlbnROb2Rlc1sxXSxcbiAgICAgICAgdkVudHJ5ID0gcmVzdWx0c1t2XSxcbiAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0RnVuYyhlKSxcbiAgICAgICAgZGlzdGFuY2UgPSB1RW50cnkuZGlzdGFuY2UgKyB3ZWlnaHQ7XG5cbiAgICBpZiAod2VpZ2h0IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlqa3N0cmEgZG9lcyBub3QgYWxsb3cgbmVnYXRpdmUgZWRnZSB3ZWlnaHRzLiBCYWQgZWRnZTogXCIgKyBlICsgXCIgV2VpZ2h0OiBcIiArIHdlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKGRpc3RhbmNlIDwgdkVudHJ5LmRpc3RhbmNlKSB7XG4gICAgICB2RW50cnkuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIHZFbnRyeS5wcmVkZWNlc3NvciA9IHU7XG4gICAgICBwcS5kZWNyZWFzZSh2LCBkaXN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgd2VpZ2h0RnVuYyA9IHdlaWdodEZ1bmMgfHwgZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xuICBpbmNpZGVudEZ1bmMgPSBpbmNpZGVudEZ1bmMgfHwgKGcuaXNEaXJlY3RlZCgpXG4gICAgICA/IGZ1bmN0aW9uKHUpIHsgcmV0dXJuIGcub3V0RWRnZXModSk7IH1cbiAgICAgIDogZnVuY3Rpb24odSkgeyByZXR1cm4gZy5pbmNpZGVudEVkZ2VzKHUpOyB9KTtcblxuICBnLmVhY2hOb2RlKGZ1bmN0aW9uKHUpIHtcbiAgICB2YXIgZGlzdGFuY2UgPSB1ID09PSBzb3VyY2UgPyAwIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHJlc3VsdHNbdV0gPSB7IGRpc3RhbmNlOiBkaXN0YW5jZSB9O1xuICAgIHBxLmFkZCh1LCBkaXN0YW5jZSk7XG4gIH0pO1xuXG4gIHZhciB1LCB1RW50cnk7XG4gIHdoaWxlIChwcS5zaXplKCkgPiAwKSB7XG4gICAgdSA9IHBxLnJlbW92ZU1pbigpO1xuICAgIHVFbnRyeSA9IHJlc3VsdHNbdV07XG4gICAgaWYgKHVFbnRyeS5kaXN0YW5jZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpbmNpZGVudEZ1bmModSkuZm9yRWFjaCh1cGRhdGVOZWlnaGJvcnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4iLCJ2YXIgZGlqa3N0cmEgPSByZXF1aXJlKFwiLi9kaWprc3RyYVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWprc3RyYUFsbDtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gZWFjaCBub2RlIHRvIGV2ZXJ5IG90aGVyXG4gKiByZWFjaGFibGUgbm9kZSBpbiB0aGUgZ3JhcGguIEl0IGlzIHNpbWlsYXIgdG8gW2FsZy5kaWprc3RyYV1bXSwgYnV0XG4gKiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIHNpbmdsZS1zb3VyY2UgYXJyYXksIGl0IHJldHVybnMgYSBtYXBwaW5nIG9mXG4gKiBvZiBgc291cmNlIC0+IGFsZy5kaWprc3RhKGcsIHNvdXJjZSwgd2VpZ2h0RnVuYywgaW5jaWRlbnRGdW5jKWAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBvcHRpb25hbCBgd2VpZ2h0RnVuYyhlKWAgd2hpY2ggcmV0dXJucyB0aGVcbiAqIHdlaWdodCBvZiB0aGUgZWRnZSBgZWAuIElmIG5vIHdlaWdodEZ1bmMgaXMgc3VwcGxpZWQgdGhlbiBlYWNoIGVkZ2UgaXNcbiAqIGFzc3VtZWQgdG8gaGF2ZSBhIHdlaWdodCBvZiAxLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBhbiBFcnJvciBpZiBhbnkgb2ZcbiAqIHRoZSB0cmF2ZXJzZWQgZWRnZXMgaGF2ZSBhIG5lZ2F0aXZlIGVkZ2Ugd2VpZ2h0LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gb3B0aW9uYWwgYGluY2lkZW50RnVuYyh1KWAgd2hpY2ggcmV0dXJucyB0aGUgaWRzIG9mXG4gKiBhbGwgZWRnZXMgaW5jaWRlbnQgdG8gdGhlIG5vZGUgYHVgIGZvciB0aGUgcHVycG9zZXMgb2Ygc2hvcnRlc3QgcGF0aFxuICogdHJhdmVyc2FsLiBCeSBkZWZhdWx0IHRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgYG91dEVkZ2VzYCBmdW5jdGlvbiBvbiB0aGVcbiAqIHN1cHBsaWVkIGdyYXBoLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYE8ofFZ8ICogKHxFfCArIHxWfCkgKiBsb2cgfFZ8KWAgdGltZS5cbiAqXG4gKiBbYWxnLmRpamtzdHJhXTogZGlqa3N0cmEuanMuaHRtbCNkaWprc3RyYVxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IGcgdGhlIGdyYXBoIHRvIHNlYXJjaCBmb3Igc2hvcnRlc3QgcGF0aHMgZnJvbSAqKnNvdXJjZSoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbd2VpZ2h0RnVuY10gb3B0aW9uYWwgd2VpZ2h0IGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5jaWRlbnRGdW5jXSBvcHRpb25hbCBpbmNpZGVudCBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBkaWprc3RyYUFsbChnLCB3ZWlnaHRGdW5jLCBpbmNpZGVudEZ1bmMpIHtcbiAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgZy5lYWNoTm9kZShmdW5jdGlvbih1KSB7XG4gICAgcmVzdWx0c1t1XSA9IGRpamtzdHJhKGcsIHUsIHdlaWdodEZ1bmMsIGluY2lkZW50RnVuYyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsInZhciB0YXJqYW4gPSByZXF1aXJlKFwiLi90YXJqYW5cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEN5Y2xlcztcblxuLypcbiAqIEdpdmVuIGEgRGlncmFwaCAqKmcqKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYWxsIG5vZGVzIHRoYXQgYXJlIHBhcnQgb2YgYVxuICogY3ljbGUuIFNpbmNlIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIGN5Y2xlIGluIGEgZ3JhcGggdGhpcyBmdW5jdGlvblxuICogcmV0dXJucyBhbiBhcnJheSBvZiB0aGVzZSBjeWNsZXMsIHdoZXJlIGVhY2ggY3ljbGUgaXMgaXRzZWxmIHJlcHJlc2VudGVkXG4gKiBieSBhbiBhcnJheSBvZiBpZHMgZm9yIGVhY2ggbm9kZSBpbnZvbHZlZCBpbiB0aGF0IGN5Y2xlLlxuICpcbiAqIFthbGcuaXNBY3ljbGljXVtdIGlzIG1vcmUgZWZmaWNpZW50IGlmIHlvdSBvbmx5IG5lZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXJcbiAqIGEgZ3JhcGggaGFzIGEgY3ljbGUgb3Igbm90LlxuICpcbiAqIFthbGcuaXNBY3ljbGljXTogaXNBY3ljbGljLmpzLmh0bWwjaXNBY3ljbGljXG4gKlxuICogQHBhcmFtIHtEaWdyYXBofSBnIHRoZSBncmFwaCB0byBzZWFyY2ggZm9yIGN5Y2xlcy5cbiAqL1xuZnVuY3Rpb24gZmluZEN5Y2xlcyhnKSB7XG4gIHJldHVybiB0YXJqYW4oZykuZmlsdGVyKGZ1bmN0aW9uKGNtcHQpIHsgcmV0dXJuIGNtcHQubGVuZ3RoID4gMTsgfSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZsb3lkV2Fyc2hhbGw7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgW0Zsb3lkLVdhcnNoYWxsIGFsZ29yaXRobV1bXSxcbiAqIHdoaWNoIGZpbmRzIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gZWFjaCBub2RlIHRvIGV2ZXJ5IG90aGVyIHJlYWNoYWJsZSBub2RlXG4gKiBpbiB0aGUgZ3JhcGguIEl0IGlzIHNpbWlsYXIgdG8gW2FsZy5kaWprc3RyYUFsbF1bXSwgYnV0IGl0IGhhbmRsZXMgbmVnYXRpdmVcbiAqIGVkZ2Ugd2VpZ2h0cyBhbmQgaXMgbW9yZSBlZmZpY2llbnQgZm9yIHNvbWUgdHlwZXMgb2YgZ3JhcGhzLiBUaGlzIGZ1bmN0aW9uXG4gKiByZXR1cm5zIGEgbWFwIG9mIGBzb3VyY2UgLT4geyB0YXJnZXQgLT4geyBkaXN0YW5jZSwgcHJlZGVjZXNzb3IgfWAuIFRoZVxuICogZGlzdGFuY2UgcHJvcGVydHkgaG9sZHMgdGhlIHN1bSBvZiB0aGUgd2VpZ2h0cyBmcm9tIGBzb3VyY2VgIHRvIGB0YXJnZXRgXG4gKiBhbG9uZyB0aGUgc2hvcnRlc3QgcGF0aCBvZiBgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZYCBpZiB0aGVyZSBpcyBubyBwYXRoXG4gKiBmcm9tIGBzb3VyY2VgLiBUaGUgcHJlZGVjZXNzb3IgcHJvcGVydHkgY2FuIGJlIHVzZWQgdG8gd2FsayB0aGUgaW5kaXZpZHVhbFxuICogZWxlbWVudHMgb2YgdGhlIHBhdGggZnJvbSBgc291cmNlYCB0byBgdGFyZ2V0YCBpbiByZXZlcnNlIG9yZGVyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gb3B0aW9uYWwgYHdlaWdodEZ1bmMoZSlgIHdoaWNoIHJldHVybnMgdGhlXG4gKiB3ZWlnaHQgb2YgdGhlIGVkZ2UgYGVgLiBJZiBubyB3ZWlnaHRGdW5jIGlzIHN1cHBsaWVkIHRoZW4gZWFjaCBlZGdlIGlzXG4gKiBhc3N1bWVkIHRvIGhhdmUgYSB3ZWlnaHQgb2YgMS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIG9wdGlvbmFsIGBpbmNpZGVudEZ1bmModSlgIHdoaWNoIHJldHVybnMgdGhlIGlkcyBvZlxuICogYWxsIGVkZ2VzIGluY2lkZW50IHRvIHRoZSBub2RlIGB1YCBmb3IgdGhlIHB1cnBvc2VzIG9mIHNob3J0ZXN0IHBhdGhcbiAqIHRyYXZlcnNhbC4gQnkgZGVmYXVsdCB0aGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGBvdXRFZGdlc2AgZnVuY3Rpb24gb24gdGhlXG4gKiBzdXBwbGllZCBncmFwaC5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSB0YWtlcyBPKHxWfF4zKSB0aW1lLlxuICpcbiAqIFtGbG95ZC1XYXJzaGFsbCBhbGdvcml0aG1dOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZC1XYXJzaGFsbF9hbGdvcml0aG1cbiAqIFthbGcuZGlqa3N0cmFBbGxdOiBkaWprc3RyYUFsbC5qcy5odG1sI2RpamtzdHJhQWxsXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gZyB0aGUgZ3JhcGggdG8gc2VhcmNoIGZvciBzaG9ydGVzdCBwYXRocyBmcm9tICoqc291cmNlKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt3ZWlnaHRGdW5jXSBvcHRpb25hbCB3ZWlnaHQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbmNpZGVudEZ1bmNdIG9wdGlvbmFsIGluY2lkZW50IGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZsb3lkV2Fyc2hhbGwoZywgd2VpZ2h0RnVuYywgaW5jaWRlbnRGdW5jKSB7XG4gIHZhciByZXN1bHRzID0ge30sXG4gICAgICBub2RlcyA9IGcubm9kZXMoKTtcblxuICB3ZWlnaHRGdW5jID0gd2VpZ2h0RnVuYyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG4gIGluY2lkZW50RnVuYyA9IGluY2lkZW50RnVuYyB8fCAoZy5pc0RpcmVjdGVkKClcbiAgICAgID8gZnVuY3Rpb24odSkgeyByZXR1cm4gZy5vdXRFZGdlcyh1KTsgfVxuICAgICAgOiBmdW5jdGlvbih1KSB7IHJldHVybiBnLmluY2lkZW50RWRnZXModSk7IH0pO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgIHJlc3VsdHNbdV0gPSB7fTtcbiAgICByZXN1bHRzW3VdW3VdID0geyBkaXN0YW5jZTogMCB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgaWYgKHUgIT09IHYpIHtcbiAgICAgICAgcmVzdWx0c1t1XVt2XSA9IHsgZGlzdGFuY2U6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGluY2lkZW50RnVuYyh1KS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBpbmNpZGVudE5vZGVzID0gZy5pbmNpZGVudE5vZGVzKGUpLFxuICAgICAgICAgIHYgPSBpbmNpZGVudE5vZGVzWzBdICE9PSB1ID8gaW5jaWRlbnROb2Rlc1swXSA6IGluY2lkZW50Tm9kZXNbMV0sXG4gICAgICAgICAgZCA9IHdlaWdodEZ1bmMoZSk7XG4gICAgICBpZiAoZCA8IHJlc3VsdHNbdV1bdl0uZGlzdGFuY2UpIHtcbiAgICAgICAgcmVzdWx0c1t1XVt2XSA9IHsgZGlzdGFuY2U6IGQsIHByZWRlY2Vzc29yOiB1IH07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciByb3dLID0gcmVzdWx0c1trXTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciByb3dJID0gcmVzdWx0c1tpXTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICB2YXIgaWsgPSByb3dJW2tdO1xuICAgICAgICB2YXIga2ogPSByb3dLW2pdO1xuICAgICAgICB2YXIgaWogPSByb3dJW2pdO1xuICAgICAgICB2YXIgYWx0RGlzdGFuY2UgPSBpay5kaXN0YW5jZSArIGtqLmRpc3RhbmNlO1xuICAgICAgICBpZiAoYWx0RGlzdGFuY2UgPCBpai5kaXN0YW5jZSkge1xuICAgICAgICAgIGlqLmRpc3RhbmNlID0gYWx0RGlzdGFuY2U7XG4gICAgICAgICAgaWoucHJlZGVjZXNzb3IgPSBrai5wcmVkZWNlc3NvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuIiwidmFyIHRvcHNvcnQgPSByZXF1aXJlKFwiLi90b3Bzb3J0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQWN5Y2xpYztcblxuLypcbiAqIEdpdmVuIGEgRGlncmFwaCAqKmcqKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGlmIHRoZSBncmFwaCBoYXMgbm9cbiAqIGN5Y2xlcyBhbmQgcmV0dXJucyBgZmFsc2VgIGlmIGl0IGRvZXMuIFRoaXMgYWxnb3JpdGhtIHJldHVybnMgYXMgc29vbiBhcyBpdFxuICogZGV0ZWN0cyB0aGUgZmlyc3QgY3ljbGUuXG4gKlxuICogVXNlIFthbGcuZmluZEN5Y2xlc11bXSBpZiB5b3UgbmVlZCB0aGUgYWN0dWFsIGxpc3Qgb2YgY3ljbGVzIGluIGEgZ3JhcGguXG4gKlxuICogW2FsZy5maW5kQ3ljbGVzXTogZmluZEN5Y2xlcy5qcy5odG1sI2ZpbmRDeWNsZXNcbiAqXG4gKiBAcGFyYW0ge0RpZ3JhcGh9IGcgdGhlIGdyYXBoIHRvIHRlc3QgZm9yIGN5Y2xlc1xuICovXG5mdW5jdGlvbiBpc0FjeWNsaWMoZykge1xuICB0cnkge1xuICAgIHRvcHNvcnQoZyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIHRvcHNvcnQuQ3ljbGVFeGNlcHRpb24pIHJldHVybiBmYWxzZTtcbiAgICB0aHJvdyBlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIiwiLyoganNoaW50IC1XMDc5ICovXG52YXIgU2V0ID0gcmVxdWlyZShcImNwLWRhdGFcIikuU2V0O1xuLyoganNoaW50ICtXMDc5ICovXG5cbm1vZHVsZS5leHBvcnRzID0gcG9zdG9yZGVyO1xuXG4vLyBQb3N0b3JkZXIgdHJhdmVyc2FsIG9mIGcsIGNhbGxpbmcgZiBmb3IgZWFjaCB2aXNpdGVkIG5vZGUuIEFzc3VtZXMgdGhlIGdyYXBoXG4vLyBpcyBhIHRyZWUuXG5mdW5jdGlvbiBwb3N0b3JkZXIoZywgcm9vdCwgZikge1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgaWYgKGcuaXNEaXJlY3RlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBmdW5jdGlvbiBvbmx5IHdvcmtzIGZvciB1bmRpcmVjdGVkIGdyYXBoc1wiKTtcbiAgfVxuICBmdW5jdGlvbiBkZnModSwgcHJldikge1xuICAgIGlmICh2aXNpdGVkLmhhcyh1KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGlucHV0IGdyYXBoIGlzIG5vdCBhIHRyZWU6IFwiICsgZyk7XG4gICAgfVxuICAgIHZpc2l0ZWQuYWRkKHUpO1xuICAgIGcubmVpZ2hib3JzKHUpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgaWYgKHYgIT09IHByZXYpIGRmcyh2LCB1KTtcbiAgICB9KTtcbiAgICBmKHUpO1xuICB9XG4gIGRmcyhyb290KTtcbn1cbiIsIi8qIGpzaGludCAtVzA3OSAqL1xudmFyIFNldCA9IHJlcXVpcmUoXCJjcC1kYXRhXCIpLlNldDtcbi8qIGpzaGludCArVzA3OSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZW9yZGVyO1xuXG4vLyBQcmVvcmRlciB0cmF2ZXJzYWwgb2YgZywgY2FsbGluZyBmIGZvciBlYWNoIHZpc2l0ZWQgbm9kZS4gQXNzdW1lcyB0aGUgZ3JhcGhcbi8vIGlzIGEgdHJlZS5cbmZ1bmN0aW9uIHByZW9yZGVyKGcsIHJvb3QsIGYpIHtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIGlmIChnLmlzRGlyZWN0ZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZnVuY3Rpb24gb25seSB3b3JrcyBmb3IgdW5kaXJlY3RlZCBncmFwaHNcIik7XG4gIH1cbiAgZnVuY3Rpb24gZGZzKHUsIHByZXYpIHtcbiAgICBpZiAodmlzaXRlZC5oYXModSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBpbnB1dCBncmFwaCBpcyBub3QgYSB0cmVlOiBcIiArIGcpO1xuICAgIH1cbiAgICB2aXNpdGVkLmFkZCh1KTtcbiAgICBmKHUpO1xuICAgIGcubmVpZ2hib3JzKHUpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgaWYgKHYgIT09IHByZXYpIGRmcyh2LCB1KTtcbiAgICB9KTtcbiAgfVxuICBkZnMocm9vdCk7XG59XG4iLCJ2YXIgR3JhcGggPSByZXF1aXJlKFwiLi4vR3JhcGhcIiksXG4gICAgUHJpb3JpdHlRdWV1ZSA9IHJlcXVpcmUoXCJjcC1kYXRhXCIpLlByaW9yaXR5UXVldWU7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJpbTtcblxuLyoqXG4gKiBbUHJpbSdzIGFsZ29yaXRobV1bXSB0YWtlcyBhIGNvbm5lY3RlZCB1bmRpcmVjdGVkIGdyYXBoIGFuZCBnZW5lcmF0ZXMgYVxuICogW21pbmltdW0gc3Bhbm5pbmcgdHJlZV1bXS4gVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBtaW5pbXVtIHNwYW5uaW5nXG4gKiB0cmVlIGFzIGFuIHVuZGlyZWN0ZWQgZ3JhcGguIFRoaXMgYWxnb3JpdGhtIGlzIGRlcml2ZWQgZnJvbSB0aGUgZGVzY3JpcHRpb25cbiAqIGluIFwiSW50cm9kdWN0aW9uIHRvIEFsZ29yaXRobXNcIiwgVGhpcmQgRWRpdGlvbiwgQ29ybWVuLCBldCBhbC4sIFBnIDYzNC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgYHdlaWdodEZ1bmMoZSlgIHdoaWNoIHJldHVybnMgdGhlIHdlaWdodCBvZiB0aGUgZWRnZVxuICogYGVgLiBJdCB0aHJvd3MgYW4gRXJyb3IgaWYgdGhlIGdyYXBoIGlzIG5vdCBjb25uZWN0ZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBgTyh8RXwgbG9nIHxWfClgIHRpbWUuXG4gKlxuICogW1ByaW0ncyBhbGdvcml0aG1dOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QcmltJ3NfYWxnb3JpdGhtXG4gKiBbbWluaW11bSBzcGFubmluZyB0cmVlXTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWluaW11bV9zcGFubmluZ190cmVlXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gZyB0aGUgZ3JhcGggdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWluaW11bSBzcGFubmluZyB0cmVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB3ZWlnaHRGdW5jIHRoZSB3ZWlnaHQgZnVuY3Rpb24gdG8gdXNlXG4gKi9cbmZ1bmN0aW9uIHByaW0oZywgd2VpZ2h0RnVuYykge1xuICB2YXIgcmVzdWx0ID0gbmV3IEdyYXBoKCksXG4gICAgICBwYXJlbnRzID0ge30sXG4gICAgICBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlKCksXG4gICAgICB1O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZU5laWdoYm9ycyhlKSB7XG4gICAgdmFyIGluY2lkZW50Tm9kZXMgPSBnLmluY2lkZW50Tm9kZXMoZSksXG4gICAgICAgIHYgPSBpbmNpZGVudE5vZGVzWzBdICE9PSB1ID8gaW5jaWRlbnROb2Rlc1swXSA6IGluY2lkZW50Tm9kZXNbMV0sXG4gICAgICAgIHByaSA9IHBxLnByaW9yaXR5KHYpO1xuICAgIGlmIChwcmkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGVkZ2VXZWlnaHQgPSB3ZWlnaHRGdW5jKGUpO1xuICAgICAgaWYgKGVkZ2VXZWlnaHQgPCBwcmkpIHtcbiAgICAgICAgcGFyZW50c1t2XSA9IHU7XG4gICAgICAgIHBxLmRlY3JlYXNlKHYsIGVkZ2VXZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChnLm9yZGVyKCkgPT09IDApIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZy5lYWNoTm9kZShmdW5jdGlvbih1KSB7XG4gICAgcHEuYWRkKHUsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgcmVzdWx0LmFkZE5vZGUodSk7XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IGZyb20gYW4gYXJiaXRyYXJ5IG5vZGVcbiAgcHEuZGVjcmVhc2UoZy5ub2RlcygpWzBdLCAwKTtcblxuICB2YXIgaW5pdCA9IGZhbHNlO1xuICB3aGlsZSAocHEuc2l6ZSgpID4gMCkge1xuICAgIHUgPSBwcS5yZW1vdmVNaW4oKTtcbiAgICBpZiAodSBpbiBwYXJlbnRzKSB7XG4gICAgICByZXN1bHQuYWRkRWRnZShudWxsLCB1LCBwYXJlbnRzW3VdKTtcbiAgICB9IGVsc2UgaWYgKGluaXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGdyYXBoIGlzIG5vdCBjb25uZWN0ZWQ6IFwiICsgZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIGcuaW5jaWRlbnRFZGdlcyh1KS5mb3JFYWNoKHVwZGF0ZU5laWdoYm9ycyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB0YXJqYW47XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBbVGFyamFuJ3MgYWxnb3JpdGhtXVtdIHdoaWNoIGZpbmRzXG4gKiBhbGwgW3N0cm9uZ2x5IGNvbm5lY3RlZCBjb21wb25lbnRzXVtdIGluIHRoZSBkaXJlY3RlZCBncmFwaCAqKmcqKi4gRWFjaFxuICogc3Ryb25nbHkgY29ubmVjdGVkIGNvbXBvbmVudCBpcyBjb21wb3NlZCBvZiBub2RlcyB0aGF0IGNhbiByZWFjaCBhbGwgb3RoZXJcbiAqIG5vZGVzIGluIHRoZSBjb21wb25lbnQgdmlhIGRpcmVjdGVkIGVkZ2VzLiBBIHN0cm9uZ2x5IGNvbm5lY3RlZCBjb21wb25lbnRcbiAqIGNhbiBjb25zaXN0IG9mIGEgc2luZ2xlIG5vZGUgaWYgdGhhdCBub2RlIGNhbm5vdCBib3RoIHJlYWNoIGFuZCBiZSByZWFjaGVkXG4gKiBieSBhbnkgb3RoZXIgc3BlY2lmaWMgbm9kZSBpbiB0aGUgZ3JhcGguIENvbXBvbmVudHMgb2YgbW9yZSB0aGFuIG9uZSBub2RlXG4gKiBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIGF0IGxlYXN0IG9uZSBjeWNsZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYXJyYXkgb2YgY29tcG9uZW50cy4gRWFjaCBjb21wb25lbnQgaXMgaXRzZWxmIGFuXG4gKiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBpZHMgb2YgYWxsIG5vZGVzIGluIHRoZSBjb21wb25lbnQuXG4gKlxuICogW1RhcmphbidzIGFsZ29yaXRobV06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGFyamFuJ3Nfc3Ryb25nbHlfY29ubmVjdGVkX2NvbXBvbmVudHNfYWxnb3JpdGhtXG4gKiBbc3Ryb25nbHkgY29ubmVjdGVkIGNvbXBvbmVudHNdOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0cm9uZ2x5X2Nvbm5lY3RlZF9jb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge0RpZ3JhcGh9IGcgdGhlIGdyYXBoIHRvIHNlYXJjaCBmb3Igc3Ryb25nbHkgY29ubmVjdGVkIGNvbXBvbmVudHNcbiAqL1xuZnVuY3Rpb24gdGFyamFuKGcpIHtcbiAgaWYgKCFnLmlzRGlyZWN0ZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInRhcmphbiBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGEgZGlyZWN0ZWQgZ3JhcGguIEJhZCBpbnB1dDogXCIgKyBnKTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBzdGFjayA9IFtdLFxuICAgICAgdmlzaXRlZCA9IHt9LCAvLyBub2RlIGlkIC0+IHsgb25TdGFjaywgbG93bGluaywgaW5kZXggfVxuICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGRmcyh1KSB7XG4gICAgdmFyIGVudHJ5ID0gdmlzaXRlZFt1XSA9IHtcbiAgICAgIG9uU3RhY2s6IHRydWUsXG4gICAgICBsb3dsaW5rOiBpbmRleCxcbiAgICAgIGluZGV4OiBpbmRleCsrXG4gICAgfTtcbiAgICBzdGFjay5wdXNoKHUpO1xuXG4gICAgZy5zdWNjZXNzb3JzKHUpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgaWYgKCEodiBpbiB2aXNpdGVkKSkge1xuICAgICAgICBkZnModik7XG4gICAgICAgIGVudHJ5Lmxvd2xpbmsgPSBNYXRoLm1pbihlbnRyeS5sb3dsaW5rLCB2aXNpdGVkW3ZdLmxvd2xpbmspO1xuICAgICAgfSBlbHNlIGlmICh2aXNpdGVkW3ZdLm9uU3RhY2spIHtcbiAgICAgICAgZW50cnkubG93bGluayA9IE1hdGgubWluKGVudHJ5Lmxvd2xpbmssIHZpc2l0ZWRbdl0uaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGVudHJ5Lmxvd2xpbmsgPT09IGVudHJ5LmluZGV4KSB7XG4gICAgICB2YXIgY21wdCA9IFtdLFxuICAgICAgICAgIHY7XG4gICAgICBkbyB7XG4gICAgICAgIHYgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmlzaXRlZFt2XS5vblN0YWNrID0gZmFsc2U7XG4gICAgICAgIGNtcHQucHVzaCh2KTtcbiAgICAgIH0gd2hpbGUgKHUgIT09IHYpO1xuICAgICAgcmVzdWx0cy5wdXNoKGNtcHQpO1xuICAgIH1cbiAgfVxuXG4gIGcubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICBpZiAoISh1IGluIHZpc2l0ZWQpKSB7XG4gICAgICBkZnModSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gdG9wc29ydDtcbnRvcHNvcnQuQ3ljbGVFeGNlcHRpb24gPSBDeWNsZUV4Y2VwdGlvbjtcblxuLypcbiAqIEdpdmVuIGEgZ3JhcGggKipnKiosIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBvcmRlcmVkIGxpc3Qgb2Ygbm9kZXMgc3VjaFxuICogdGhhdCBmb3IgZWFjaCBlZGdlIGB1IC0+IHZgLCBgdWAgYXBwZWFycyBiZWZvcmUgYHZgIGluIHRoZSBsaXN0LiBJZiB0aGVcbiAqIGdyYXBoIGhhcyBhIGN5Y2xlIGl0IGlzIGltcG9zc2libGUgdG8gZ2VuZXJhdGUgc3VjaCBhIGxpc3QgYW5kXG4gKiAqKkN5Y2xlRXhjZXB0aW9uKiogaXMgdGhyb3duLlxuICpcbiAqIFNlZSBbdG9wb2xvZ2ljYWwgc29ydGluZ10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9wb2xvZ2ljYWxfc29ydGluZylcbiAqIGZvciBtb3JlIGRldGFpbHMgYWJvdXQgaG93IHRoaXMgYWxnb3JpdGhtIHdvcmtzLlxuICpcbiAqIEBwYXJhbSB7RGlncmFwaH0gZyB0aGUgZ3JhcGggdG8gc29ydFxuICovXG5mdW5jdGlvbiB0b3Bzb3J0KGcpIHtcbiAgaWYgKCFnLmlzRGlyZWN0ZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInRvcHNvcnQgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBhIGRpcmVjdGVkIGdyYXBoLiBCYWQgaW5wdXQ6IFwiICsgZyk7XG4gIH1cblxuICB2YXIgdmlzaXRlZCA9IHt9O1xuICB2YXIgc3RhY2sgPSB7fTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBmdW5jdGlvbiB2aXNpdChub2RlKSB7XG4gICAgaWYgKG5vZGUgaW4gc3RhY2spIHtcbiAgICAgIHRocm93IG5ldyBDeWNsZUV4Y2VwdGlvbigpO1xuICAgIH1cblxuICAgIGlmICghKG5vZGUgaW4gdmlzaXRlZCkpIHtcbiAgICAgIHN0YWNrW25vZGVdID0gdHJ1ZTtcbiAgICAgIHZpc2l0ZWRbbm9kZV0gPSB0cnVlO1xuICAgICAgZy5wcmVkZWNlc3NvcnMobm9kZSkuZm9yRWFjaChmdW5jdGlvbihwcmVkKSB7XG4gICAgICAgIHZpc2l0KHByZWQpO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgc3RhY2tbbm9kZV07XG4gICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNpbmtzID0gZy5zaW5rcygpO1xuICBpZiAoZy5vcmRlcigpICE9PSAwICYmIHNpbmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBDeWNsZUV4Y2VwdGlvbigpO1xuICB9XG5cbiAgZy5zaW5rcygpLmZvckVhY2goZnVuY3Rpb24oc2luaykge1xuICAgIHZpc2l0KHNpbmspO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gQ3ljbGVFeGNlcHRpb24oKSB7fVxuXG5DeWNsZUV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiR3JhcGggaGFzIGF0IGxlYXN0IG9uZSBjeWNsZVwiO1xufTtcbiIsIi8vIFRoaXMgZmlsZSBwcm92aWRlcyBhIGhlbHBlciBmdW5jdGlvbiB0aGF0IG1peGVzLWluIERvdCBiZWhhdmlvciB0byBhblxuLy8gZXhpc3RpbmcgZ3JhcGggcHJvdG90eXBlLlxuXG4vKiBqc2hpbnQgLVcwNzkgKi9cbnZhciBTZXQgPSByZXF1aXJlKFwiY3AtZGF0YVwiKS5TZXQ7XG4vKiBqc2hpbnQgK1cwNzkgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wb3VuZGlmeTtcblxuLy8gRXh0ZW5kcyB0aGUgZ2l2ZW4gU3VwZXJDb25zdHJ1Y3RvciB3aXRoIHRoZSBhYmlsaXR5IGZvciBub2RlcyB0byBjb250YWluXG4vLyBvdGhlciBub2Rlcy4gQSBzcGVjaWFsIG5vZGUgaWQgYG51bGxgIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhlIHJvb3QgZ3JhcGguXG5mdW5jdGlvbiBjb21wb3VuZGlmeShTdXBlckNvbnN0cnVjdG9yKSB7XG4gIGZ1bmN0aW9uIENvbnN0cnVjdG9yKCkge1xuICAgIFN1cGVyQ29uc3RydWN0b3IuY2FsbCh0aGlzKTtcblxuICAgIC8vIE1hcCBvZiBvYmplY3QgaWQgLT4gcGFyZW50IGlkIChvciBudWxsIGZvciByb290IGdyYXBoKVxuICAgIHRoaXMuX3BhcmVudHMgPSB7fTtcblxuICAgIC8vIE1hcCBvZiBpZCAob3IgbnVsbCkgLT4gY2hpbGRyZW4gc2V0XG4gICAgdGhpcy5fY2hpbGRyZW4gPSB7fTtcbiAgICB0aGlzLl9jaGlsZHJlbltudWxsXSA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBTdXBlckNvbnN0cnVjdG9yKCk7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbih1LCBwYXJlbnQpIHtcbiAgICB0aGlzLl9zdHJpY3RHZXROb2RlKHUpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50c1t1XTtcbiAgICB9XG5cbiAgICBpZiAodSA9PT0gcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWFrZSBcIiArIHUgKyBcIiBhIHBhcmVudCBvZiBpdHNlbGZcIik7XG4gICAgfVxuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3N0cmljdEdldE5vZGUocGFyZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGlsZHJlblt0aGlzLl9wYXJlbnRzW3VdXS5yZW1vdmUodSk7XG4gICAgdGhpcy5fcGFyZW50c1t1XSA9IHBhcmVudDtcbiAgICB0aGlzLl9jaGlsZHJlbltwYXJlbnRdLmFkZCh1KTtcbiAgfTtcblxuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbih1KSB7XG4gICAgaWYgKHUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3N0cmljdEdldE5vZGUodSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlblt1XS5rZXlzKCk7XG4gIH07XG5cbiAgQ29uc3RydWN0b3IucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbih1LCB2YWx1ZSkge1xuICAgIHUgPSBTdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZS5hZGROb2RlLmNhbGwodGhpcywgdSwgdmFsdWUpO1xuICAgIHRoaXMuX3BhcmVudHNbdV0gPSBudWxsO1xuICAgIHRoaXMuX2NoaWxkcmVuW3VdID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2NoaWxkcmVuW251bGxdLmFkZCh1KTtcbiAgICByZXR1cm4gdTtcbiAgfTtcblxuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGVsTm9kZSA9IGZ1bmN0aW9uKHUpIHtcbiAgICAvLyBQcm9tb3RlIGFsbCBjaGlsZHJlbiB0byB0aGUgcGFyZW50IG9mIHRoZSBzdWJncmFwaFxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCh1KTtcbiAgICB0aGlzLl9jaGlsZHJlblt1XS5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgdGhpcy5wYXJlbnQoY2hpbGQsIHBhcmVudCk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9jaGlsZHJlbltwYXJlbnRdLnJlbW92ZSh1KTtcbiAgICBkZWxldGUgdGhpcy5fcGFyZW50c1t1XTtcbiAgICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdV07XG5cbiAgICByZXR1cm4gU3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGVsTm9kZS5jYWxsKHRoaXMsIHUpO1xuICB9O1xuXG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSBTdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcyk7XG4gICAgdGhpcy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgY29weS5wYXJlbnQodSwgdGhpcy5wYXJlbnQodSkpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZS5maWx0ZXJOb2RlcyA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY29weSA9IFN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLmZpbHRlck5vZGVzLmNhbGwodGhpcywgZmlsdGVyKTtcblxuICAgIHZhciBwYXJlbnRzID0ge307XG4gICAgZnVuY3Rpb24gZmluZFBhcmVudCh1KSB7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5wYXJlbnQodSk7XG4gICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IGNvcHkuaGFzTm9kZShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudHNbdV0gPSBwYXJlbnQ7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudCBpbiBwYXJlbnRzKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRzW3BhcmVudF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmluZFBhcmVudChwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvcHkuZWFjaE5vZGUoZnVuY3Rpb24odSkgeyBjb3B5LnBhcmVudCh1LCBmaW5kUGFyZW50KHUpKTsgfSk7XG5cbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4iLCJ2YXIgR3JhcGggPSByZXF1aXJlKFwiLi4vR3JhcGhcIiksXG4gICAgRGlncmFwaCA9IHJlcXVpcmUoXCIuLi9EaWdyYXBoXCIpLFxuICAgIENHcmFwaCA9IHJlcXVpcmUoXCIuLi9DR3JhcGhcIiksXG4gICAgQ0RpZ3JhcGggPSByZXF1aXJlKFwiLi4vQ0RpZ3JhcGhcIik7XG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24obm9kZXMsIGVkZ2VzLCBDdG9yKSB7XG4gIEN0b3IgPSBDdG9yIHx8IERpZ3JhcGg7XG5cbiAgaWYgKHR5cGVPZihub2RlcykgIT09IFwiQXJyYXlcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm5vZGVzIGlzIG5vdCBhbiBBcnJheVwiKTtcbiAgfVxuXG4gIGlmICh0eXBlT2YoZWRnZXMpICE9PSBcIkFycmF5XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJlZGdlcyBpcyBub3QgYW4gQXJyYXlcIik7XG4gIH1cblxuICBpZiAodHlwZW9mIEN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICBzd2l0Y2goQ3Rvcikge1xuICAgICAgY2FzZSBcImdyYXBoXCI6IEN0b3IgPSBHcmFwaDsgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlncmFwaFwiOiBDdG9yID0gRGlncmFwaDsgYnJlYWs7XG4gICAgICBjYXNlIFwiY2dyYXBoXCI6IEN0b3IgPSBDR3JhcGg7IGJyZWFrO1xuICAgICAgY2FzZSBcImNkaWdyYXBoXCI6IEN0b3IgPSBDRGlncmFwaDsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZ3JhcGggdHlwZTogXCIgKyBDdG9yKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZ3JhcGggPSBuZXcgQ3RvcigpO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgIGdyYXBoLmFkZE5vZGUodS5pZCwgdS52YWx1ZSk7XG4gIH0pO1xuXG4gIC8vIElmIHRoZSBncmFwaCBpcyBjb21wb3VuZCwgc2V0IHVwIGNoaWxkcmVuLi4uXG4gIGlmIChncmFwaC5wYXJlbnQpIHtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICAgIGlmICh1LmNoaWxkcmVuKSB7XG4gICAgICAgIHUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgZ3JhcGgucGFyZW50KHYsIHUuaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIGdyYXBoLmFkZEVkZ2UoZS5pZCwgZS51LCBlLnYsIGUudmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gZ3JhcGg7XG59O1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgZWRnZXMgPSBbXTtcblxuICBncmFwaC5lYWNoTm9kZShmdW5jdGlvbih1LCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0ge2lkOiB1LCB2YWx1ZTogdmFsdWV9O1xuICAgIGlmIChncmFwaC5jaGlsZHJlbikge1xuICAgICAgdmFyIGNoaWxkcmVuID0gZ3JhcGguY2hpbGRyZW4odSk7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfSk7XG5cbiAgZ3JhcGguZWFjaEVkZ2UoZnVuY3Rpb24oZSwgdSwgdiwgdmFsdWUpIHtcbiAgICBlZGdlcy5wdXNoKHtpZDogZSwgdTogdSwgdjogdiwgdmFsdWU6IHZhbHVlfSk7XG4gIH0pO1xuXG4gIHZhciB0eXBlO1xuICBpZiAoZ3JhcGggaW5zdGFuY2VvZiBDRGlncmFwaCkge1xuICAgIHR5cGUgPSBcImNkaWdyYXBoXCI7XG4gIH0gZWxzZSBpZiAoZ3JhcGggaW5zdGFuY2VvZiBDR3JhcGgpIHtcbiAgICB0eXBlID0gXCJjZ3JhcGhcIjtcbiAgfSBlbHNlIGlmIChncmFwaCBpbnN0YW5jZW9mIERpZ3JhcGgpIHtcbiAgICB0eXBlID0gXCJkaWdyYXBoXCI7XG4gIH0gZWxzZSBpZiAoZ3JhcGggaW5zdGFuY2VvZiBHcmFwaCkge1xuICAgIHR5cGUgPSBcImdyYXBoXCI7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZGV0ZXJtaW5lIHR5cGUgb2YgZ3JhcGg6IFwiICsgZ3JhcGgpO1xuICB9XG5cbiAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIHR5cGU6IHR5cGUgfTtcbn07XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopLnNsaWNlKDgsIC0xKTtcbn1cbiIsIi8qIGpzaGludCAtVzA3OSAqL1xudmFyIFNldCA9IHJlcXVpcmUoXCJjcC1kYXRhXCIpLlNldDtcbi8qIGpzaGludCArVzA3OSAqL1xuXG5leHBvcnRzLmFsbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xufTtcblxuZXhwb3J0cy5ub2Rlc0Zyb21MaXN0ID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgdmFyIHNldCA9IG5ldyBTZXQobm9kZXMpO1xuICByZXR1cm4gZnVuY3Rpb24odSkge1xuICAgIHJldHVybiBzZXQuaGFzKHUpO1xuICB9O1xufTtcbiIsInZhciBHcmFwaCA9IHJlcXVpcmUoXCIuL0dyYXBoXCIpLFxuICAgIERpZ3JhcGggPSByZXF1aXJlKFwiLi9EaWdyYXBoXCIpO1xuXG4vLyBTaWRlLWVmZmVjdCBiYXNlZCBjaGFuZ2VzIGFyZSBsb3VzeSwgYnV0IG5vZGUgZG9lc24ndCBzZWVtIHRvIHJlc29sdmUgdGhlXG4vLyByZXF1aXJlcyBjeWNsZS5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGRpcmVjdGVkIGdyYXBoIHVzaW5nIHRoZSBub2RlcyBhbmQgZWRnZXMgZnJvbSB0aGlzIGdyYXBoLiBUaGVcbiAqIG5ldyBncmFwaCB3aWxsIGhhdmUgdGhlIHNhbWUgbm9kZXMsIGJ1dCB3aWxsIGhhdmUgdHdpY2UgdGhlIG51bWJlciBvZiBlZGdlczpcbiAqIGVhY2ggZWRnZSBpcyBzcGxpdCBpbnRvIHR3byBlZGdlcyB3aXRoIG9wcG9zaXRlIGRpcmVjdGlvbnMuIEVkZ2UgaWRzLFxuICogY29uc2VxdWVudGx5LCBhcmUgbm90IHByZXNlcnZlZCBieSB0aGlzIHRyYW5zZm9ybWF0aW9uLlxuICovXG5HcmFwaC5wcm90b3R5cGUudG9EaWdyYXBoID1cbkdyYXBoLnByb3RvdHlwZS5hc0RpcmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBnID0gbmV3IERpZ3JhcGgoKTtcbiAgdGhpcy5lYWNoTm9kZShmdW5jdGlvbih1LCB2YWx1ZSkgeyBnLmFkZE5vZGUodSwgdmFsdWUpOyB9KTtcbiAgdGhpcy5lYWNoRWRnZShmdW5jdGlvbihlLCB1LCB2LCB2YWx1ZSkge1xuICAgIGcuYWRkRWRnZShudWxsLCB1LCB2LCB2YWx1ZSk7XG4gICAgZy5hZGRFZGdlKG51bGwsIHYsIHUsIHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IHVuZGlyZWN0ZWQgZ3JhcGggdXNpbmcgdGhlIG5vZGVzIGFuZCBlZGdlcyBmcm9tIHRoaXMgZ3JhcGguXG4gKiBUaGUgbmV3IGdyYXBoIHdpbGwgaGF2ZSB0aGUgc2FtZSBub2RlcywgYnV0IHRoZSBlZGdlcyB3aWxsIGJlIG1hZGVcbiAqIHVuZGlyZWN0ZWQuIEVkZ2UgaWRzIGFyZSBwcmVzZXJ2ZWQgaW4gdGhpcyB0cmFuc2Zvcm1hdGlvbi5cbiAqL1xuRGlncmFwaC5wcm90b3R5cGUudG9HcmFwaCA9XG5EaWdyYXBoLnByb3RvdHlwZS5hc1VuZGlyZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGcgPSBuZXcgR3JhcGgoKTtcbiAgdGhpcy5lYWNoTm9kZShmdW5jdGlvbih1LCB2YWx1ZSkgeyBnLmFkZE5vZGUodSwgdmFsdWUpOyB9KTtcbiAgdGhpcy5lYWNoRWRnZShmdW5jdGlvbihlLCB1LCB2LCB2YWx1ZSkge1xuICAgIGcuYWRkRWRnZShlLCB1LCB2LCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gZztcbn07XG4iLCIvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB2YWx1ZXMgZm9yIHByb3BlcnRpZXMgb2YgKipvKiouXG5leHBvcnRzLnZhbHVlcyA9IGZ1bmN0aW9uKG8pIHtcbiAgdmFyIGtzID0gT2JqZWN0LmtleXMobyksXG4gICAgICBsZW4gPSBrcy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuKSxcbiAgICAgIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IG9ba3NbaV1dO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAnMC43LjQnO1xuIiwidm9pZCBmdW5jdGlvbigpe1xuICAndXNlIHN0cmljdCdcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbil7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZm4uYmluZChudWxsLCB0aGlzKS5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICB9XG4gIH1cbn0oKVxuIiwidmFyIGRvbWlmeSA9IHJlcXVpcmUoJ2RvbWlmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGVyZ2x1ZTtcbmZ1bmN0aW9uIGh5cGVyZ2x1ZSAoc3JjLCB1cGRhdGVzKSB7XG4gICAgaWYgKCF1cGRhdGVzKSB1cGRhdGVzID0ge307XG5cbiAgICB2YXIgZG9tID0gdHlwZW9mIHNyYyA9PT0gJ29iamVjdCdcbiAgICAgICAgPyBbIHNyYyBdXG4gICAgICAgIDogZG9taWZ5KHNyYylcbiAgICA7XG4gICAgZm9yRWFjaChvYmplY3RLZXlzKHVwZGF0ZXMpLCBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdXBkYXRlc1tzZWxlY3Rvcl07XG4gICAgICAgIGZvckVhY2goZG9tLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnOmZpcnN0Jykge1xuICAgICAgICAgICAgICAgIGJpbmQoZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoLzpmaXJzdCQvLnRlc3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBzZWxlY3Rvci5yZXBsYWNlKC86Zmlyc3QkLywgJycpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZC5xdWVyeVNlbGVjdG9yKGspO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtKSBiaW5kKGVsZW0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IGQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZChub2Rlc1tpXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZG9tLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IGRvbVswXVxuICAgICAgICA6IGRvbVxuICAgIDtcbn1cblxuZnVuY3Rpb24gYmluZCAobm9kZSwgdmFsdWUpIHtcbiAgICBpZiAoaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGUgPSBoeXBlcmdsdWUobm9kZS5jbG9uZU5vZGUodHJ1ZSksIHZhbHVlW2ldKTtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvckVhY2gob2JqZWN0S2V5cyh2YWx1ZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdfdGV4dCcpIHtcbiAgICAgICAgICAgICAgICBzZXRUZXh0KG5vZGUsIHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnX2h0bWwnICYmIGlzRWxlbWVudCh2YWx1ZVtrZXldKSkge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ19odG1sJykge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Ugbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Ugc2V0VGV4dChub2RlLCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykgZih4c1tpXSwgaSlcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCAoZSkge1xuICAgIHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiBlLmNoaWxkTm9kZXNcbiAgICAgICAgJiYgKHR5cGVvZiBlLmFwcGVuZENoaWxkID09PSAnZnVuY3Rpb24nXG4gICAgICAgIHx8IHR5cGVvZiBlLmFwcGVuZENoaWxkID09PSAnb2JqZWN0JylcbiAgICA7XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIHNldFRleHQgKGUsIHMpIHtcbiAgICBlLmlubmVySFRNTCA9ICcnO1xuICAgIHZhciB0eHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcocykpO1xuICAgIGUuYXBwZW5kQ2hpbGQodHh0KTtcbn1cbiIsIlxuLyoqXG4gKiBFeHBvc2UgYHBhcnNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG4vKipcbiAqIFdyYXAgbWFwIGZyb20ganF1ZXJ5LlxuICovXG5cbnZhciBtYXAgPSB7XG4gIG9wdGlvbjogWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J10sXG4gIG9wdGdyb3VwOiBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsICc8L3NlbGVjdD4nXSxcbiAgbGVnZW5kOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgdGhlYWQ6IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddLFxuICB0Ym9keTogWzEsICc8dGFibGU+JywgJzwvdGFibGU+J10sXG4gIHRmb290OiBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXSxcbiAgY29sZ3JvdXA6IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddLFxuICBjYXB0aW9uOiBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXSxcbiAgdHI6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuICB0ZDogWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J10sXG4gIHRoOiBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgX2RlZmF1bHQ6IFswLCAnJywgJyddXG59O1xuXG4vKipcbiAqIFBhcnNlIGBodG1sYCBhbmQgcmV0dXJuIHRoZSBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShodG1sKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgaHRtbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkJyk7XG4gIFxuICAvLyB0YWcgbmFtZVxuICB2YXIgbSA9IC88KFtcXHc6XSspLy5leGVjKGh0bWwpO1xuICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudHMgd2VyZSBnZW5lcmF0ZWQuJyk7XG4gIHZhciB0YWcgPSBtWzFdO1xuICBcbiAgLy8gYm9keSBzdXBwb3J0XG4gIGlmICh0YWcgPT0gJ2JvZHknKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIFtlbC5yZW1vdmVDaGlsZChlbC5sYXN0Q2hpbGQpXTtcbiAgfVxuICBcbiAgLy8gd3JhcCBtYXBcbiAgdmFyIHdyYXAgPSBtYXBbdGFnXSB8fCBtYXAuX2RlZmF1bHQ7XG4gIHZhciBkZXB0aCA9IHdyYXBbMF07XG4gIHZhciBwcmVmaXggPSB3cmFwWzFdO1xuICB2YXIgc3VmZml4ID0gd3JhcFsyXTtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsLmlubmVySFRNTCA9IHByZWZpeCArIGh0bWwgKyBzdWZmaXg7XG4gIHdoaWxlIChkZXB0aC0tKSBlbCA9IGVsLmxhc3RDaGlsZDtcblxuICByZXR1cm4gb3JwaGFuKGVsLmNoaWxkcmVuKTtcbn1cblxuLyoqXG4gKiBPcnBoYW4gYGVsc2AgYW5kIHJldHVybiBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge05vZGVMaXN0fSBlbHNcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gb3JwaGFuKGVscykge1xuICB2YXIgcmV0ID0gW107XG5cbiAgd2hpbGUgKGVscy5sZW5ndGgpIHtcbiAgICByZXQucHVzaChlbHNbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbHNbMF0pKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG4iLCJ2YXIgZGljdGlvbmFyeSA9IHtcbiAgd29yZHM6IFtcbiAgICAnYWQnLFxuICAgICdhZGlwaXNpY2luZycsXG4gICAgJ2FsaXF1YScsXG4gICAgJ2FsaXF1aXAnLFxuICAgICdhbWV0JyxcbiAgICAnYW5pbScsXG4gICAgJ2F1dGUnLFxuICAgICdjaWxsdW0nLFxuICAgICdjb21tb2RvJyxcbiAgICAnY29uc2VjdGV0dXInLFxuICAgICdjb25zZXF1YXQnLFxuICAgICdjdWxwYScsXG4gICAgJ2N1cGlkYXRhdCcsXG4gICAgJ2Rlc2VydW50JyxcbiAgICAnZG8nLFxuICAgICdkb2xvcicsXG4gICAgJ2RvbG9yZScsXG4gICAgJ2R1aXMnLFxuICAgICdlYScsXG4gICAgJ2VpdXNtb2QnLFxuICAgICdlbGl0JyxcbiAgICAnZW5pbScsXG4gICAgJ2Vzc2UnLFxuICAgICdlc3QnLFxuICAgICdldCcsXG4gICAgJ2V1JyxcbiAgICAnZXgnLFxuICAgICdleGNlcHRldXInLFxuICAgICdleGVyY2l0YXRpb24nLFxuICAgICdmdWdpYXQnLFxuICAgICdpZCcsXG4gICAgJ2luJyxcbiAgICAnaW5jaWRpZHVudCcsXG4gICAgJ2lwc3VtJyxcbiAgICAnaXJ1cmUnLFxuICAgICdsYWJvcmUnLFxuICAgICdsYWJvcmlzJyxcbiAgICAnbGFib3J1bScsXG4gICAgJ0xvcmVtJyxcbiAgICAnbWFnbmEnLFxuICAgICdtaW5pbScsXG4gICAgJ21vbGxpdCcsXG4gICAgJ25pc2knLFxuICAgICdub24nLFxuICAgICdub3N0cnVkJyxcbiAgICAnbnVsbGEnLFxuICAgICdvY2NhZWNhdCcsXG4gICAgJ29mZmljaWEnLFxuICAgICdwYXJpYXR1cicsXG4gICAgJ3Byb2lkZW50JyxcbiAgICAncXVpJyxcbiAgICAncXVpcycsXG4gICAgJ3JlcHJlaGVuZGVyaXQnLFxuICAgICdzaW50JyxcbiAgICAnc2l0JyxcbiAgICAnc3VudCcsXG4gICAgJ3RlbXBvcicsXG4gICAgJ3VsbGFtY28nLFxuICAgICd1dCcsXG4gICAgJ3ZlbGl0JyxcbiAgICAndmVuaWFtJyxcbiAgICAndm9sdXB0YXRlJyAgXG4gIF1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGljdGlvbmFyeTsiLCJ2YXIgZ2VuZXJhdG9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcHRpb25zID0gKGFyZ3VtZW50cy5sZW5ndGgpID8gYXJndW1lbnRzWzBdIDoge31cbiAgICAsIGNvdW50ID0gb3B0aW9ucy5jb3VudCB8fCAxXG4gICAgLCB1bml0cyA9IG9wdGlvbnMudW5pdHMgfHwgJ3NlbnRlbmNlcydcbiAgICAsIHNlbnRlbmNlTG93ZXJCb3VuZCA9IG9wdGlvbnMuc2VudGVuY2VMb3dlckJvdW5kIHx8IDVcbiAgICAsIHNlbnRlbmNlVXBwZXJCb3VuZCA9IG9wdGlvbnMuc2VudGVuY2VVcHBlckJvdW5kIHx8IDE1XG5cdCAgLCBwYXJhZ3JhcGhMb3dlckJvdW5kID0gb3B0aW9ucy5wYXJhZ3JhcGhMb3dlckJvdW5kIHx8IDNcblx0ICAsIHBhcmFncmFwaFVwcGVyQm91bmQgPSBvcHRpb25zLnBhcmFncmFwaFVwcGVyQm91bmQgfHwgN1xuXHQgICwgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgJ3BsYWluJ1xuICAgICwgd29yZHMgPSBvcHRpb25zLndvcmRzIHx8IHJlcXVpcmUoJy4vZGljdGlvbmFyeScpLndvcmRzXG4gICAgLCByYW5kb20gPSBvcHRpb25zLnJhbmRvbSB8fCBNYXRoLnJhbmRvbTtcblxuICB1bml0cyA9IHNpbXBsZVBsdXJhbGl6ZSh1bml0cy50b0xvd2VyQ2FzZSgpKTtcblxuICB2YXIgcmFuZG9tSW50ZWdlciA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pO1xuICB9O1xuICBcbiAgdmFyIHJhbmRvbVdvcmQgPSBmdW5jdGlvbih3b3Jkcykge1xuICAgIHJldHVybiB3b3Jkc1tyYW5kb21JbnRlZ2VyKDAsIHdvcmRzLmxlbmd0aCAtIDEpXTtcbiAgfTtcbiAgXG4gIHZhciByYW5kb21TZW50ZW5jZSA9IGZ1bmN0aW9uKHdvcmRzLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gICAgdmFyIHNlbnRlbmNlID0gJydcbiAgICAgICwgYm91bmRzID0ge21pbjogMCwgbWF4OiByYW5kb21JbnRlZ2VyKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpfTtcbiAgICBcbiAgICB3aGlsZSAoYm91bmRzLm1pbiA8IGJvdW5kcy5tYXgpIHtcbiAgICAgIHNlbnRlbmNlID0gc2VudGVuY2UgKyAnICcgKyByYW5kb21Xb3JkKHdvcmRzKTtcbiAgICAgIGJvdW5kcy5taW4gPSBib3VuZHMubWluICsgMTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHNlbnRlbmNlLmxlbmd0aCkge1xuICAgICAgc2VudGVuY2UgPSBzZW50ZW5jZS5zbGljZSgxKTtcbiAgICAgIHNlbnRlbmNlID0gc2VudGVuY2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzZW50ZW5jZS5zbGljZSgxKTtcbiAgICB9XG4gIFxuICAgIHJldHVybiBzZW50ZW5jZTtcbiAgfTtcblxuICB2YXIgcmFuZG9tUGFyYWdyYXBoID0gZnVuY3Rpb24od29yZHMsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIHNlbnRlbmNlTG93ZXJCb3VuZCwgc2VudGVuY2VVcHBlckJvdW5kKSB7XG4gICAgdmFyIHBhcmFncmFwaCA9ICcnXG4gICAgICAsIGJvdW5kcyA9IHttaW46IDAsIG1heDogcmFuZG9tSW50ZWdlcihsb3dlckJvdW5kLCB1cHBlckJvdW5kKX07XG4gICAgICBcbiAgICB3aGlsZSAoYm91bmRzLm1pbiA8IGJvdW5kcy5tYXgpIHtcbiAgICAgIHBhcmFncmFwaCA9IHBhcmFncmFwaCArICcuICcgKyByYW5kb21TZW50ZW5jZSh3b3Jkcywgc2VudGVuY2VMb3dlckJvdW5kLCBzZW50ZW5jZVVwcGVyQm91bmQpO1xuICAgICAgYm91bmRzLm1pbiA9IGJvdW5kcy5taW4gKyAxO1xuICAgIH1cbiAgICBcbiAgICBpZiAocGFyYWdyYXBoLmxlbmd0aCkge1xuICAgICAgcGFyYWdyYXBoID0gcGFyYWdyYXBoLnNsaWNlKDIpO1xuICAgICAgcGFyYWdyYXBoID0gcGFyYWdyYXBoICsgJy4nO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcGFyYWdyYXBoO1xuICB9XG4gIFxuICB2YXIgaXRlciA9IDBcbiAgICAsIGJvdW5kcyA9IHttaW46IDAsIG1heDogY291bnR9XG4gICAgLCBzdHJpbmcgPSAnJ1xuICAgICwgcHJlZml4ID0gJydcbiAgICAsIHN1ZmZpeCA9IFwiXFxyXFxuXCI7XG5cbiAgaWYgKGZvcm1hdCA9PSAnaHRtbCcpIHtcbiAgICBwcmVmaXggPSAnPHA+JztcbiAgICBzdWZmaXggPSAnPC9wPic7XG4gIH1cbiAgICAgIFxuICB3aGlsZSAoYm91bmRzLm1pbiA8IGJvdW5kcy5tYXgpIHtcbiAgICBzd2l0Y2ggKHVuaXRzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ3dvcmRzJzpcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nICsgJyAnICsgcmFuZG9tV29yZCh3b3Jkcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VudGVuY2VzJzpcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nICsgJy4gJyArIHJhbmRvbVNlbnRlbmNlKHdvcmRzLCBzZW50ZW5jZUxvd2VyQm91bmQsIHNlbnRlbmNlVXBwZXJCb3VuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGFyYWdyYXBocyc6XG4gICAgICAgIHN0cmluZyA9IHN0cmluZyArIHByZWZpeCArIHJhbmRvbVBhcmFncmFwaCh3b3JkcywgcGFyYWdyYXBoTG93ZXJCb3VuZCwgcGFyYWdyYXBoVXBwZXJCb3VuZCwgc2VudGVuY2VMb3dlckJvdW5kLCBzZW50ZW5jZVVwcGVyQm91bmQpICsgc3VmZml4O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgYm91bmRzLm1pbiA9IGJvdW5kcy5taW4gKyAxO1xuICB9XG4gICAgXG4gIGlmIChzdHJpbmcubGVuZ3RoKSB7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgXG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCcuICcpID09IDApIHtcbiAgICAgIHBvcyA9IDI7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZignLicpID09IDAgfHwgc3RyaW5nLmluZGV4T2YoJyAnKSA9PSAwKSB7XG4gICAgICBwb3MgPSAxO1xuICAgIH1cbiAgICBcbiAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UocG9zKTtcbiAgICBcbiAgICBpZiAodW5pdHMgPT0gJ3NlbnRlbmNlcycpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyArICcuJztcbiAgICB9XG4gIH0gIFxuICBcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbmZ1bmN0aW9uIHNpbXBsZVBsdXJhbGl6ZShzdHJpbmcpIHtcbiAgaWYgKHN0cmluZy5pbmRleE9mKCdzJywgc3RyaW5nLmxlbmd0aCAtIDEpID09PSAtMSkge1xuICAgIHJldHVybiBzdHJpbmcgKyAncyc7XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0b3I7XG4iLCJ2b2lkIGZ1bmN0aW9uKHJvb3Qpe1xuXG4gIGZ1bmN0aW9uIGRlZmF1bHRzKG9wdGlvbnMpe1xuICAgIHZhciBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBtaW4gPSBvcHRpb25zLm1pblxuICAgIHZhciBtYXggPSBvcHRpb25zLm1heFxuICAgIHZhciBpbnRlZ2VyID0gb3B0aW9ucy5pbnRlZ2VyIHx8IGZhbHNlXG4gICAgaWYgKCBtaW4gPT0gbnVsbCAmJiBtYXggPT0gbnVsbCApIHtcbiAgICAgIG1pbiA9IDBcbiAgICAgIG1heCA9IDFcbiAgICB9IGVsc2UgaWYgKCBtaW4gPT0gbnVsbCApIHtcbiAgICAgIG1pbiA9IG1heCAtIDFcbiAgICB9IGVsc2UgaWYgKCBtYXggPT0gbnVsbCApIHtcbiAgICAgIG1heCA9IG1pbiArIDFcbiAgICB9XG4gICAgaWYgKCBtYXggPCBtaW4gKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3B0aW9ucywgbWF4IG11c3QgYmUgPj0gbWluJylcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiAgICAgbWluXG4gICAgLCBtYXg6ICAgICBtYXhcbiAgICAsIGludGVnZXI6IGludGVnZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByYW5kb20ob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMpXG4gICAgaWYgKCBvcHRpb25zLm1heCA9PT0gb3B0aW9ucy5taW4gKSByZXR1cm4gb3B0aW9ucy5taW5cbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAob3B0aW9ucy5tYXggLSBvcHRpb25zLm1pbiArIE51bWJlcighIW9wdGlvbnMuaW50ZWdlcikpICsgb3B0aW9ucy5taW5cbiAgICByZXR1cm4gb3B0aW9ucy5pbnRlZ2VyID8gTWF0aC5mbG9vcihyKSA6IHJcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRvcihvcHRpb25zKXtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucylcbiAgICByZXR1cm4gZnVuY3Rpb24obWluLCBtYXgsIGludGVnZXIpe1xuICAgICAgb3B0aW9ucy5taW4gICAgID0gbWluICAgICB8fCBvcHRpb25zLm1pblxuICAgICAgb3B0aW9ucy5tYXggICAgID0gbWF4ICAgICB8fCBvcHRpb25zLm1heFxuICAgICAgb3B0aW9ucy5pbnRlZ2VyID0gaW50ZWdlciAhPSBudWxsID8gaW50ZWdlciA6IG9wdGlvbnMuaW50ZWdlclxuICAgICAgcmV0dXJuIHJhbmRvbShvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gIHJhbmRvbVxuICBtb2R1bGUuZXhwb3J0cy5nZW5lcmF0b3IgPSBnZW5lcmF0b3JcbiAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0c1xufSh0aGlzKVxuIiwidm9pZCBmdW5jdGlvbihyb290KXtcblxuICAgIC8vIHJldHVybiBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIG1heC0xXG4gICAgZnVuY3Rpb24gcihtYXgpeyByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKm1heCkgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUoc2FsdCwgc2l6ZSl7XG4gICAgICAgIHZhciBrZXkgPSAnJ1xuICAgICAgICB2YXIgc2wgPSBzYWx0Lmxlbmd0aFxuICAgICAgICB3aGlsZSAoIHNpemUgLS0gKSB7XG4gICAgICAgICAgICB2YXIgcm5kID0gcihzbClcbiAgICAgICAgICAgIGtleSArPSBzYWx0W3JuZF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5XG4gICAgfVxuXG4gICAgdmFyIHJuZHRvayA9IGZ1bmN0aW9uKHNhbHQsIHNpemUpe1xuICAgICAgICByZXR1cm4gaXNOYU4oc2l6ZSkgPyB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgc2l6ZSA8IDEgICAgPyB1bmRlZmluZWQgOiBnZW5lcmF0ZShzYWx0LCBzaXplKVxuXG4gICAgfVxuXG4gICAgcm5kdG9rLmdlbiA9IGNyZWF0ZUdlbmVyYXRvclxuXG4gICAgZnVuY3Rpb24gY3JlYXRlR2VuZXJhdG9yKHNhbHQpe1xuICAgICAgICBzYWx0ID0gdHlwZW9mIHNhbHQgID09ICdzdHJpbmcnICYmIHNhbHQubGVuZ3RoID4gMCA/IHNhbHQgOiAgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHp5MDEyMzQ1Njc4OSdcbiAgICAgICAgdmFyIHRlbXAgPSBybmR0b2suYmluZChybmR0b2ssIHNhbHQpXG4gICAgICAgIHRlbXAuc2FsdCA9IGZ1bmN0aW9uKCl7IHJldHVybiBzYWx0IH1cbiAgICAgICAgdGVtcC5jcmVhdGUgPSBjcmVhdGVHZW5lcmF0b3JcbiAgICAgICAgdGVtcC5nZW4gPSBjcmVhdGVHZW5lcmF0b3JcbiAgICAgICAgcmV0dXJuIHRlbXBcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUdlbmVyYXRvcigpXG5cbn0odGhpcylcbiIsIi8vIFNuYXAuc3ZnIDAuMi4wXG4vL1xuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLy9cbi8vIGJ1aWxkOiAyMDE0LTAyLTA4XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgXFxcXFxuLy8g4pSCIEV2ZSAwLjQuMiAtIEphdmFTY3JpcHQgRXZlbnRzIExpYnJhcnkgICAgICAgICAgICAgICAgICAgICAg4pSCIFxcXFxcbi8vIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpCBcXFxcXG4vLyDilIIgQXV0aG9yIERtaXRyeSBCYXJhbm92c2tpeSAoaHR0cDovL2RtaXRyeS5iYXJhbm92c2tpeS5jb20vKSDilIIgXFxcXFxuLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxcXFxcblxuKGZ1bmN0aW9uIChnbG9iKSB7XG4gICAgdmFyIHZlcnNpb24gPSBcIjAuNC4yXCIsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgc2VwYXJhdG9yID0gL1tcXC5cXC9dLyxcbiAgICAgICAgd2lsZGNhcmQgPSBcIipcIixcbiAgICAgICAgZnVuID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG51bXNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50X2V2ZW50LFxuICAgICAgICBzdG9wLFxuICAgICAgICBldmVudHMgPSB7bjoge319LFxuICAgIC8qXFxcbiAgICAgKiBldmVcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogRmlyZXMgZXZlbnQgd2l0aCBnaXZlbiBgbmFtZWAsIGdpdmVuIHNjb3BlIGFuZCBvdGhlciBwYXJhbWV0ZXJzLlxuXG4gICAgID4gQXJndW1lbnRzXG5cbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlICpldmVudCosIGRvdCAoYC5gKSBvciBzbGFzaCAoYC9gKSBzZXBhcmF0ZWRcbiAgICAgLSBzY29wZSAob2JqZWN0KSBjb250ZXh0IGZvciB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgLSB2YXJhcmdzICguLi4pIHRoZSByZXN0IG9mIGFyZ3VtZW50cyB3aWxsIGJlIHNlbnQgdG8gZXZlbnQgaGFuZGxlcnNcblxuICAgICA9IChvYmplY3QpIGFycmF5IG9mIHJldHVybmVkIHZhbHVlcyBmcm9tIHRoZSBsaXN0ZW5lcnNcbiAgICBcXCovXG4gICAgICAgIGV2ZSA9IGZ1bmN0aW9uIChuYW1lLCBzY29wZSkge1xuXHRcdFx0bmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgICAgICAgIHZhciBlID0gZXZlbnRzLFxuICAgICAgICAgICAgICAgIG9sZHN0b3AgPSBzdG9wLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGV2ZS5saXN0ZW5lcnMobmFtZSksXG4gICAgICAgICAgICAgICAgeiA9IDAsXG4gICAgICAgICAgICAgICAgZiA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgICAgaW5kZXhlZCA9IFtdLFxuICAgICAgICAgICAgICAgIHF1ZXVlID0ge30sXG4gICAgICAgICAgICAgICAgb3V0ID0gW10sXG4gICAgICAgICAgICAgICAgY2UgPSBjdXJyZW50X2V2ZW50LFxuICAgICAgICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgY3VycmVudF9ldmVudCA9IG5hbWU7XG4gICAgICAgICAgICBzdG9wID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoXCJ6SW5kZXhcIiBpbiBsaXN0ZW5lcnNbaV0pIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2gobGlzdGVuZXJzW2ldLnpJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS56SW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlW2xpc3RlbmVyc1tpXS56SW5kZXhdID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ZWQuc29ydChudW1zb3J0KTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleGVkW3pdIDwgMCkge1xuICAgICAgICAgICAgICAgIGwgPSBxdWV1ZVtpbmRleGVkW3orK11dO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gb2xkc3RvcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGwgPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKFwiekluZGV4XCIgaW4gbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobC56SW5kZXggPT0gaW5kZXhlZFt6XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2gobC5hcHBseShzY29wZSwgYXJncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHF1ZXVlW2luZGV4ZWRbel1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgJiYgb3V0LnB1c2gobC5hcHBseShzY29wZSwgYXJncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGwpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVtsLnpJbmRleF0gPSBsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2gobC5hcHBseShzY29wZSwgYXJncykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wID0gb2xkc3RvcDtcbiAgICAgICAgICAgIGN1cnJlbnRfZXZlbnQgPSBjZTtcbiAgICAgICAgICAgIHJldHVybiBvdXQubGVuZ3RoID8gb3V0IDogbnVsbDtcbiAgICAgICAgfTtcblx0XHQvLyBVbmRvY3VtZW50ZWQuIERlYnVnIG9ubHkuXG5cdFx0ZXZlLl9ldmVudHMgPSBldmVudHM7XG4gICAgLypcXFxuICAgICAqIGV2ZS5saXN0ZW5lcnNcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHdoaWNoIGdpdmVzIHlvdSBhcnJheSBvZiBhbGwgZXZlbnQgaGFuZGxlcnMgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCBieSB0aGUgZ2l2ZW4gYG5hbWVgLlxuXG4gICAgID4gQXJndW1lbnRzXG5cbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkXG5cbiAgICAgPSAoYXJyYXkpIGFycmF5IG9mIGV2ZW50IGhhbmRsZXJzXG4gICAgXFwqL1xuICAgIGV2ZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICBlID0gZXZlbnRzLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBqaixcbiAgICAgICAgICAgIG5lcyxcbiAgICAgICAgICAgIGVzID0gW2VdLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGVzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlID0gZXNbal0ubjtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtlW25hbWVzW2ldXSwgZVt3aWxkY2FyZF1dO1xuICAgICAgICAgICAgICAgIGsgPSAyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KGl0ZW0uZiB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcyA9IG5lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICAvKlxcXG4gICAgICogZXZlLm9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCaW5kcyBnaXZlbiBldmVudCBoYW5kbGVyIHdpdGggYSBnaXZlbiBuYW1lLiBZb3UgY2FuIHVzZSB3aWxkY2FyZHMg4oCcYCpg4oCdIGZvciB0aGUgbmFtZXM6XG4gICAgIHwgZXZlLm9uKFwiKi51bmRlci4qXCIsIGYpO1xuICAgICB8IGV2ZShcIm1vdXNlLnVuZGVyLmZsb29yXCIpOyAvLyB0cmlnZ2VycyBmXG4gICAgICogVXNlIEBldmUgdG8gdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAgICoqXG4gICAgID4gQXJndW1lbnRzXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqKlxuICAgICA9IChmdW5jdGlvbikgcmV0dXJuZWQgZnVuY3Rpb24gYWNjZXB0cyBhIHNpbmdsZSBudW1lcmljIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgei1pbmRleCBvZiB0aGUgaGFuZGxlci4gSXQgaXMgYW4gb3B0aW9uYWwgZmVhdHVyZSBhbmQgb25seSB1c2VkIHdoZW4geW91IG5lZWQgdG8gZW5zdXJlIHRoYXQgc29tZSBzdWJzZXQgb2YgaGFuZGxlcnMgd2lsbCBiZSBpbnZva2VkIGluIGEgZ2l2ZW4gb3JkZXIsIGRlc3BpdGUgb2YgdGhlIG9yZGVyIG9mIGFzc2lnbm1lbnQuXG4gICAgID4gRXhhbXBsZTpcbiAgICAgfCBldmUub24oXCJtb3VzZVwiLCBlYXRJdCkoMik7XG4gICAgIHwgZXZlLm9uKFwibW91c2VcIiwgc2NyZWFtKTtcbiAgICAgfCBldmUub24oXCJtb3VzZVwiLCBjYXRjaEl0KSgxKTtcbiAgICAgKiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgYGNhdGNoSXQoKWAgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGBlYXRJdCgpYC5cblx0ICpcbiAgICAgKiBJZiB5b3Ugd2FudCB0byBwdXQgeW91ciBoYW5kbGVyIGJlZm9yZSBub24taW5kZXhlZCBoYW5kbGVycywgc3BlY2lmeSBhIG5lZ2F0aXZlIHZhbHVlLlxuICAgICAqIE5vdGU6IEkgYXNzdW1lIG1vc3Qgb2YgdGhlIHRpbWUgeW91IGRvbuKAmXQgbmVlZCB0byB3b3JyeSBhYm91dCB6LWluZGV4LCBidXQgaXTigJlzIG5pY2UgdG8gaGF2ZSB0aGlzIGZlYXR1cmUg4oCcanVzdCBpbiBjYXNl4oCdLlxuICAgIFxcKi9cbiAgICBldmUub24gPSBmdW5jdGlvbiAobmFtZSwgZikge1xuXHRcdG5hbWUgPSBTdHJpbmcobmFtZSk7XG5cdFx0aWYgKHR5cGVvZiBmICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuXHRcdH1cbiAgICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChzZXBhcmF0b3IpLFxuICAgICAgICAgICAgZSA9IGV2ZW50cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgZSA9IGUubjtcbiAgICAgICAgICAgIGUgPSBlLmhhc093blByb3BlcnR5KG5hbWVzW2ldKSAmJiBlW25hbWVzW2ldXSB8fCAoZVtuYW1lc1tpXV0gPSB7bjoge319KTtcbiAgICAgICAgfVxuICAgICAgICBlLmYgPSBlLmYgfHwgW107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gZS5mLmxlbmd0aDsgaSA8IGlpOyBpKyspIGlmIChlLmZbaV0gPT0gZikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bjtcbiAgICAgICAgfVxuICAgICAgICBlLmYucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh6SW5kZXgpIHtcbiAgICAgICAgICAgIGlmICgrekluZGV4ID09ICt6SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBmLnpJbmRleCA9ICt6SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLmZcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGZpcmUgZ2l2ZW4gZXZlbnQgd2l0aCBvcHRpb25hbCBhcmd1bWVudHMuXG5cdCAqIEFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSByZXN1bHQgZnVuY3Rpb24gd2lsbCBiZSBhbHNvXG5cdCAqIGNvbmNhdGVkIHRvIHRoZSBsaXN0IG9mIGZpbmFsIGFyZ3VtZW50cy5cbiBcdCB8IGVsLm9uY2xpY2sgPSBldmUuZihcImNsaWNrXCIsIDEsIDIpO1xuIFx0IHwgZXZlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiBcdCB8ICAgICBjb25zb2xlLmxvZyhhLCBiLCBjKTsgLy8gMSwgMiwgW2V2ZW50IG9iamVjdF1cbiBcdCB8IH0pO1xuICAgICA+IEFyZ3VtZW50c1xuXHQgLSBldmVudCAoc3RyaW5nKSBldmVudCBuYW1lXG5cdCAtIHZhcmFyZ3MgKOKApikgYW5kIGFueSBvdGhlciBhcmd1bWVudHNcblx0ID0gKGZ1bmN0aW9uKSBwb3NzaWJsZSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgXFwqL1xuXHRldmUuZiA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBhdHRycyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0ZXZlLmFwcGx5KG51bGwsIFtldmVudCwgbnVsbF0uY29uY2F0KGF0dHJzKS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKSk7XG5cdFx0fTtcblx0fTtcbiAgICAvKlxcXG4gICAgICogZXZlLnN0b3BcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIElzIHVzZWQgaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXIgdG8gc3RvcCB0aGUgZXZlbnQsIHByZXZlbnRpbmcgYW55IHN1YnNlcXVlbnQgbGlzdGVuZXJzIGZyb20gZmlyaW5nLlxuICAgIFxcKi9cbiAgICBldmUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RvcCA9IDE7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLm50XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDb3VsZCBiZSB1c2VkIGluc2lkZSBldmVudCBoYW5kbGVyIHRvIGZpZ3VyZSBvdXQgYWN0dWFsIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqKlxuICAgICA+IEFyZ3VtZW50c1xuICAgICAqKlxuICAgICAtIHN1Ym5hbWUgKHN0cmluZykgI29wdGlvbmFsIHN1Ym5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICoqXG4gICAgID0gKHN0cmluZykgbmFtZSBvZiB0aGUgZXZlbnQsIGlmIGBzdWJuYW1lYCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICogb3JcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgLCBpZiBjdXJyZW50IGV2ZW504oCZcyBuYW1lIGNvbnRhaW5zIGBzdWJuYW1lYFxuICAgIFxcKi9cbiAgICBldmUubnQgPSBmdW5jdGlvbiAoc3VibmFtZSkge1xuICAgICAgICBpZiAoc3VibmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpcXFxcLnxcXFxcL3xeKVwiICsgc3VibmFtZSArIFwiKD86XFxcXC58XFxcXC98JClcIikudGVzdChjdXJyZW50X2V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudF9ldmVudDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUubnRzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDb3VsZCBiZSB1c2VkIGluc2lkZSBldmVudCBoYW5kbGVyIHRvIGZpZ3VyZSBvdXQgYWN0dWFsIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqKlxuICAgICAqKlxuICAgICA9IChhcnJheSkgbmFtZXMgb2YgdGhlIGV2ZW50XG4gICAgXFwqL1xuICAgIGV2ZS5udHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50X2V2ZW50LnNwbGl0KHNlcGFyYXRvcik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLm9mZlxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBnaXZlbiBmdW5jdGlvbiBmcm9tIHRoZSBsaXN0IG9mIGV2ZW50IGxpc3RlbmVycyBhc3NpZ25lZCB0byBnaXZlbiBuYW1lLlxuXHQgKiBJZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkIGFsbCB0aGUgZXZlbnRzIHdpbGwgYmUgY2xlYXJlZC5cbiAgICAgKipcbiAgICAgPiBBcmd1bWVudHNcbiAgICAgKipcbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkLCB3aXRoIG9wdGlvbmFsIHdpbGRjYXJkc1xuICAgICAtIGYgKGZ1bmN0aW9uKSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBldmUudW5iaW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQGV2ZS5vZmZcbiAgICBcXCovXG4gICAgZXZlLm9mZiA9IGV2ZS51bmJpbmQgPSBmdW5jdGlvbiAobmFtZSwgZikge1xuXHRcdGlmICghbmFtZSkge1xuXHRcdCAgICBldmUuX2V2ZW50cyA9IGV2ZW50cyA9IHtuOiB7fX07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgc3BsaWNlLFxuICAgICAgICAgICAgaSwgaWksIGosIGpqLFxuICAgICAgICAgICAgY3VyID0gW2V2ZW50c107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1ci5sZW5ndGg7IGogKz0gc3BsaWNlLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpY2UgPSBbaiwgMV07XG4gICAgICAgICAgICAgICAgZSA9IGN1cltqXS5uO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc1tpXSAhPSB3aWxkY2FyZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZVtuYW1lc1tpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZS5wdXNoKGVbbmFtZXNbaV1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGUpIGlmIChlW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlLnB1c2goZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXIuc3BsaWNlLmFwcGx5KGN1ciwgc3BsaWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGN1ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBlID0gY3VyW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGUubikge1xuICAgICAgICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGpqID0gZS5mLmxlbmd0aDsgaiA8IGpqOyBqKyspIGlmIChlLmZbal0gPT0gZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZi5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAhZS5mLmxlbmd0aCAmJiBkZWxldGUgZS5mO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGUubikgaWYgKGUubltoYXNdKGtleSkgJiYgZS5uW2tleV0uZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmNzID0gZS5uW2tleV0uZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGpqID0gZnVuY3MubGVuZ3RoOyBqIDwgamo7IGorKykgaWYgKGZ1bmNzW2pdID09IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3MubGVuZ3RoICYmIGRlbGV0ZSBlLm5ba2V5XS5mO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGUuZjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gZS5uKSBpZiAoZS5uW2hhc10oa2V5KSAmJiBlLm5ba2V5XS5mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZS5uW2tleV0uZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlID0gZS5uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLm9uY2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJpbmRzIGdpdmVuIGV2ZW50IGhhbmRsZXIgd2l0aCBhIGdpdmVuIG5hbWUgdG8gb25seSBydW4gb25jZSB0aGVuIHVuYmluZCBpdHNlbGYuXG4gICAgIHwgZXZlLm9uY2UoXCJsb2dpblwiLCBmKTtcbiAgICAgfCBldmUoXCJsb2dpblwiKTsgLy8gdHJpZ2dlcnMgZlxuICAgICB8IGV2ZShcImxvZ2luXCIpOyAvLyBubyBsaXN0ZW5lcnNcbiAgICAgKiBVc2UgQGV2ZSB0byB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cbiAgICAgKipcbiAgICAgPiBBcmd1bWVudHNcbiAgICAgKipcbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkLCB3aXRoIG9wdGlvbmFsIHdpbGRjYXJkc1xuICAgICAtIGYgKGZ1bmN0aW9uKSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICoqXG4gICAgID0gKGZ1bmN0aW9uKSBzYW1lIHJldHVybiBmdW5jdGlvbiBhcyBAZXZlLm9uXG4gICAgXFwqL1xuICAgIGV2ZS5vbmNlID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgdmFyIGYyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXZlLnVuYmluZChuYW1lLCBmMik7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXZlLm9uKG5hbWUsIGYyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUudmVyc2lvblxuICAgICBbIHByb3BlcnR5IChzdHJpbmcpIF1cbiAgICAgKipcbiAgICAgKiBDdXJyZW50IHZlcnNpb24gb2YgdGhlIGxpYnJhcnkuXG4gICAgXFwqL1xuICAgIGV2ZS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBldmUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIllvdSBhcmUgcnVubmluZyBFdmUgXCIgKyB2ZXJzaW9uO1xuICAgIH07XG4gICAgKHR5cGVvZiBtb2R1bGUgIT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykgPyAobW9kdWxlLmV4cG9ydHMgPSBldmUpIDogKHR5cGVvZiBkZWZpbmUgIT0gXCJ1bmRlZmluZWRcIiA/IChkZWZpbmUoXCJldmVcIiwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXZlOyB9KSkgOiAoZ2xvYi5ldmUgPSBldmUpKTtcbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24gKGdsb2IsIGZhY3RvcnkpIHtcbiAgICAvLyBBTUQgc3VwcG9ydFxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZVxuICAgICAgICBkZWZpbmUoW1wiZXZlXCJdLCBmdW5jdGlvbiggZXZlICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoZ2xvYiwgZXZlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTmV4dCBmb3IgTm9kZS5qcyBvciBDb21tb25KU1xuICAgICAgICB2YXIgZXZlID0gcmVxdWlyZSgnZXZlJyk7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShnbG9iLCBldmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAoZ2xvYiBpcyB3aW5kb3cpXG4gICAgICAgIC8vIFNuYXAgYWRkcyBpdHNlbGYgdG8gd2luZG93XG4gICAgICAgIGZhY3RvcnkoZ2xvYiwgZ2xvYi5ldmUpO1xuICAgIH1cbn0od2luZG93IHx8IHRoaXMsIGZ1bmN0aW9uICh3aW5kb3csIGV2ZSkge1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgbWluYSA9IChmdW5jdGlvbiAoZXZlKSB7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSB7fSxcbiAgICByZXF1ZXN0QW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhIGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSxcbiAgICBpZGdlbiA9IDAsXG4gICAgaWRwcmVmaXggPSBcIk1cIiArICgrbmV3IERhdGUpLnRvU3RyaW5nKDM2KSxcbiAgICBJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkcHJlZml4ICsgKGlkZ2VuKyspLnRvU3RyaW5nKDM2KTtcbiAgICB9LFxuICAgIGRpZmYgPSBmdW5jdGlvbiAoYSwgYiwgQSwgQikge1xuICAgICAgICBpZiAoaXNBcnJheShhKSkge1xuICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBkaWZmKGFbaV0sIGIsIEFbaV0sIEIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlmID0gKEEgLSBhKSAvIChCIC0gYik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYmIpIHtcbiAgICAgICAgICAgIHJldHVybiBhICsgZGlmICogKGJiIC0gYik7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0aW1lciA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICtuZXcgRGF0ZTtcbiAgICB9LFxuICAgIHN0YSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRzID0gYS5zIC0gdmFsO1xuICAgICAgICBhLmIgKz0gYS5kdXIgKiBkcztcbiAgICAgICAgYS5CICs9IGEuZHVyICogZHM7XG4gICAgICAgIGEucyA9IHZhbDtcbiAgICB9LFxuICAgIHNwZWVkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGEuc3BkO1xuICAgICAgICB9XG4gICAgICAgIGEuc3BkID0gdmFsO1xuICAgIH0sXG4gICAgZHVyYXRpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5kdXI7XG4gICAgICAgIH1cbiAgICAgICAgYS5zID0gYS5zICogdmFsIC8gYS5kdXI7XG4gICAgICAgIGEuZHVyID0gdmFsO1xuICAgIH0sXG4gICAgc3RvcGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGRlbGV0ZSBhbmltYXRpb25zW2EuaWRdO1xuICAgICAgICBldmUoXCJtaW5hLnN0b3AuXCIgKyBhLmlkLCBhKTtcbiAgICB9LFxuICAgIHBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmIChhLnBkaWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgYW5pbWF0aW9uc1thLmlkXTtcbiAgICAgICAgYS5wZGlmID0gYS5nZXQoKSAtIGEuYjtcbiAgICB9LFxuICAgIHJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBpZiAoIWEucGRpZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGEuYiA9IGEuZ2V0KCkgLSBhLnBkaWY7XG4gICAgICAgIGRlbGV0ZSBhLnBkaWY7XG4gICAgICAgIGFuaW1hdGlvbnNbYS5pZF0gPSBhO1xuICAgIH0sXG4gICAgZnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgICBmb3IgKHZhciBpIGluIGFuaW1hdGlvbnMpIGlmIChhbmltYXRpb25zLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFuaW1hdGlvbnNbaV0sXG4gICAgICAgICAgICAgICAgYiA9IGEuZ2V0KCksXG4gICAgICAgICAgICAgICAgcmVzO1xuICAgICAgICAgICAgbGVuKys7XG4gICAgICAgICAgICBhLnMgPSAoYiAtIGEuYikgLyAoYS5kdXIgLyBhLnNwZCk7XG4gICAgICAgICAgICBpZiAoYS5zID49IDEpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYW5pbWF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBhLnMgPSAxO1xuICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZShcIm1pbmEuZmluaXNoLlwiICsgYS5pZCwgYSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0oYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoYS5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBhLnN0YXJ0Lmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2pdID0gK2Euc3RhcnRbal0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGEuZW5kW2pdIC0gYS5zdGFydFtqXSkgKiBhLmVhc2luZyhhLnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gK2Euc3RhcnQgKyAoYS5lbmQgLSBhLnN0YXJ0KSAqIGEuZWFzaW5nKGEucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLnNldChyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiAmJiByZXF1ZXN0QW5pbUZyYW1lKGZyYW1lKTtcbiAgICB9LFxuICAgIC8vIFNJRVJSQSBVbmZhbWlsaWFyIHdpdGggdGhlIHdvcmQgX3NsYXZlXyBpbiB0aGlzIGNvbnRleHQuIEFsc28sIEkgZG9uJ3Qga25vdyB3aGF0IF9nZXJlYWxfIG1lYW5zLiBEbyB5b3UgbWVhbiBfZ2VuZXJhbF8/XG4gICAgLypcXFxuICAgICAqIG1pbmFcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEdlbmVyaWMgYW5pbWF0aW9uIG9mIG51bWJlcnNcbiAgICAgKipcbiAgICAgLSBhIChudW1iZXIpIHN0YXJ0IF9zbGF2ZV8gbnVtYmVyXG4gICAgIC0gQSAobnVtYmVyKSBlbmQgX3NsYXZlXyBudW1iZXJcbiAgICAgLSBiIChudW1iZXIpIHN0YXJ0IF9tYXN0ZXJfIG51bWJlciAoc3RhcnQgdGltZSBpbiBnZW5lcmFsIGNhc2UpXG4gICAgIC0gQiAobnVtYmVyKSBlbmQgX21hc3Rlcl8gbnVtYmVyIChlbmQgdGltZSBpbiBnZXJlYWwgY2FzZSlcbiAgICAgLSBnZXQgKGZ1bmN0aW9uKSBnZXR0ZXIgb2YgX21hc3Rlcl8gbnVtYmVyIChzZWUgQG1pbmEudGltZSlcbiAgICAgLSBzZXQgKGZ1bmN0aW9uKSBzZXR0ZXIgb2YgX3NsYXZlXyBudW1iZXJcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uLCBkZWZhdWx0IGlzIEBtaW5hLmxpbmVhclxuICAgICA9IChvYmplY3QpIGFuaW1hdGlvbiBkZXNjcmlwdG9yXG4gICAgIG8ge1xuICAgICBvICAgICAgICAgaWQgKHN0cmluZykgYW5pbWF0aW9uIGlkLFxuICAgICBvICAgICAgICAgc3RhcnQgKG51bWJlcikgc3RhcnQgX3NsYXZlXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBlbmQgKG51bWJlcikgZW5kIF9zbGF2ZV8gbnVtYmVyLFxuICAgICBvICAgICAgICAgYiAobnVtYmVyKSBzdGFydCBfbWFzdGVyXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBzIChudW1iZXIpIGFuaW1hdGlvbiBzdGF0dXMgKDAuLjEpLFxuICAgICBvICAgICAgICAgZHVyIChudW1iZXIpIGFuaW1hdGlvbiBkdXJhdGlvbixcbiAgICAgbyAgICAgICAgIHNwZCAobnVtYmVyKSBhbmltYXRpb24gc3BlZWQsXG4gICAgIG8gICAgICAgICBnZXQgKGZ1bmN0aW9uKSBnZXR0ZXIgb2YgX21hc3Rlcl8gbnVtYmVyIChzZWUgQG1pbmEudGltZSksXG4gICAgIG8gICAgICAgICBzZXQgKGZ1bmN0aW9uKSBzZXR0ZXIgb2YgX3NsYXZlXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBlYXNpbmcgKGZ1bmN0aW9uKSBlYXNpbmcgZnVuY3Rpb24sIGRlZmF1bHQgaXMgQG1pbmEubGluZWFyLFxuICAgICBvICAgICAgICAgc3RhdHVzIChmdW5jdGlvbikgc3RhdHVzIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBzcGVlZCAoZnVuY3Rpb24pIHNwZWVkIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBkdXJhdGlvbiAoZnVuY3Rpb24pIGR1cmF0aW9uIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBzdG9wIChmdW5jdGlvbikgYW5pbWF0aW9uIHN0b3BwZXJcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIG1pbmEgPSBmdW5jdGlvbiAoYSwgQSwgYiwgQiwgZ2V0LCBzZXQsIGVhc2luZykge1xuICAgICAgICB2YXIgYW5pbSA9IHtcbiAgICAgICAgICAgIGlkOiBJRCgpLFxuICAgICAgICAgICAgc3RhcnQ6IGEsXG4gICAgICAgICAgICBlbmQ6IEEsXG4gICAgICAgICAgICBiOiBiLFxuICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgIGR1cjogQiAtIGIsXG4gICAgICAgICAgICBzcGQ6IDEsXG4gICAgICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgICAgIHNldDogc2V0LFxuICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmcgfHwgbWluYS5saW5lYXIsXG4gICAgICAgICAgICBzdGF0dXM6IHN0YSxcbiAgICAgICAgICAgIHNwZWVkOiBzcGVlZCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgIHN0b3A6IHN0b3BpdCxcbiAgICAgICAgICAgIHBhdXNlOiBwYXVzZSxcbiAgICAgICAgICAgIHJlc3VtZTogcmVzdW1lXG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGlvbnNbYW5pbS5pZF0gPSBhbmltO1xuICAgICAgICB2YXIgbGVuID0gMCwgaTtcbiAgICAgICAgZm9yIChpIGluIGFuaW1hdGlvbnMpIGlmIChhbmltYXRpb25zLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIGlmIChsZW4gPT0gMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlbiA9PSAxICYmIHJlcXVlc3RBbmltRnJhbWUoZnJhbWUpO1xuICAgICAgICByZXR1cm4gYW5pbTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLnRpbWVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZS4gRXF1aXZhbGVudCB0bzpcbiAgICAgfCBmdW5jdGlvbiAoKSB7XG4gICAgIHwgICAgIHJldHVybiAobmV3IERhdGUpLmdldFRpbWUoKTtcbiAgICAgfCB9XG4gICAgXFwqL1xuICAgIG1pbmEudGltZSA9IHRpbWVyO1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmdldEJ5SWRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gYW5pbWF0aW9uIGJ5IGl0cyBpZFxuICAgICAtIGlkIChzdHJpbmcpIGFuaW1hdGlvbidzIGlkXG4gICAgID0gKG9iamVjdCkgU2VlIEBtaW5hXG4gICAgXFwqL1xuICAgIG1pbmEuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uc1tpZF0gfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIG1pbmEubGluZWFyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEZWZhdWx0IGxpbmVhciBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmxpbmVhciA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuZWFzZW91dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRWFzZW91dCBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmVhc2VvdXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3cobiwgMS43KTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmVhc2VpblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRWFzZWluIGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuZWFzZWluID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KG4sIC40OCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5lYXNlaW5vdXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEVhc2Vpbm91dCBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmVhc2Vpbm91dCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmIChuID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxID0gLjQ4IC0gbiAvIDEuMDQsXG4gICAgICAgICAgICBRID0gTWF0aC5zcXJ0KC4xNzM0ICsgcSAqIHEpLFxuICAgICAgICAgICAgeCA9IFEgLSBxLFxuICAgICAgICAgICAgWCA9IE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMykgKiAoeCA8IDAgPyAtMSA6IDEpLFxuICAgICAgICAgICAgeSA9IC1RIC0gcSxcbiAgICAgICAgICAgIFkgPSBNYXRoLnBvdyhNYXRoLmFicyh5KSwgMSAvIDMpICogKHkgPCAwID8gLTEgOiAxKSxcbiAgICAgICAgICAgIHQgPSBYICsgWSArIC41O1xuICAgICAgICByZXR1cm4gKDEgLSB0KSAqIDMgKiB0ICogdCArIHQgKiB0ICogdDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmJhY2tpblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQmFja2luIGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuYmFja2luID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICByZXR1cm4gbiAqIG4gKiAoKHMgKyAxKSAqIG4gLSBzKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmJhY2tvdXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJhY2tvdXQgZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5iYWNrb3V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4gLSAxO1xuICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiBuICogbiAqICgocyArIDEpICogbiArIHMpICsgMTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmVsYXN0aWNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEVsYXN0aWMgZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5lbGFzdGljID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPT0gISFuKSB7XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwICogbikgKiBNYXRoLnNpbigobiAtIC4wNzUpICpcbiAgICAgICAgICAgICgyICogTWF0aC5QSSkgLyAuMykgKyAxO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuYm91bmNlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCb3VuY2UgZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5ib3VuY2UgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgcyA9IDcuNTYyNSxcbiAgICAgICAgICAgIHAgPSAyLjc1LFxuICAgICAgICAgICAgbDtcbiAgICAgICAgaWYgKG4gPCAoMSAvIHApKSB7XG4gICAgICAgICAgICBsID0gcyAqIG4gKiBuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG4gPCAoMiAvIHApKSB7XG4gICAgICAgICAgICAgICAgbiAtPSAoMS41IC8gcCk7XG4gICAgICAgICAgICAgICAgbCA9IHMgKiBuICogbiArIC43NTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gPCAoMi41IC8gcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbiAtPSAoMi4yNSAvIHApO1xuICAgICAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjkzNzU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbiAtPSAoMi42MjUgLyBwKTtcbiAgICAgICAgICAgICAgICAgICAgbCA9IHMgKiBuICogbiArIC45ODQzNzU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsO1xuICAgIH07XG4gICAgd2luZG93Lm1pbmEgPSBtaW5hO1xuICAgIHJldHVybiBtaW5hO1xufSkodHlwZW9mIGV2ZSA9PSBcInVuZGVmaW5lZFwiID8gZnVuY3Rpb24gKCkge30gOiBldmUpO1xuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG52YXIgU25hcCA9IChmdW5jdGlvbihyb290KSB7XG5TbmFwLnZlcnNpb24gPSBcIjAuMi4wXCI7XG4vKlxcXG4gKiBTbmFwXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDcmVhdGVzIGEgZHJhd2luZyBzdXJmYWNlIG9yIHdyYXBzIGV4aXN0aW5nIFNWRyBlbGVtZW50LlxuICoqXG4gLSB3aWR0aCAobnVtYmVyfHN0cmluZykgd2lkdGggb2Ygc3VyZmFjZVxuIC0gaGVpZ2h0IChudW1iZXJ8c3RyaW5nKSBoZWlnaHQgb2Ygc3VyZmFjZVxuICogb3JcbiAtIERPTSAoU1ZHRWxlbWVudCkgZWxlbWVudCB0byBiZSB3cmFwcGVkIGludG8gU25hcCBzdHJ1Y3R1cmVcbiAqIG9yXG4gLSBxdWVyeSAoc3RyaW5nKSBDU1MgcXVlcnkgc2VsZWN0b3JcbiA9IChvYmplY3QpIEBFbGVtZW50XG5cXCovXG5mdW5jdGlvbiBTbmFwKHcsIGgpIHtcbiAgICBpZiAodykge1xuICAgICAgICBpZiAody50YWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcCh3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoID09IG51bGwpIHtcbiAgICAgICAgICAgIHcgPSBnbG9iLmRvYy5xdWVyeVNlbGVjdG9yKHcpO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAodyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdyA9IHcgPT0gbnVsbCA/IFwiMTAwJVwiIDogdztcbiAgICBoID0gaCA9PSBudWxsID8gXCIxMDAlXCIgOiBoO1xuICAgIHJldHVybiBuZXcgUGFwZXIodywgaCk7XG59XG5TbmFwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIlNuYXAgdlwiICsgdGhpcy52ZXJzaW9uO1xufTtcblNuYXAuXyA9IHt9O1xudmFyIGdsb2IgPSB7XG4gICAgd2luOiByb290LndpbmRvdyxcbiAgICBkb2M6IHJvb3Qud2luZG93LmRvY3VtZW50XG59O1xuU25hcC5fLmdsb2IgPSBnbG9iO1xudmFyIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICBTdHIgPSBTdHJpbmcsXG4gICAgdG9GbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgdG9JbnQgPSBwYXJzZUludCxcbiAgICBtYXRoID0gTWF0aCxcbiAgICBtbWF4ID0gbWF0aC5tYXgsXG4gICAgbW1pbiA9IG1hdGgubWluLFxuICAgIGFicyA9IG1hdGguYWJzLFxuICAgIHBvdyA9IG1hdGgucG93LFxuICAgIFBJID0gbWF0aC5QSSxcbiAgICByb3VuZCA9IG1hdGgucm91bmQsXG4gICAgRSA9IFwiXCIsXG4gICAgUyA9IFwiIFwiLFxuICAgIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICBJU1VSTCA9IC9edXJsXFwoWydcIl0/KFteXFwpXSs/KVsnXCJdP1xcKSQvaSxcbiAgICBjb2xvdXJSZWdFeHAgPSAvXlxccyooKCNbYS1mXFxkXXs2fSl8KCNbYS1mXFxkXXszfSl8cmdiYT9cXChcXHMqKFtcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSslPyg/OlxccyosXFxzKltcXGRcXC5dKyU/KT8pXFxzKlxcKXxoc2JhP1xcKFxccyooW1xcZFxcLl0rKD86ZGVnfFxceGIwfCUpP1xccyosXFxzKltcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rKD86JT9cXHMqLFxccypbXFxkXFwuXSspPyU/KVxccypcXCl8aHNsYT9cXChcXHMqKFtcXGRcXC5dKyg/OmRlZ3xcXHhiMHwlKT9cXHMqLFxccypbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyg/OiU/XFxzKixcXHMqW1xcZFxcLl0rKT8lPylcXHMqXFwpKVxccyokL2ksXG4gICAgYmV6aWVycmcgPSAvXig/OmN1YmljLSk/YmV6aWVyXFwoKFteLF0rKSwoW14sXSspLChbXixdKyksKFteXFwpXSspXFwpLyxcbiAgICByZVVSTFZhbHVlID0gL151cmxcXCgjPyhbXildKylcXCkkLyxcbiAgICBzcGFjZXMgPSBcIlxceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XCIsXG4gICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChcIlssXCIgKyBzcGFjZXMgKyBcIl0rXCIpLFxuICAgIHdoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKFwiW1wiICsgc3BhY2VzICsgXCJdXCIsIFwiZ1wiKSxcbiAgICBjb21tYVNwYWNlcyA9IG5ldyBSZWdFeHAoXCJbXCIgKyBzcGFjZXMgKyBcIl0qLFtcIiArIHNwYWNlcyArIFwiXSpcIiksXG4gICAgaHNyZyA9IHtoczogMSwgcmc6IDF9LFxuICAgIHBhdGhDb21tYW5kID0gbmV3IFJlZ0V4cChcIihbYS16XSlbXCIgKyBzcGFjZXMgKyBcIixdKigoLT9cXFxcZCpcXFxcLj9cXFxcZCooPzplW1xcXFwtK10/XFxcXGQrKT9bXCIgKyBzcGFjZXMgKyBcIl0qLD9bXCIgKyBzcGFjZXMgKyBcIl0qKSspXCIsIFwiaWdcIiksXG4gICAgdENvbW1hbmQgPSBuZXcgUmVnRXhwKFwiKFtyc3RtXSlbXCIgKyBzcGFjZXMgKyBcIixdKigoLT9cXFxcZCpcXFxcLj9cXFxcZCooPzplW1xcXFwtK10/XFxcXGQrKT9bXCIgKyBzcGFjZXMgKyBcIl0qLD9bXCIgKyBzcGFjZXMgKyBcIl0qKSspXCIsIFwiaWdcIiksXG4gICAgcGF0aFZhbHVlcyA9IG5ldyBSZWdFeHAoXCIoLT9cXFxcZCpcXFxcLj9cXFxcZCooPzplW1xcXFwtK10/XFxcXGQrKT8pW1wiICsgc3BhY2VzICsgXCJdKiw/W1wiICsgc3BhY2VzICsgXCJdKlwiLCBcImlnXCIpLFxuICAgIGlkZ2VuID0gMCxcbiAgICBpZHByZWZpeCA9IFwiU1wiICsgKCtuZXcgRGF0ZSkudG9TdHJpbmcoMzYpLFxuICAgIElEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWRwcmVmaXggKyAoaWRnZW4rKykudG9TdHJpbmcoMzYpO1xuICAgIH0sXG4gICAgeGxpbmsgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICB4bWxucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBodWIgPSB7fSxcbiAgICBVUkwgPSBTbmFwLnVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIFwidXJsKCcjXCIgKyB1cmwgKyBcIicpXCI7XG4gICAgfTtcblxuZnVuY3Rpb24gJChlbCwgYXR0cikge1xuICAgIGlmIChhdHRyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWwgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZWwgPSAkKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGF0dHIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGF0dHIuc3Vic3RyaW5nKDAsIDYpID09IFwieGxpbms6XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlTlMoeGxpbmssIGF0dHIuc3Vic3RyaW5nKDYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyLnN1YnN0cmluZygwLCA0KSA9PSBcInhtbDpcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGVOUyh4bWxucywgYXR0ci5zdWJzdHJpbmcoNCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cikgaWYgKGF0dHJbaGFzXShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gU3RyKGF0dHJba2V5XSk7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgNikgPT0gXCJ4bGluazpcIikge1xuICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGluaywga2V5LnN1YnN0cmluZyg2KSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleS5zdWJzdHJpbmcoMCwgNCkgPT0gXCJ4bWw6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeG1sbnMsIGtleS5zdWJzdHJpbmcoNCksIHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSBnbG9iLmRvYy5jcmVhdGVFbGVtZW50TlMoeG1sbnMsIGVsKTtcbiAgICAgICAgLy8gZWwuc3R5bGUgJiYgKGVsLnN0eWxlLndlYmtpdFRhcEhpZ2hsaWdodENvbG9yID0gXCJyZ2JhKDAsMCwwLDApXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG59XG5TbmFwLl8uJCA9ICQ7XG5TbmFwLl8uaWQgPSBJRDtcbmZ1bmN0aW9uIGdldEF0dHJzKGVsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cmlidXRlcyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb3V0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXR0cnNbaV0ubmFtZXNwYWNlVVJJID09IHhsaW5rKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJ4bGluazpcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgKz0gYXR0cnNbaV0ubmFtZTtcbiAgICAgICAgb3V0W25hbWVdID0gYXR0cnNbaV0udGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpcyhvLCB0eXBlKSB7XG4gICAgdHlwZSA9IFN0ci5wcm90b3R5cGUudG9Mb3dlckNhc2UuY2FsbCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PSBcImZpbml0ZVwiKSB7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShvKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJhcnJheVwiICYmXG4gICAgICAgIChvIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KG8pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICAodHlwZSA9PSBcIm51bGxcIiAmJiBvID09PSBudWxsKSB8fFxuICAgICAgICAgICAgKHR5cGUgPT0gdHlwZW9mIG8gJiYgbyAhPT0gbnVsbCkgfHxcbiAgICAgICAgICAgICh0eXBlID09IFwib2JqZWN0XCIgJiYgbyA9PT0gT2JqZWN0KG8pKSB8fFxuICAgICAgICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSA9PSB0eXBlO1xufVxuLypcXFxuICogU25hcC5mb3JtYXRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJlcGxhY2VzIGNvbnN0cnVjdGlvbiBvZiB0eXBlIGB7PG5hbWU+fWAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXJndW1lbnRcbiAqKlxuIC0gdG9rZW4gKHN0cmluZykgc3RyaW5nIHRvIGZvcm1hdFxuIC0ganNvbiAob2JqZWN0KSBvYmplY3Qgd2hpY2ggcHJvcGVydGllcyBhcmUgdXNlZCBhcyBhIHJlcGxhY2VtZW50XG4gPSAoc3RyaW5nKSBmb3JtYXR0ZWQgc3RyaW5nXG4gPiBVc2FnZVxuIHwgLy8gdGhpcyBkcmF3cyBhIHJlY3Rhbmd1bGFyIHNoYXBlIGVxdWl2YWxlbnQgdG8gXCJNMTAsMjBoNDB2NTBoLTQwelwiXG4gfCBwYXBlci5wYXRoKFNuYXAuZm9ybWF0KFwiTXt4fSx7eX1oe2RpbS53aWR0aH12e2RpbS5oZWlnaHR9aHtkaW1bJ25lZ2F0aXZlIHdpZHRoJ119elwiLCB7XG4gfCAgICAgeDogMTAsXG4gfCAgICAgeTogMjAsXG4gfCAgICAgZGltOiB7XG4gfCAgICAgICAgIHdpZHRoOiA0MCxcbiB8ICAgICAgICAgaGVpZ2h0OiA1MCxcbiB8ICAgICAgICAgXCJuZWdhdGl2ZSB3aWR0aFwiOiAtNDBcbiB8ICAgICB9XG4gfCB9KSk7XG5cXCovXG5TbmFwLmZvcm1hdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRva2VuUmVnZXggPSAvXFx7KFteXFx9XSspXFx9L2csXG4gICAgICAgIG9iak5vdGF0aW9uUmVnZXggPSAvKD86KD86XnxcXC4pKC4rPykoPz1cXFt8XFwufCR8XFwoKXxcXFsoJ3xcIikoLis/KVxcMlxcXSkoXFwoXFwpKT8vZywgLy8gbWF0Y2hlcyAueHh4eHggb3IgW1wieHh4eHhcIl0gdG8gcnVuIG92ZXIgb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgcmVwbGFjZXIgPSBmdW5jdGlvbiAoYWxsLCBrZXksIG9iaikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG9iajtcbiAgICAgICAgICAgIGtleS5yZXBsYWNlKG9iak5vdGF0aW9uUmVnZXgsIGZ1bmN0aW9uIChhbGwsIG5hbWUsIHF1b3RlLCBxdW90ZWROYW1lLCBpc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBxdW90ZWROYW1lO1xuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcyA9PSBcImZ1bmN0aW9uXCIgJiYgaXNGdW5jICYmIChyZXMgPSByZXMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXMgPSAocmVzID09IG51bGwgfHwgcmVzID09IG9iaiA/IGFsbCA6IHJlcykgKyBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgb2JqKSB7XG4gICAgICAgIHJldHVybiBTdHIoc3RyKS5yZXBsYWNlKHRva2VuUmVnZXgsIGZ1bmN0aW9uIChhbGwsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKGFsbCwga2V5LCBvYmopO1xuICAgICAgICB9KTtcbiAgICB9O1xufSkoKTtcbnZhciBwcmVsb2FkID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBvbmVycm9yKCkge1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc3JjLCBmKSB7XG4gICAgICAgIHZhciBpbWcgPSBnbG9iLmRvYy5jcmVhdGVFbGVtZW50KFwiaW1nXCIpLFxuICAgICAgICAgICAgYm9keSA9IGdsb2IuZG9jLmJvZHk7XG4gICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5ZW07dG9wOi05OTk5ZW1cIjtcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGYuY2FsbChpbWcpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoaW1nKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgfTtcbn0oKSk7XG5mdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PSBcImZ1bmN0aW9uXCIgfHwgT2JqZWN0KG9iaikgIT09IG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgcmVzID0gbmV3IG9iai5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAob2JqW2hhc10oa2V5KSkge1xuICAgICAgICByZXNba2V5XSA9IGNsb25lKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblNuYXAuXy5jbG9uZSA9IGNsb25lO1xuZnVuY3Rpb24gcmVwdXNoKGFycmF5LCBpdGVtKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSB7XG4gICAgICAgIHJldHVybiBhcnJheS5wdXNoKGFycmF5LnNwbGljZShpLCAxKVswXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FjaGVyKGYsIHNjb3BlLCBwb3N0cHJvY2Vzc29yKSB7XG4gICAgZnVuY3Rpb24gbmV3ZigpIHtcbiAgICAgICAgdmFyIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgICAgICBhcmdzID0gYXJnLmpvaW4oXCJcXHUyNDAwXCIpLFxuICAgICAgICAgICAgY2FjaGUgPSBuZXdmLmNhY2hlID0gbmV3Zi5jYWNoZSB8fCB7fSxcbiAgICAgICAgICAgIGNvdW50ID0gbmV3Zi5jb3VudCA9IG5ld2YuY291bnQgfHwgW107XG4gICAgICAgIGlmIChjYWNoZVtoYXNdKGFyZ3MpKSB7XG4gICAgICAgICAgICByZXB1c2goY291bnQsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3Rwcm9jZXNzb3IgPyBwb3N0cHJvY2Vzc29yKGNhY2hlW2FyZ3NdKSA6IGNhY2hlW2FyZ3NdO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50Lmxlbmd0aCA+PSAxZTMgJiYgZGVsZXRlIGNhY2hlW2NvdW50LnNoaWZ0KCldO1xuICAgICAgICBjb3VudC5wdXNoKGFyZ3MpO1xuICAgICAgICBjYWNoZVthcmdzXSA9IGYuYXBwbHkoc2NvcGUsIGFyZyk7XG4gICAgICAgIHJldHVybiBwb3N0cHJvY2Vzc29yID8gcG9zdHByb2Nlc3NvcihjYWNoZVthcmdzXSkgOiBjYWNoZVthcmdzXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld2Y7XG59XG5TbmFwLl8uY2FjaGVyID0gY2FjaGVyO1xuZnVuY3Rpb24gYW5nbGUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIGlmICh4MyA9PSBudWxsKSB7XG4gICAgICAgIHZhciB4ID0geDEgLSB4MixcbiAgICAgICAgICAgIHkgPSB5MSAtIHkyO1xuICAgICAgICBpZiAoIXggJiYgIXkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMTgwICsgbWF0aC5hdGFuMigteSwgLXgpICogMTgwIC8gUEkgKyAzNjApICUgMzYwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhbmdsZSh4MSwgeTEsIHgzLCB5MykgLSBhbmdsZSh4MiwgeTIsIHgzLCB5Myk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmFkKGRlZykge1xuICAgIHJldHVybiBkZWcgJSAzNjAgKiBQSSAvIDE4MDtcbn1cbmZ1bmN0aW9uIGRlZyhyYWQpIHtcbiAgICByZXR1cm4gcmFkICogMTgwIC8gUEkgJSAzNjA7XG59XG5mdW5jdGlvbiB4X3koKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIFMgKyB0aGlzLnk7XG59XG5mdW5jdGlvbiB4X3lfd19oKCkge1xuICAgIHJldHVybiB0aGlzLnggKyBTICsgdGhpcy55ICsgUyArIHRoaXMud2lkdGggKyBcIiBcXHhkNyBcIiArIHRoaXMuaGVpZ2h0O1xufVxuXG4vKlxcXG4gKiBTbmFwLnJhZFxuIFsgbWV0aG9kIF1cbiAqKlxuICogVHJhbnNmb3JtIGFuZ2xlIHRvIHJhZGlhbnNcbiAtIGRlZyAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzXG4gPSAobnVtYmVyKSBhbmdsZSBpbiByYWRpYW5zXG5cXCovXG5TbmFwLnJhZCA9IHJhZDtcbi8qXFxcbiAqIFNuYXAuZGVnXG4gWyBtZXRob2QgXVxuICoqXG4gKiBUcmFuc2Zvcm0gYW5nbGUgdG8gZGVncmVlc1xuIC0gcmFkIChudW1iZXIpIGFuZ2xlIGluIHJhZGlhbnNcbiA9IChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuZGVnID0gZGVnO1xuLy8gU0lFUlJBIGZvciB3aGljaCBwb2ludCBpcyB0aGUgYW5nbGUgY2FsY3VsYXRlZD9cbi8qXFxcbiAqIFNuYXAuYW5nbGVcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgYW4gYW5nbGUgYmV0d2VlbiB0d28gb3IgdGhyZWUgcG9pbnRzXG4gPiBQYXJhbWV0ZXJzXG4gLSB4MSAobnVtYmVyKSB4IGNvb3JkIG9mIGZpcnN0IHBvaW50XG4gLSB5MSAobnVtYmVyKSB5IGNvb3JkIG9mIGZpcnN0IHBvaW50XG4gLSB4MiAobnVtYmVyKSB4IGNvb3JkIG9mIHNlY29uZCBwb2ludFxuIC0geTIgKG51bWJlcikgeSBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHgzIChudW1iZXIpICNvcHRpb25hbCB4IGNvb3JkIG9mIHRoaXJkIHBvaW50XG4gLSB5MyAobnVtYmVyKSAjb3B0aW9uYWwgeSBjb29yZCBvZiB0aGlyZCBwb2ludFxuID0gKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuXFwqL1xuU25hcC5hbmdsZSA9IGFuZ2xlO1xuLypcXFxuICogU25hcC5pc1xuIFsgbWV0aG9kIF1cbiAqKlxuICogSGFuZHkgcmVwbGFjZW1lbnQgZm9yIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuIC0gbyAo4oCmKSBhbnkgb2JqZWN0IG9yIHByaW1pdGl2ZVxuIC0gdHlwZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSB0eXBlLCBlLmcuLCBgc3RyaW5nYCwgYGZ1bmN0aW9uYCwgYG51bWJlcmAsIGV0Yy5cbiA9IChib29sZWFuKSBgdHJ1ZWAgaWYgZ2l2ZW4gdmFsdWUgaXMgb2YgZ2l2ZW4gdHlwZVxuXFwqL1xuU25hcC5pcyA9IGlzO1xuLypcXFxuICogU25hcC5zbmFwVG9cbiBbIG1ldGhvZCBdXG4gKipcbiAqIFNuYXBzIGdpdmVuIHZhbHVlIHRvIGdpdmVuIGdyaWRcbiAtIHZhbHVlcyAoYXJyYXl8bnVtYmVyKSBnaXZlbiBhcnJheSBvZiB2YWx1ZXMgb3Igc3RlcCBvZiB0aGUgZ3JpZFxuIC0gdmFsdWUgKG51bWJlcikgdmFsdWUgdG8gYWRqdXN0XG4gLSB0b2xlcmFuY2UgKG51bWJlcikgI29wdGlvbmFsIG1heGltdW0gZGlzdGFuY2UgdG8gdGhlIHRhcmdldCB2YWx1ZSB0aGF0IHdvdWxkIHRyaWdnZXIgdGhlIHNuYXAuIERlZmF1bHQgaXMgYDEwYC5cbiA9IChudW1iZXIpIGFkanVzdGVkIHZhbHVlXG5cXCovXG5TbmFwLnNuYXBUbyA9IGZ1bmN0aW9uICh2YWx1ZXMsIHZhbHVlLCB0b2xlcmFuY2UpIHtcbiAgICB0b2xlcmFuY2UgPSBpcyh0b2xlcmFuY2UsIFwiZmluaXRlXCIpID8gdG9sZXJhbmNlIDogMTA7XG4gICAgaWYgKGlzKHZhbHVlcywgXCJhcnJheVwiKSkge1xuICAgICAgICB2YXIgaSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIGlmIChhYnModmFsdWVzW2ldIC0gdmFsdWUpIDw9IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcyA9ICt2YWx1ZXM7XG4gICAgICAgIHZhciByZW0gPSB2YWx1ZSAlIHZhbHVlcztcbiAgICAgICAgaWYgKHJlbSA8IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gcmVtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW0gPiB2YWx1ZXMgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAtIHJlbSArIHZhbHVlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBNQVRSSVhcbmZ1bmN0aW9uIE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaWYgKGIgPT0gbnVsbCAmJiBvYmplY3RUb1N0cmluZy5jYWxsKGEpID09IFwiW29iamVjdCBTVkdNYXRyaXhdXCIpIHtcbiAgICAgICAgdGhpcy5hID0gYS5hO1xuICAgICAgICB0aGlzLmIgPSBhLmI7XG4gICAgICAgIHRoaXMuYyA9IGEuYztcbiAgICAgICAgdGhpcy5kID0gYS5kO1xuICAgICAgICB0aGlzLmUgPSBhLmU7XG4gICAgICAgIHRoaXMuZiA9IGEuZjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYSA9ICthO1xuICAgICAgICB0aGlzLmIgPSArYjtcbiAgICAgICAgdGhpcy5jID0gK2M7XG4gICAgICAgIHRoaXMuZCA9ICtkO1xuICAgICAgICB0aGlzLmUgPSArZTtcbiAgICAgICAgdGhpcy5mID0gK2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hID0gMTtcbiAgICAgICAgdGhpcy5iID0gMDtcbiAgICAgICAgdGhpcy5jID0gMDtcbiAgICAgICAgdGhpcy5kID0gMTtcbiAgICAgICAgdGhpcy5lID0gMDtcbiAgICAgICAgdGhpcy5mID0gMDtcbiAgICB9XG59XG4oZnVuY3Rpb24gKG1hdHJpeHByb3RvKSB7XG4gICAgLypcXFxuICAgICAqIE1hdHJpeC5hZGRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIG1hdHJpeCB0byBleGlzdGluZyBvbmVcbiAgICAgLSBhIChudW1iZXIpXG4gICAgIC0gYiAobnVtYmVyKVxuICAgICAtIGMgKG51bWJlcilcbiAgICAgLSBkIChudW1iZXIpXG4gICAgIC0gZSAobnVtYmVyKVxuICAgICAtIGYgKG51bWJlcilcbiAgICAgKiBvclxuICAgICAtIG1hdHJpeCAob2JqZWN0KSBATWF0cml4XG4gICAgXFwqL1xuICAgIG1hdHJpeHByb3RvLmFkZCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgIHZhciBvdXQgPSBbW10sIFtdLCBbXV0sXG4gICAgICAgICAgICBtID0gW1t0aGlzLmEsIHRoaXMuYywgdGhpcy5lXSwgW3RoaXMuYiwgdGhpcy5kLCB0aGlzLmZdLCBbMCwgMCwgMV1dLFxuICAgICAgICAgICAgbWF0cml4ID0gW1thLCBjLCBlXSwgW2IsIGQsIGZdLCBbMCwgMCwgMV1dLFxuICAgICAgICAgICAgeCwgeSwgeiwgcmVzO1xuXG4gICAgICAgIGlmIChhICYmIGEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIG1hdHJpeCA9IFtbYS5hLCBhLmMsIGEuZV0sIFthLmIsIGEuZCwgYS5mXSwgWzAsIDAsIDFdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoeCA9IDA7IHggPCAzOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCAzOyB5KyspIHtcbiAgICAgICAgICAgICAgICByZXMgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoeiA9IDA7IHogPCAzOyB6KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IG1beF1bel0gKiBtYXRyaXhbel1beV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dFt4XVt5XSA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmEgPSBvdXRbMF1bMF07XG4gICAgICAgIHRoaXMuYiA9IG91dFsxXVswXTtcbiAgICAgICAgdGhpcy5jID0gb3V0WzBdWzFdO1xuICAgICAgICB0aGlzLmQgPSBvdXRbMV1bMV07XG4gICAgICAgIHRoaXMuZSA9IG91dFswXVsyXTtcbiAgICAgICAgdGhpcy5mID0gb3V0WzFdWzJdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBNYXRyaXguaW52ZXJ0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhlIG1hdHJpeFxuICAgICA9IChvYmplY3QpIEBNYXRyaXhcbiAgICBcXCovXG4gICAgbWF0cml4cHJvdG8uaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgeCA9IG1lLmEgKiBtZS5kIC0gbWUuYiAqIG1lLmM7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KG1lLmQgLyB4LCAtbWUuYiAvIHgsIC1tZS5jIC8geCwgbWUuYSAvIHgsIChtZS5jICogbWUuZiAtIG1lLmQgKiBtZS5lKSAvIHgsIChtZS5iICogbWUuZSAtIG1lLmEgKiBtZS5mKSAvIHgpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIE1hdHJpeC5jbG9uZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hdHJpeFxuICAgICA9IChvYmplY3QpIEBNYXRyaXhcbiAgICBcXCovXG4gICAgbWF0cml4cHJvdG8uY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmYpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIE1hdHJpeC50cmFuc2xhdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFRyYW5zbGF0ZSB0aGUgbWF0cml4XG4gICAgIC0geCAobnVtYmVyKSBob3Jpem9udGFsIG9mZnNldCBkaXN0YW5jZVxuICAgICAtIHkgKG51bWJlcikgdmVydGljYWwgb2Zmc2V0IGRpc3RhbmNlXG4gICAgXFwqL1xuICAgIG1hdHJpeHByb3RvLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZCgxLCAwLCAwLCAxLCB4LCB5KTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBNYXRyaXguc2NhbGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNjYWxlcyB0aGUgbWF0cml4XG4gICAgIC0geCAobnVtYmVyKSBhbW91bnQgdG8gYmUgc2NhbGVkLCB3aXRoIGAxYCByZXN1bHRpbmcgaW4gbm8gY2hhbmdlXG4gICAgIC0geSAobnVtYmVyKSAjb3B0aW9uYWwgYW1vdW50IHRvIHNjYWxlIGFsb25nIHRoZSB2ZXJ0aWNhbCBheGlzLiAoT3RoZXJ3aXNlIGB4YCBhcHBsaWVzIHRvIGJvdGggYXhlcy4pXG4gICAgIC0gY3ggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gc2NhbGVcbiAgICAgLSBjeSAobnVtYmVyKSAjb3B0aW9uYWwgdmVydGljYWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gc2NhbGVcbiAgICAgKiBEZWZhdWx0IGN4LCBjeSBpcyB0aGUgbWlkZGxlIHBvaW50IG9mIHRoZSBlbGVtZW50LlxuICAgIFxcKi9cbiAgICBtYXRyaXhwcm90by5zY2FsZSA9IGZ1bmN0aW9uICh4LCB5LCBjeCwgY3kpIHtcbiAgICAgICAgeSA9PSBudWxsICYmICh5ID0geCk7XG4gICAgICAgIChjeCB8fCBjeSkgJiYgdGhpcy5hZGQoMSwgMCwgMCwgMSwgY3gsIGN5KTtcbiAgICAgICAgdGhpcy5hZGQoeCwgMCwgMCwgeSwgMCwgMCk7XG4gICAgICAgIChjeCB8fCBjeSkgJiYgdGhpcy5hZGQoMSwgMCwgMCwgMSwgLWN4LCAtY3kpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBNYXRyaXgucm90YXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSb3RhdGVzIHRoZSBtYXRyaXhcbiAgICAgLSBhIChudW1iZXIpIGFuZ2xlIG9mIHJvdGF0aW9uLCBpbiBkZWdyZWVzXG4gICAgIC0geCAobnVtYmVyKSBob3Jpem9udGFsIG9yaWdpbiBwb2ludCBmcm9tIHdoaWNoIHRvIHJvdGF0ZVxuICAgICAtIHkgKG51bWJlcikgdmVydGljYWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gcm90YXRlXG4gICAgXFwqL1xuICAgIG1hdHJpeHByb3RvLnJvdGF0ZSA9IGZ1bmN0aW9uIChhLCB4LCB5KSB7XG4gICAgICAgIGEgPSByYWQoYSk7XG4gICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgIHkgPSB5IHx8IDA7XG4gICAgICAgIHZhciBjb3MgPSArbWF0aC5jb3MoYSkudG9GaXhlZCg5KSxcbiAgICAgICAgICAgIHNpbiA9ICttYXRoLnNpbihhKS50b0ZpeGVkKDkpO1xuICAgICAgICB0aGlzLmFkZChjb3MsIHNpbiwgLXNpbiwgY29zLCB4LCB5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKDEsIDAsIDAsIDEsIC14LCAteSk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogTWF0cml4LnhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgeCBjb29yZGluYXRlIGZvciBnaXZlbiBwb2ludCBhZnRlciB0cmFuc2Zvcm1hdGlvbiBkZXNjcmliZWQgYnkgdGhlIG1hdHJpeC4gU2VlIGFsc28gQE1hdHJpeC55XG4gICAgIC0geCAobnVtYmVyKVxuICAgICAtIHkgKG51bWJlcilcbiAgICAgPSAobnVtYmVyKSB4XG4gICAgXFwqL1xuICAgIG1hdHJpeHByb3RvLnggPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4geCAqIHRoaXMuYSArIHkgKiB0aGlzLmMgKyB0aGlzLmU7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogTWF0cml4LnlcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgeSBjb29yZGluYXRlIGZvciBnaXZlbiBwb2ludCBhZnRlciB0cmFuc2Zvcm1hdGlvbiBkZXNjcmliZWQgYnkgdGhlIG1hdHJpeC4gU2VlIGFsc28gQE1hdHJpeC54XG4gICAgIC0geCAobnVtYmVyKVxuICAgICAtIHkgKG51bWJlcilcbiAgICAgPSAobnVtYmVyKSB5XG4gICAgXFwqL1xuICAgIG1hdHJpeHByb3RvLnkgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4geCAqIHRoaXMuYiArIHkgKiB0aGlzLmQgKyB0aGlzLmY7XG4gICAgfTtcbiAgICBtYXRyaXhwcm90by5nZXQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gK3RoaXNbU3RyLmZyb21DaGFyQ29kZSg5NyArIGkpXS50b0ZpeGVkKDQpO1xuICAgIH07XG4gICAgbWF0cml4cHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIm1hdHJpeChcIiArIFt0aGlzLmdldCgwKSwgdGhpcy5nZXQoMSksIHRoaXMuZ2V0KDIpLCB0aGlzLmdldCgzKSwgdGhpcy5nZXQoNCksIHRoaXMuZ2V0KDUpXS5qb2luKCkgKyBcIilcIjtcbiAgICB9O1xuICAgIG1hdHJpeHByb3RvLm9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmUudG9GaXhlZCg0KSwgdGhpcy5mLnRvRml4ZWQoNCldO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbm9ybShhKSB7XG4gICAgICAgIHJldHVybiBhWzBdICogYVswXSArIGFbMV0gKiBhWzFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemUoYSkge1xuICAgICAgICB2YXIgbWFnID0gbWF0aC5zcXJ0KG5vcm0oYSkpO1xuICAgICAgICBhWzBdICYmIChhWzBdIC89IG1hZyk7XG4gICAgICAgIGFbMV0gJiYgKGFbMV0gLz0gbWFnKTtcbiAgICB9XG4gICAgLypcXFxuICAgICAqIE1hdHJpeC5zcGxpdFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU3BsaXRzIG1hdHJpeCBpbnRvIHByaW1pdGl2ZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgPSAob2JqZWN0KSBpbiBmb3JtYXQ6XG4gICAgIG8gZHggKG51bWJlcikgdHJhbnNsYXRpb24gYnkgeFxuICAgICBvIGR5IChudW1iZXIpIHRyYW5zbGF0aW9uIGJ5IHlcbiAgICAgbyBzY2FsZXggKG51bWJlcikgc2NhbGUgYnkgeFxuICAgICBvIHNjYWxleSAobnVtYmVyKSBzY2FsZSBieSB5XG4gICAgIG8gc2hlYXIgKG51bWJlcikgc2hlYXJcbiAgICAgbyByb3RhdGUgKG51bWJlcikgcm90YXRpb24gaW4gZGVnXG4gICAgIG8gaXNTaW1wbGUgKGJvb2xlYW4pIGNvdWxkIGl0IGJlIHJlcHJlc2VudGVkIHZpYSBzaW1wbGUgdHJhbnNmb3JtYXRpb25zXG4gICAgXFwqL1xuICAgIG1hdHJpeHByb3RvLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIC8vIHRyYW5zbGF0aW9uXG4gICAgICAgIG91dC5keCA9IHRoaXMuZTtcbiAgICAgICAgb3V0LmR5ID0gdGhpcy5mO1xuXG4gICAgICAgIC8vIHNjYWxlIGFuZCBzaGVhclxuICAgICAgICB2YXIgcm93ID0gW1t0aGlzLmEsIHRoaXMuY10sIFt0aGlzLmIsIHRoaXMuZF1dO1xuICAgICAgICBvdXQuc2NhbGV4ID0gbWF0aC5zcXJ0KG5vcm0ocm93WzBdKSk7XG4gICAgICAgIG5vcm1hbGl6ZShyb3dbMF0pO1xuXG4gICAgICAgIG91dC5zaGVhciA9IHJvd1swXVswXSAqIHJvd1sxXVswXSArIHJvd1swXVsxXSAqIHJvd1sxXVsxXTtcbiAgICAgICAgcm93WzFdID0gW3Jvd1sxXVswXSAtIHJvd1swXVswXSAqIG91dC5zaGVhciwgcm93WzFdWzFdIC0gcm93WzBdWzFdICogb3V0LnNoZWFyXTtcblxuICAgICAgICBvdXQuc2NhbGV5ID0gbWF0aC5zcXJ0KG5vcm0ocm93WzFdKSk7XG4gICAgICAgIG5vcm1hbGl6ZShyb3dbMV0pO1xuICAgICAgICBvdXQuc2hlYXIgLz0gb3V0LnNjYWxleTtcblxuICAgICAgICAvLyByb3RhdGlvblxuICAgICAgICB2YXIgc2luID0gLXJvd1swXVsxXSxcbiAgICAgICAgICAgIGNvcyA9IHJvd1sxXVsxXTtcbiAgICAgICAgaWYgKGNvcyA8IDApIHtcbiAgICAgICAgICAgIG91dC5yb3RhdGUgPSBkZWcobWF0aC5hY29zKGNvcykpO1xuICAgICAgICAgICAgaWYgKHNpbiA8IDApIHtcbiAgICAgICAgICAgICAgICBvdXQucm90YXRlID0gMzYwIC0gb3V0LnJvdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dC5yb3RhdGUgPSBkZWcobWF0aC5hc2luKHNpbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0LmlzU2ltcGxlID0gIStvdXQuc2hlYXIudG9GaXhlZCg5KSAmJiAob3V0LnNjYWxleC50b0ZpeGVkKDkpID09IG91dC5zY2FsZXkudG9GaXhlZCg5KSB8fCAhb3V0LnJvdGF0ZSk7XG4gICAgICAgIG91dC5pc1N1cGVyU2ltcGxlID0gIStvdXQuc2hlYXIudG9GaXhlZCg5KSAmJiBvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICBvdXQubm9Sb3RhdGlvbiA9ICErb3V0LnNoZWFyLnRvRml4ZWQoOSkgJiYgIW91dC5yb3RhdGU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogTWF0cml4LnRvVHJhbnNmb3JtU3RyaW5nXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRyYW5zZm9ybSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGdpdmVuIG1hdHJpeFxuICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybSBzdHJpbmdcbiAgICBcXCovXG4gICAgbWF0cml4cHJvdG8udG9UcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbiAoc2hvcnRlcikge1xuICAgICAgICB2YXIgcyA9IHNob3J0ZXIgfHwgdGhpcy5zcGxpdCgpO1xuICAgICAgICBpZiAocy5pc1NpbXBsZSkge1xuICAgICAgICAgICAgcy5zY2FsZXggPSArcy5zY2FsZXgudG9GaXhlZCg0KTtcbiAgICAgICAgICAgIHMuc2NhbGV5ID0gK3Muc2NhbGV5LnRvRml4ZWQoNCk7XG4gICAgICAgICAgICBzLnJvdGF0ZSA9ICtzLnJvdGF0ZS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgcmV0dXJuICAocy5keCB8fCBzLmR5ID8gXCJ0XCIgKyBbK3MuZHgudG9GaXhlZCg0KSwgK3MuZHkudG9GaXhlZCg0KV0gOiBFKSArXG4gICAgICAgICAgICAgICAgICAgIChzLnNjYWxleCAhPSAxIHx8IHMuc2NhbGV5ICE9IDEgPyBcInNcIiArIFtzLnNjYWxleCwgcy5zY2FsZXksIDAsIDBdIDogRSkgK1xuICAgICAgICAgICAgICAgICAgICAocy5yb3RhdGUgPyBcInJcIiArIFsrcy5yb3RhdGUudG9GaXhlZCg0KSwgMCwgMF0gOiBFKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIm1cIiArIFt0aGlzLmdldCgwKSwgdGhpcy5nZXQoMSksIHRoaXMuZ2V0KDIpLCB0aGlzLmdldCgzKSwgdGhpcy5nZXQoNCksIHRoaXMuZ2V0KDUpXTtcbiAgICAgICAgfVxuICAgIH07XG59KShNYXRyaXgucHJvdG90eXBlKTtcbi8qXFxcbiAqIFNuYXAuTWF0cml4XG4gWyBtZXRob2QgXVxuICoqXG4gKiBVdGlsaXR5IG1ldGhvZFxuICoqXG4gKiBSZXR1cm5zIGEgbWF0cml4IGJhc2VkIG9uIHRoZSBnaXZlbiBwYXJhbWV0ZXJzXG4gLSBhIChudW1iZXIpXG4gLSBiIChudW1iZXIpXG4gLSBjIChudW1iZXIpXG4gLSBkIChudW1iZXIpXG4gLSBlIChudW1iZXIpXG4gLSBmIChudW1iZXIpXG4gKiBvclxuIC0gc3ZnTWF0cml4IChTVkdNYXRyaXgpXG4gPSAob2JqZWN0KSBATWF0cml4XG5cXCovXG5TbmFwLk1hdHJpeCA9IE1hdHJpeDtcbi8vIENvbG91clxuLypcXFxuICogU25hcC5nZXRSR0JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFBhcnNlcyBjb2xvciBzdHJpbmcgYXMgUkdCIG9iamVjdFxuIC0gY29sb3IgKHN0cmluZykgY29sb3Igc3RyaW5nIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6XG4gIyA8dWw+XG4gIyAgICAgPGxpPkNvbG9yIG5hbWUgKDxjb2RlPnJlZDwvY29kZT4sIDxjb2RlPmdyZWVuPC9jb2RlPiwgPGNvZGU+Y29ybmZsb3dlcmJsdWU8L2NvZGU+LCBldGMpPC9saT5cbiAjICAgICA8bGk+I+KAouKAouKAoiDigJQgc2hvcnRlbmVkIEhUTUwgY29sb3I6ICg8Y29kZT4jMDAwPC9jb2RlPiwgPGNvZGU+I2ZjMDwvY29kZT4sIGV0Yy4pPC9saT5cbiAjICAgICA8bGk+I+KAouKAouKAouKAouKAouKAoiDigJQgZnVsbCBsZW5ndGggSFRNTCBjb2xvcjogKDxjb2RlPiMwMDAwMDA8L2NvZGU+LCA8Y29kZT4jYmQyMzAwPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5yZ2Io4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIHJlZCwgZ3JlZW4gYW5kIGJsdWUgY2hhbm5lbHMgdmFsdWVzOiAoPGNvZGU+cmdiKDIwMCwmbmJzcDsxMDAsJm5ic3A7MCk8L2NvZGU+KTwvbGk+XG4gIyAgICAgPGxpPnJnYmEo4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgYWxzbyB3aXRoIG9wYWNpdHk8L2xpPlxuICMgICAgIDxsaT5yZ2Io4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCBpbiAlOiAoPGNvZGU+cmdiKDEwMCUsJm5ic3A7MTc1JSwmbmJzcDswJSk8L2NvZGU+KTwvbGk+XG4gIyAgICAgPGxpPnJnYmEo4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+aHNiKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBodWUsIHNhdHVyYXRpb24gYW5kIGJyaWdodG5lc3MgdmFsdWVzOiAoPGNvZGU+aHNiKDAuNSwmbmJzcDswLjI1LCZuYnNwOzEpPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5oc2JhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+aHNiKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTwvbGk+XG4gIyAgICAgPGxpPmhzYmEo4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+aHNsKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBodWUsIHNhdHVyYXRpb24gYW5kIGx1bWlub3NpdHkgdmFsdWVzOiAoPGNvZGU+aHNiKDAuNSwmbmJzcDswLjI1LCZuYnNwOzAuNSk8L2NvZGU+KTwvbGk+XG4gIyAgICAgPGxpPmhzbGEo4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgYWxzbyB3aXRoIG9wYWNpdHk8L2xpPlxuICMgICAgIDxsaT5oc2wo4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCBpbiAlPC9saT5cbiAjICAgICA8bGk+aHNsYSjigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgYWxzbyB3aXRoIG9wYWNpdHk8L2xpPlxuICMgPC91bD5cbiAqIE5vdGUgdGhhdCBgJWAgY2FuIGJlIHVzZWQgYW55IHRpbWU6IGByZ2IoMjAlLCAyNTUsIDUwJSlgLlxuID0gKG9iamVjdCkgUkdCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICByIChudW1iZXIpIHJlZCxcbiBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiLFxuIG8gICAgIGVycm9yIChib29sZWFuKSB0cnVlIGlmIHN0cmluZyBjYW4ndCBiZSBwYXJzZWRcbiBvIH1cblxcKi9cblNuYXAuZ2V0UkdCID0gY2FjaGVyKGZ1bmN0aW9uIChjb2xvdXIpIHtcbiAgICBpZiAoIWNvbG91ciB8fCAhISgoY29sb3VyID0gU3RyKGNvbG91cikpLmluZGV4T2YoXCItXCIpICsgMSkpIHtcbiAgICAgICAgcmV0dXJuIHtyOiAtMSwgZzogLTEsIGI6IC0xLCBoZXg6IFwibm9uZVwiLCBlcnJvcjogMSwgdG9TdHJpbmc6IHJnYnRvU3RyaW5nfTtcbiAgICB9XG4gICAgaWYgKGNvbG91ciA9PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4ge3I6IC0xLCBnOiAtMSwgYjogLTEsIGhleDogXCJub25lXCIsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG4gICAgfVxuICAgICEoaHNyZ1toYXNdKGNvbG91ci50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygwLCAyKSkgfHwgY29sb3VyLmNoYXJBdCgpID09IFwiI1wiKSAmJiAoY29sb3VyID0gdG9IZXgoY29sb3VyKSk7XG4gICAgaWYgKCFjb2xvdXIpIHtcbiAgICAgICAgcmV0dXJuIHtyOiAtMSwgZzogLTEsIGI6IC0xLCBoZXg6IFwibm9uZVwiLCBlcnJvcjogMSwgdG9TdHJpbmc6IHJnYnRvU3RyaW5nfTtcbiAgICB9XG4gICAgdmFyIHJlcyxcbiAgICAgICAgcmVkLFxuICAgICAgICBncmVlbixcbiAgICAgICAgYmx1ZSxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgdCxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICByZ2IgPSBjb2xvdXIubWF0Y2goY29sb3VyUmVnRXhwKTtcbiAgICBpZiAocmdiKSB7XG4gICAgICAgIGlmIChyZ2JbMl0pIHtcbiAgICAgICAgICAgIGJsdWUgPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDUpLCAxNik7XG4gICAgICAgICAgICBncmVlbiA9IHRvSW50KHJnYlsyXS5zdWJzdHJpbmcoMywgNSksIDE2KTtcbiAgICAgICAgICAgIHJlZCA9IHRvSW50KHJnYlsyXS5zdWJzdHJpbmcoMSwgMyksIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmdiWzNdKSB7XG4gICAgICAgICAgICBibHVlID0gdG9JbnQoKHQgPSByZ2JbM10uY2hhckF0KDMpKSArIHQsIDE2KTtcbiAgICAgICAgICAgIGdyZWVuID0gdG9JbnQoKHQgPSByZ2JbM10uY2hhckF0KDIpKSArIHQsIDE2KTtcbiAgICAgICAgICAgIHJlZCA9IHRvSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgxKSkgKyB0LCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJnYls0XSkge1xuICAgICAgICAgICAgdmFsdWVzID0gcmdiWzRdLnNwbGl0KGNvbW1hU3BhY2VzKTtcbiAgICAgICAgICAgIHJlZCA9IHRvRmxvYXQodmFsdWVzWzBdKTtcbiAgICAgICAgICAgIHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKHJlZCAqPSAyLjU1KTtcbiAgICAgICAgICAgIGdyZWVuID0gdG9GbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgdmFsdWVzWzFdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoZ3JlZW4gKj0gMi41NSk7XG4gICAgICAgICAgICBibHVlID0gdG9GbG9hdCh2YWx1ZXNbMl0pO1xuICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAqPSAyLjU1KTtcbiAgICAgICAgICAgIHJnYlsxXS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDQpID09IFwicmdiYVwiICYmIChvcGFjaXR5ID0gdG9GbG9hdCh2YWx1ZXNbM10pKTtcbiAgICAgICAgICAgIHZhbHVlc1szXSAmJiB2YWx1ZXNbM10uc2xpY2UoLTEpID09IFwiJVwiICYmIChvcGFjaXR5IC89IDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJnYls1XSkge1xuICAgICAgICAgICAgdmFsdWVzID0gcmdiWzVdLnNwbGl0KGNvbW1hU3BhY2VzKTtcbiAgICAgICAgICAgIHJlZCA9IHRvRmxvYXQodmFsdWVzWzBdKTtcbiAgICAgICAgICAgIHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKHJlZCAvPSAxMDApO1xuICAgICAgICAgICAgZ3JlZW4gPSB0b0Zsb2F0KHZhbHVlc1sxXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMV0uc2xpY2UoLTEpID09IFwiJVwiICYmIChncmVlbiAvPSAxMDApO1xuICAgICAgICAgICAgYmx1ZSA9IHRvRmxvYXQodmFsdWVzWzJdKTtcbiAgICAgICAgICAgIHZhbHVlc1syXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGJsdWUgLz0gMTAwKTtcbiAgICAgICAgICAgICh2YWx1ZXNbMF0uc2xpY2UoLTMpID09IFwiZGVnXCIgfHwgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIlxceGIwXCIpICYmIChyZWQgLz0gMzYwKTtcbiAgICAgICAgICAgIHJnYlsxXS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDQpID09IFwiaHNiYVwiICYmIChvcGFjaXR5ID0gdG9GbG9hdCh2YWx1ZXNbM10pKTtcbiAgICAgICAgICAgIHZhbHVlc1szXSAmJiB2YWx1ZXNbM10uc2xpY2UoLTEpID09IFwiJVwiICYmIChvcGFjaXR5IC89IDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gU25hcC5oc2IycmdiKHJlZCwgZ3JlZW4sIGJsdWUsIG9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2JbNl0pIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHJnYls2XS5zcGxpdChjb21tYVNwYWNlcyk7XG4gICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgLz0gMTAwKTtcbiAgICAgICAgICAgIGdyZWVuID0gdG9GbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgdmFsdWVzWzFdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoZ3JlZW4gLz0gMTAwKTtcbiAgICAgICAgICAgIGJsdWUgPSB0b0Zsb2F0KHZhbHVlc1syXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMl0uc2xpY2UoLTEpID09IFwiJVwiICYmIChibHVlIC89IDEwMCk7XG4gICAgICAgICAgICAodmFsdWVzWzBdLnNsaWNlKC0zKSA9PSBcImRlZ1wiIHx8IHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCJcXHhiMFwiKSAmJiAocmVkIC89IDM2MCk7XG4gICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcImhzbGFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICB2YWx1ZXNbM10gJiYgdmFsdWVzWzNdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAob3BhY2l0eSAvPSAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuaHNsMnJnYihyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICByZWQgPSBtbWluKG1hdGgucm91bmQocmVkKSwgMjU1KTtcbiAgICAgICAgZ3JlZW4gPSBtbWluKG1hdGgucm91bmQoZ3JlZW4pLCAyNTUpO1xuICAgICAgICBibHVlID0gbW1pbihtYXRoLnJvdW5kKGJsdWUpLCAyNTUpO1xuICAgICAgICBvcGFjaXR5ID0gbW1pbihtbWF4KG9wYWNpdHksIDApLCAxKTtcbiAgICAgICAgcmdiID0ge3I6IHJlZCwgZzogZ3JlZW4sIGI6IGJsdWUsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG4gICAgICAgIHJnYi5oZXggPSBcIiNcIiArICgxNjc3NzIxNiB8IGJsdWUgfCAoZ3JlZW4gPDwgOCkgfCAocmVkIDw8IDE2KSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICByZ2Iub3BhY2l0eSA9IGlzKG9wYWNpdHksIFwiZmluaXRlXCIpID8gb3BhY2l0eSA6IDE7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG59LCBTbmFwKTtcbi8vIFNJRVJSQSBJdCBzZWVtcyBvZGQgdGhhdCB0aGUgZm9sbG93aW5nIDMgY29udmVyc2lvbiBtZXRob2RzIGFyZSBub3QgZXhwcmVzc2VkIGFzIC50aGlzMnRoYXQoKSwgbGlrZSB0aGUgb3RoZXJzLlxuLypcXFxuICogU25hcC5oc2JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIEhTQiB2YWx1ZXMgdG8gYSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG4gLSBoIChudW1iZXIpIGh1ZVxuIC0gcyAobnVtYmVyKSBzYXR1cmF0aW9uXG4gLSBiIChudW1iZXIpIHZhbHVlIG9yIGJyaWdodG5lc3NcbiA9IChzdHJpbmcpIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcblxcKi9cblNuYXAuaHNiID0gY2FjaGVyKGZ1bmN0aW9uIChoLCBzLCBiKSB7XG4gICAgcmV0dXJuIFNuYXAuaHNiMnJnYihoLCBzLCBiKS5oZXg7XG59KTtcbi8qXFxcbiAqIFNuYXAuaHNsXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBIU0wgdmFsdWVzIHRvIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuIC0gaCAobnVtYmVyKSBodWVcbiAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuIC0gbCAobnVtYmVyKSBsdW1pbm9zaXR5XG4gPSAoc3RyaW5nKSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG5cXCovXG5TbmFwLmhzbCA9IGNhY2hlcihmdW5jdGlvbiAoaCwgcywgbCkge1xuICAgIHJldHVybiBTbmFwLmhzbDJyZ2IoaCwgcywgbCkuaGV4O1xufSk7XG4vKlxcXG4gKiBTbmFwLnJnYlxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgUkdCIHZhbHVlcyB0byBhIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcbiAtIHIgKG51bWJlcikgcmVkXG4gLSBnIChudW1iZXIpIGdyZWVuXG4gLSBiIChudW1iZXIpIGJsdWVcbiA9IChzdHJpbmcpIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcblxcKi9cblNuYXAucmdiID0gY2FjaGVyKGZ1bmN0aW9uIChyLCBnLCBiLCBvKSB7XG4gICAgaWYgKGlzKG8sIFwiZmluaXRlXCIpKSB7XG4gICAgICAgIHZhciByb3VuZCA9IG1hdGgucm91bmQ7XG4gICAgICAgIHJldHVybiBcInJnYmEoXCIgKyBbcm91bmQociksIHJvdW5kKGcpLCByb3VuZChiKSwgK28udG9GaXhlZCgyKV0gKyBcIilcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiI1wiICsgKDE2Nzc3MjE2IHwgYiB8IChnIDw8IDgpIHwgKHIgPDwgMTYpKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG59KTtcbnZhciB0b0hleCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHZhciBpID0gZ2xvYi5kb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLFxuICAgICAgICByZWQgPSBcInJnYigyNTUsIDAsIDApXCI7XG4gICAgdG9IZXggPSBjYWNoZXIoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmIChjb2xvci50b0xvd2VyQ2FzZSgpID09IFwicmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IHJlZDtcbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgICAgICB2YXIgb3V0ID0gZ2xvYi5kb2MuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShpLCBFKS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29sb3JcIik7XG4gICAgICAgIHJldHVybiBvdXQgPT0gcmVkID8gbnVsbCA6IG91dDtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9IZXgoY29sb3IpO1xufSxcbmhzYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImhzYihcIiArIFt0aGlzLmgsIHRoaXMucywgdGhpcy5iXSArIFwiKVwiO1xufSxcbmhzbHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImhzbChcIiArIFt0aGlzLmgsIHRoaXMucywgdGhpcy5sXSArIFwiKVwiO1xufSxcbnJnYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPT0gMSB8fCB0aGlzLm9wYWNpdHkgPT0gbnVsbCA/XG4gICAgICAgICAgICB0aGlzLmhleCA6XG4gICAgICAgICAgICBcInJnYmEoXCIgKyBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5vcGFjaXR5XSArIFwiKVwiO1xufSxcbnByZXBhcmVSR0IgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIGlmIChnID09IG51bGwgJiYgaXMociwgXCJvYmplY3RcIikgJiYgXCJyXCIgaW4gciAmJiBcImdcIiBpbiByICYmIFwiYlwiIGluIHIpIHtcbiAgICAgICAgYiA9IHIuYjtcbiAgICAgICAgZyA9IHIuZztcbiAgICAgICAgciA9IHIucjtcbiAgICB9XG4gICAgaWYgKGcgPT0gbnVsbCAmJiBpcyhyLCBzdHJpbmcpKSB7XG4gICAgICAgIHZhciBjbHIgPSBTbmFwLmdldFJHQihyKTtcbiAgICAgICAgciA9IGNsci5yO1xuICAgICAgICBnID0gY2xyLmc7XG4gICAgICAgIGIgPSBjbHIuYjtcbiAgICB9XG4gICAgaWYgKHIgPiAxIHx8IGcgPiAxIHx8IGIgPiAxKSB7XG4gICAgICAgIHIgLz0gMjU1O1xuICAgICAgICBnIC89IDI1NTtcbiAgICAgICAgYiAvPSAyNTU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn0sXG5wYWNrYWdlUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIsIG8pIHtcbiAgICByID0gbWF0aC5yb3VuZChyICogMjU1KTtcbiAgICBnID0gbWF0aC5yb3VuZChnICogMjU1KTtcbiAgICBiID0gbWF0aC5yb3VuZChiICogMjU1KTtcbiAgICB2YXIgcmdiID0ge1xuICAgICAgICByOiByLFxuICAgICAgICBnOiBnLFxuICAgICAgICBiOiBiLFxuICAgICAgICBvcGFjaXR5OiBpcyhvLCBcImZpbml0ZVwiKSA/IG8gOiAxLFxuICAgICAgICBoZXg6IFNuYXAucmdiKHIsIGcsIGIpLFxuICAgICAgICB0b1N0cmluZzogcmdidG9TdHJpbmdcbiAgICB9O1xuICAgIGlzKG8sIFwiZmluaXRlXCIpICYmIChyZ2Iub3BhY2l0eSA9IG8pO1xuICAgIHJldHVybiByZ2I7XG59O1xuLy8gU0lFUlJBIENsYXJpZnkgaWYgU25hcCBkb2VzIG5vdCBzdXBwb3J0IGNvbnNvbGlkYXRlZCBIU0xBL1JHQkEgY29sb3JzLiBFLmcuLCBjYW4geW91IHNwZWNpZnkgYSBzZW1pLXRyYW5zcGFyZW50IHZhbHVlIGZvciBTbmFwLmZpbHRlci5zaGFkb3coKT9cbi8qXFxcbiAqIFNuYXAuY29sb3JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFBhcnNlcyB0aGUgY29sb3Igc3RyaW5nIGFuZCByZXR1cm5zIGFuIG9iamVjdCBmZWF0dXJpbmcgdGhlIGNvbG9yJ3MgY29tcG9uZW50IHZhbHVlc1xuIC0gY2xyIChzdHJpbmcpIGNvbG9yIHN0cmluZyBpbiBvbmUgb2YgdGhlIHN1cHBvcnRlZCBmb3JtYXRzIChzZWUgQFNuYXAuZ2V0UkdCKVxuID0gKG9iamVjdCkgQ29tYmluZWQgUkdCL0hTQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgciAobnVtYmVyKSByZWQsXG4gbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAoixcbiBvICAgICBlcnJvciAoYm9vbGVhbikgYHRydWVgIGlmIHN0cmluZyBjYW4ndCBiZSBwYXJzZWQsXG4gbyAgICAgaCAobnVtYmVyKSBodWUsXG4gbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uLFxuIG8gICAgIHYgKG51bWJlcikgdmFsdWUgKGJyaWdodG5lc3MpLFxuIG8gICAgIGwgKG51bWJlcikgbGlnaHRuZXNzXG4gbyB9XG5cXCovXG5TbmFwLmNvbG9yID0gZnVuY3Rpb24gKGNscikge1xuICAgIHZhciByZ2I7XG4gICAgaWYgKGlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gY2xyICYmIFwic1wiIGluIGNsciAmJiBcImJcIiBpbiBjbHIpIHtcbiAgICAgICAgcmdiID0gU25hcC5oc2IycmdiKGNscik7XG4gICAgICAgIGNsci5yID0gcmdiLnI7XG4gICAgICAgIGNsci5nID0gcmdiLmc7XG4gICAgICAgIGNsci5iID0gcmdiLmI7XG4gICAgICAgIGNsci5vcGFjaXR5ID0gMTtcbiAgICAgICAgY2xyLmhleCA9IHJnYi5oZXg7XG4gICAgfSBlbHNlIGlmIChpcyhjbHIsIFwib2JqZWN0XCIpICYmIFwiaFwiIGluIGNsciAmJiBcInNcIiBpbiBjbHIgJiYgXCJsXCIgaW4gY2xyKSB7XG4gICAgICAgIHJnYiA9IFNuYXAuaHNsMnJnYihjbHIpO1xuICAgICAgICBjbHIuciA9IHJnYi5yO1xuICAgICAgICBjbHIuZyA9IHJnYi5nO1xuICAgICAgICBjbHIuYiA9IHJnYi5iO1xuICAgICAgICBjbHIub3BhY2l0eSA9IDE7XG4gICAgICAgIGNsci5oZXggPSByZ2IuaGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpcyhjbHIsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBjbHIgPSBTbmFwLmdldFJHQihjbHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhjbHIsIFwib2JqZWN0XCIpICYmIFwiclwiIGluIGNsciAmJiBcImdcIiBpbiBjbHIgJiYgXCJiXCIgaW4gY2xyICYmICEoXCJlcnJvclwiIGluIGNscikpIHtcbiAgICAgICAgICAgIHJnYiA9IFNuYXAucmdiMmhzbChjbHIpO1xuICAgICAgICAgICAgY2xyLmggPSByZ2IuaDtcbiAgICAgICAgICAgIGNsci5zID0gcmdiLnM7XG4gICAgICAgICAgICBjbHIubCA9IHJnYi5sO1xuICAgICAgICAgICAgcmdiID0gU25hcC5yZ2IyaHNiKGNscik7XG4gICAgICAgICAgICBjbHIudiA9IHJnYi5iO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xyID0ge2hleDogXCJub25lXCJ9O1xuICAgICAgICAgICAgY2xyLnIgPSBjbHIuZyA9IGNsci5iID0gY2xyLmggPSBjbHIucyA9IGNsci52ID0gY2xyLmwgPSAtMTtcbiAgICAgICAgICAgIGNsci5lcnJvciA9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xyLnRvU3RyaW5nID0gcmdidG9TdHJpbmc7XG4gICAgcmV0dXJuIGNscjtcbn07XG4vKlxcXG4gKiBTbmFwLmhzYjJyZ2JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIEhTQiB2YWx1ZXMgdG8gYW4gUkdCIG9iamVjdFxuIC0gaCAobnVtYmVyKSBodWVcbiAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuIC0gdiAobnVtYmVyKSB2YWx1ZSBvciBicmlnaHRuZXNzXG4gPSAob2JqZWN0KSBSR0Igb2JqZWN0IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuIG8ge1xuIG8gICAgIHIgKG51bWJlcikgcmVkLFxuIG8gICAgIGcgKG51bWJlcikgZ3JlZW4sXG4gbyAgICAgYiAobnVtYmVyKSBibHVlLFxuIG8gICAgIGhleCAoc3RyaW5nKSBjb2xvciBpbiBIVE1ML0NTUyBmb3JtYXQ6ICPigKLigKLigKLigKLigKLigKJcbiBvIH1cblxcKi9cblNuYXAuaHNiMnJnYiA9IGZ1bmN0aW9uIChoLCBzLCB2LCBvKSB7XG4gICAgaWYgKGlzKGgsIFwib2JqZWN0XCIpICYmIFwiaFwiIGluIGggJiYgXCJzXCIgaW4gaCAmJiBcImJcIiBpbiBoKSB7XG4gICAgICAgIHYgPSBoLmI7XG4gICAgICAgIHMgPSBoLnM7XG4gICAgICAgIGggPSBoLmg7XG4gICAgICAgIG8gPSBoLm87XG4gICAgfVxuICAgIGggKj0gMzYwO1xuICAgIHZhciBSLCBHLCBCLCBYLCBDO1xuICAgIGggPSAoaCAlIDM2MCkgLyA2MDtcbiAgICBDID0gdiAqIHM7XG4gICAgWCA9IEMgKiAoMSAtIGFicyhoICUgMiAtIDEpKTtcbiAgICBSID0gRyA9IEIgPSB2IC0gQztcblxuICAgIGggPSB+fmg7XG4gICAgUiArPSBbQywgWCwgMCwgMCwgWCwgQ11baF07XG4gICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgQiArPSBbMCwgMCwgWCwgQywgQywgWF1baF07XG4gICAgcmV0dXJuIHBhY2thZ2VSR0IoUiwgRywgQiwgbyk7XG59O1xuLypcXFxuICogU25hcC5oc2wycmdiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBIU0wgdmFsdWVzIHRvIGFuIFJHQiBvYmplY3RcbiAtIGggKG51bWJlcikgaHVlXG4gLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAtIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuID0gKG9iamVjdCkgUkdCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICByIChudW1iZXIpIHJlZCxcbiBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiXG4gbyB9XG5cXCovXG5TbmFwLmhzbDJyZ2IgPSBmdW5jdGlvbiAoaCwgcywgbCwgbykge1xuICAgIGlmIChpcyhoLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBoICYmIFwic1wiIGluIGggJiYgXCJsXCIgaW4gaCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBzID0gaC5zO1xuICAgICAgICBoID0gaC5oO1xuICAgIH1cbiAgICBpZiAoaCA+IDEgfHwgcyA+IDEgfHwgbCA+IDEpIHtcbiAgICAgICAgaCAvPSAzNjA7XG4gICAgICAgIHMgLz0gMTAwO1xuICAgICAgICBsIC89IDEwMDtcbiAgICB9XG4gICAgaCAqPSAzNjA7XG4gICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgaCA9IChoICUgMzYwKSAvIDYwO1xuICAgIEMgPSAyICogcyAqIChsIDwgLjUgPyBsIDogMSAtIGwpO1xuICAgIFggPSBDICogKDEgLSBhYnMoaCAlIDIgLSAxKSk7XG4gICAgUiA9IEcgPSBCID0gbCAtIEMgLyAyO1xuXG4gICAgaCA9IH5+aDtcbiAgICBSICs9IFtDLCBYLCAwLCAwLCBYLCBDXVtoXTtcbiAgICBHICs9IFtYLCBDLCBDLCBYLCAwLCAwXVtoXTtcbiAgICBCICs9IFswLCAwLCBYLCBDLCBDLCBYXVtoXTtcbiAgICByZXR1cm4gcGFja2FnZVJHQihSLCBHLCBCLCBvKTtcbn07XG4vKlxcXG4gKiBTbmFwLnJnYjJoc2JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIFJHQiB2YWx1ZXMgdG8gYW4gSFNCIG9iamVjdFxuIC0gciAobnVtYmVyKSByZWRcbiAtIGcgKG51bWJlcikgZ3JlZW5cbiAtIGIgKG51bWJlcikgYmx1ZVxuID0gKG9iamVjdCkgSFNCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICBoIChudW1iZXIpIGh1ZSxcbiBvICAgICBzIChudW1iZXIpIHNhdHVyYXRpb24sXG4gbyAgICAgYiAobnVtYmVyKSBicmlnaHRuZXNzXG4gbyB9XG5cXCovXG5TbmFwLnJnYjJoc2IgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIGIgPSBwcmVwYXJlUkdCKHIsIGcsIGIpO1xuICAgIHIgPSBiWzBdO1xuICAgIGcgPSBiWzFdO1xuICAgIGIgPSBiWzJdO1xuXG4gICAgdmFyIEgsIFMsIFYsIEM7XG4gICAgViA9IG1tYXgociwgZywgYik7XG4gICAgQyA9IFYgLSBtbWluKHIsIGcsIGIpO1xuICAgIEggPSAoQyA9PSAwID8gbnVsbCA6XG4gICAgICAgICBWID09IHIgPyAoZyAtIGIpIC8gQyA6XG4gICAgICAgICBWID09IGcgPyAoYiAtIHIpIC8gQyArIDIgOlxuICAgICAgICAgICAgICAgICAgKHIgLSBnKSAvIEMgKyA0XG4gICAgICAgICk7XG4gICAgSCA9ICgoSCArIDM2MCkgJSA2KSAqIDYwIC8gMzYwO1xuICAgIFMgPSBDID09IDAgPyAwIDogQyAvIFY7XG4gICAgcmV0dXJuIHtoOiBILCBzOiBTLCBiOiBWLCB0b1N0cmluZzogaHNidG9TdHJpbmd9O1xufTtcbi8qXFxcbiAqIFNuYXAucmdiMmhzbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgUkdCIHZhbHVlcyB0byBhbiBIU0wgb2JqZWN0XG4gLSByIChudW1iZXIpIHJlZFxuIC0gZyAobnVtYmVyKSBncmVlblxuIC0gYiAobnVtYmVyKSBibHVlXG4gPSAob2JqZWN0KSBIU0wgb2JqZWN0IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuIG8ge1xuIG8gICAgIGggKG51bWJlcikgaHVlLFxuIG8gICAgIHMgKG51bWJlcikgc2F0dXJhdGlvbixcbiBvICAgICBsIChudW1iZXIpIGx1bWlub3NpdHlcbiBvIH1cblxcKi9cblNuYXAucmdiMmhzbCA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgYiA9IHByZXBhcmVSR0IociwgZywgYik7XG4gICAgciA9IGJbMF07XG4gICAgZyA9IGJbMV07XG4gICAgYiA9IGJbMl07XG5cbiAgICB2YXIgSCwgUywgTCwgTSwgbSwgQztcbiAgICBNID0gbW1heChyLCBnLCBiKTtcbiAgICBtID0gbW1pbihyLCBnLCBiKTtcbiAgICBDID0gTSAtIG07XG4gICAgSCA9IChDID09IDAgPyBudWxsIDpcbiAgICAgICAgIE0gPT0gciA/IChnIC0gYikgLyBDIDpcbiAgICAgICAgIE0gPT0gZyA/IChiIC0gcikgLyBDICsgMiA6XG4gICAgICAgICAgICAgICAgICAociAtIGcpIC8gQyArIDQpO1xuICAgIEggPSAoKEggKyAzNjApICUgNikgKiA2MCAvIDM2MDtcbiAgICBMID0gKE0gKyBtKSAvIDI7XG4gICAgUyA9IChDID09IDAgPyAwIDpcbiAgICAgICAgIEwgPCAuNSA/IEMgLyAoMiAqIEwpIDpcbiAgICAgICAgICAgICAgICAgIEMgLyAoMiAtIDIgKiBMKSk7XG4gICAgcmV0dXJuIHtoOiBILCBzOiBTLCBsOiBMLCB0b1N0cmluZzogaHNsdG9TdHJpbmd9O1xufTtcblxuLy8gVHJhbnNmb3JtYXRpb25zXG4vLyBTSUVSUkEgU25hcC5wYXJzZVBhdGhTdHJpbmcoKTogQnkgX2FycmF5IG9mIGFycmF5cyxfIEkgYXNzdW1lIHlvdSBtZWFuIGEgZm9ybWF0IGxpa2UgdGhpcyBmb3IgdHdvIHNlcGFyYXRlIHNlZ21lbnRzPyBbIFtcIk0xMCwxMFwiLFwiTDkwLDkwXCJdLCBbXCJNOTAsMTBcIixcIkwxMCw5MFwiXSBdIE90aGVyd2lzZSBob3cgaXMgZWFjaCBjb21tYW5kIHN0cnVjdHVyZWQ/XG4vKlxcXG4gKiBTbmFwLnBhcnNlUGF0aFN0cmluZ1xuIFsgbWV0aG9kIF1cbiAqKlxuICogVXRpbGl0eSBtZXRob2RcbiAqKlxuICogUGFyc2VzIGdpdmVuIHBhdGggc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBhdGggc2VnbWVudHNcbiAtIHBhdGhTdHJpbmcgKHN0cmluZ3xhcnJheSkgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2Ygc2VnbWVudHMgKGluIHRoZSBsYXN0IGNhc2UgaXQgaXMgcmV0dXJuZWQgc3RyYWlnaHQgYXdheSlcbiA9IChhcnJheSkgYXJyYXkgb2Ygc2VnbWVudHNcblxcKi9cblNuYXAucGFyc2VQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICBpZiAoIXBhdGhTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBwdGggPSBTbmFwLnBhdGgocGF0aFN0cmluZyk7XG4gICAgaWYgKHB0aC5hcnIpIHtcbiAgICAgICAgcmV0dXJuIFNuYXAucGF0aC5jbG9uZShwdGguYXJyKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1Db3VudHMgPSB7YTogNywgYzogNiwgbzogMiwgaDogMSwgbDogMiwgbTogMiwgcjogNCwgcTogNCwgczogNCwgdDogMiwgdjogMSwgdTogMywgejogMH0sXG4gICAgICAgIGRhdGEgPSBbXTtcbiAgICBpZiAoaXMocGF0aFN0cmluZywgXCJhcnJheVwiKSAmJiBpcyhwYXRoU3RyaW5nWzBdLCBcImFycmF5XCIpKSB7IC8vIHJvdWdoIGFzc3VtcHRpb25cbiAgICAgICAgZGF0YSA9IFNuYXAucGF0aC5jbG9uZShwYXRoU3RyaW5nKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgICBTdHIocGF0aFN0cmluZykucmVwbGFjZShwYXRoQ29tbWFuZCwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXSxcbiAgICAgICAgICAgICAgICBuYW1lID0gYi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgYy5yZXBsYWNlKHBhdGhWYWx1ZXMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgYiAmJiBwYXJhbXMucHVzaCgrYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwibVwiICYmIHBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCAyKSkpO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcImxcIjtcbiAgICAgICAgICAgICAgICBiID0gYiA9PSBcIm1cIiA/IFwibFwiIDogXCJMXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcIm9cIiAmJiBwYXJhbXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2IsIHBhcmFtc1swXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJyXCIpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB3aGlsZSAocGFyYW1zLmxlbmd0aCA+PSBwYXJhbUNvdW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgcGFyYW1Db3VudHNbbmFtZV0pKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbUNvdW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRhLnRvU3RyaW5nID0gU25hcC5wYXRoLnRvU3RyaW5nO1xuICAgIHB0aC5hcnIgPSBTbmFwLnBhdGguY2xvbmUoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuLypcXFxuICogU25hcC5wYXJzZVRyYW5zZm9ybVN0cmluZ1xuIFsgbWV0aG9kIF1cbiAqKlxuICogVXRpbGl0eSBtZXRob2RcbiAqKlxuICogUGFyc2VzIGdpdmVuIHRyYW5zZm9ybSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnNcbiAtIFRTdHJpbmcgKHN0cmluZ3xhcnJheSkgdHJhbnNmb3JtIHN0cmluZyBvciBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnMgKGluIHRoZSBsYXN0IGNhc2UgaXQgaXMgcmV0dXJuZWQgc3RyYWlnaHQgYXdheSlcbiA9IChhcnJheSkgYXJyYXkgb2YgdHJhbnNmb3JtYXRpb25zXG5cXCovXG52YXIgcGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBTbmFwLnBhcnNlVHJhbnNmb3JtU3RyaW5nID0gZnVuY3Rpb24gKFRTdHJpbmcpIHtcbiAgICBpZiAoIVRTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBwYXJhbUNvdW50cyA9IHtyOiAzLCBzOiA0LCB0OiAyLCBtOiA2fSxcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgIGlmIChpcyhUU3RyaW5nLCBcImFycmF5XCIpICYmIGlzKFRTdHJpbmdbMF0sIFwiYXJyYXlcIikpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICBkYXRhID0gU25hcC5wYXRoLmNsb25lKFRTdHJpbmcpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgIFN0cihUU3RyaW5nKS5yZXBsYWNlKHRDb21tYW5kLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBiLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjLnJlcGxhY2UocGF0aFZhbHVlcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBiICYmIHBhcmFtcy5wdXNoKCtiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRhLnRvU3RyaW5nID0gU25hcC5wYXRoLnRvU3RyaW5nO1xuICAgIHJldHVybiBkYXRhO1xufTtcbmZ1bmN0aW9uIHN2Z1RyYW5zZm9ybTJzdHJpbmcodHN0cikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB0c3RyID0gdHN0ci5yZXBsYWNlKC8oPzpefFxccykoXFx3KylcXCgoW14pXSspXFwpL2csIGZ1bmN0aW9uIChhbGwsIG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMuc3BsaXQoL1xccyosXFxzKnxcXHMrLyk7XG4gICAgICAgIGlmIChuYW1lID09IFwicm90YXRlXCIgJiYgcGFyYW1zLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaCgwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSBcInNjYWxlXCIpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCgwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbXNbMF0sIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwic2tld1hcIikge1xuICAgICAgICAgICAgcmVzLnB1c2goW1wibVwiLCAxLCAwLCBtYXRoLnRhbihyYWQocGFyYW1zWzBdKSksIDEsIDAsIDBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwic2tld1lcIikge1xuICAgICAgICAgICAgcmVzLnB1c2goW1wibVwiLCAxLCBtYXRoLnRhbihyYWQocGFyYW1zWzBdKSksIDAsIDEsIDAsIDBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtuYW1lLmNoYXJBdCgwKV0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cblNuYXAuXy5zdmdUcmFuc2Zvcm0yc3RyaW5nID0gc3ZnVHJhbnNmb3JtMnN0cmluZztcblNuYXAuXy5yZ1RyYW5zZm9ybSA9IG5ldyBSZWdFeHAoXCJeW2Etel1bXCIgKyBzcGFjZXMgKyBcIl0qLT9cXFxcLj9cXFxcZFwiLCBcImlcIik7XG5mdW5jdGlvbiB0cmFuc2Zvcm0ybWF0cml4KHRzdHIsIGJib3gpIHtcbiAgICB2YXIgdGRhdGEgPSBwYXJzZVRyYW5zZm9ybVN0cmluZyh0c3RyKSxcbiAgICAgICAgbSA9IG5ldyBNYXRyaXg7XG4gICAgaWYgKHRkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRkYXRhLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGRhdGFbaV0sXG4gICAgICAgICAgICAgICAgdGxlbiA9IHQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBTdHIodFswXSkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZSA9IHRbMF0gIT0gY29tbWFuZCxcbiAgICAgICAgICAgICAgICBpbnZlciA9IGFic29sdXRlID8gbS5pbnZlcnQoKSA6IDAsXG4gICAgICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICAgICAgeDIsXG4gICAgICAgICAgICAgICAgeTIsXG4gICAgICAgICAgICAgICAgYmI7XG4gICAgICAgICAgICBpZiAoY29tbWFuZCA9PSBcInRcIiAmJiB0bGVuID09IDIpe1xuICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKHRbMV0sIDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwidFwiICYmIHRsZW4gPT0gMykge1xuICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICB4MSA9IGludmVyLngoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHkxID0gaW52ZXIueSgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBpbnZlci54KHRbMV0sIHRbMl0pO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFsxXSwgdFsyXSk7XG4gICAgICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKHgyIC0geDEsIHkyIC0geTEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKHRbMV0sIHRbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PSBcInJcIikge1xuICAgICAgICAgICAgICAgIGlmICh0bGVuID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmIgPSBiYiB8fCBiYm94O1xuICAgICAgICAgICAgICAgICAgICBtLnJvdGF0ZSh0WzFdLCBiYi54ICsgYmIud2lkdGggLyAyLCBiYi55ICsgYmIuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bGVuID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IGludmVyLngodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnJvdGF0ZSh0WzFdLCB4MiwgeTIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yb3RhdGUodFsxXSwgdFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGxlbiA9PSAyIHx8IHRsZW4gPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBiYiA9IGJiIHx8IGJib3g7XG4gICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFt0bGVuIC0gMV0sIGJiLnggKyBiYi53aWR0aCAvIDIsIGJiLnkgKyBiYi5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRsZW4gPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzJdLCB0WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gaW52ZXIueSh0WzJdLCB0WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFsxXSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFsxXSwgdFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRsZW4gPT0gNSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzNdLCB0WzRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gaW52ZXIueSh0WzNdLCB0WzRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFsyXSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFsyXSwgdFszXSwgdFs0XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJtXCIgJiYgdGxlbiA9PSA3KSB7XG4gICAgICAgICAgICAgICAgbS5hZGQodFsxXSwgdFsyXSwgdFszXSwgdFs0XSwgdFs1XSwgdFs2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG07XG59XG5TbmFwLl8udHJhbnNmb3JtMm1hdHJpeCA9IHRyYW5zZm9ybTJtYXRyaXg7XG5mdW5jdGlvbiBleHRyYWN0VHJhbnNmb3JtKGVsLCB0c3RyKSB7XG4gICAgaWYgKHRzdHIgPT0gbnVsbCkge1xuICAgICAgICB2YXIgZG9SZXR1cm4gPSB0cnVlO1xuICAgICAgICBpZiAoZWwudHlwZSA9PSBcImxpbmVhckdyYWRpZW50XCIgfHwgZWwudHlwZSA9PSBcInJhZGlhbEdyYWRpZW50XCIpIHtcbiAgICAgICAgICAgIHRzdHIgPSBlbC5ub2RlLmdldEF0dHJpYnV0ZShcImdyYWRpZW50VHJhbnNmb3JtXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsLnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICAgIHRzdHIgPSBlbC5ub2RlLmdldEF0dHJpYnV0ZShcInBhdHRlcm5UcmFuc2Zvcm1cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0c3RyID0gZWwubm9kZS5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0c3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICB0c3RyID0gc3ZnVHJhbnNmb3JtMnN0cmluZyh0c3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIVNuYXAuXy5yZ1RyYW5zZm9ybS50ZXN0KHRzdHIpKSB7XG4gICAgICAgICAgICB0c3RyID0gc3ZnVHJhbnNmb3JtMnN0cmluZyh0c3RyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRzdHIgPSBTdHIodHN0cikucmVwbGFjZSgvXFwuezN9fFxcdTIwMjYvZywgZWwuXy50cmFuc2Zvcm0gfHwgRSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHRzdHIsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIHRzdHIgPSBTbmFwLnBhdGggPyBTbmFwLnBhdGgudG9TdHJpbmcuY2FsbCh0c3RyKSA6IFN0cih0c3RyKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5fLnRyYW5zZm9ybSA9IHRzdHI7XG4gICAgfVxuICAgIHZhciBtID0gdHJhbnNmb3JtMm1hdHJpeCh0c3RyLCBlbC5nZXRCQm94KDEpKTtcbiAgICBpZiAoZG9SZXR1cm4pIHtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWwubWF0cml4ID0gbTtcbiAgICB9XG59XG5TbmFwLl91bml0MnB4ID0gdW5pdDJweDtcbnZhciBjb250YWlucyA9IGdsb2IuZG9jLmNvbnRhaW5zIHx8IGdsb2IuZG9jLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID9cbiAgICBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG4gICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiBhID09IGJ1cCB8fCAhIShidXAgJiYgYnVwLm5vZGVUeXBlID09IDEgJiYgKFxuICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zID9cbiAgICAgICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMoYnVwKSA6XG4gICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihidXApICYgMTZcbiAgICAgICAgICAgICkpO1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICB3aGlsZSAoYikge1xuICAgICAgICAgICAgICAgIGIgPSBiLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGIgPT0gYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5mdW5jdGlvbiBnZXRTb21lRGVmcyhlbCkge1xuICAgIHZhciBjYWNoZSA9IFNuYXAuXy5zb21lRGVmcztcbiAgICBpZiAoY2FjaGUgJiYgY29udGFpbnMoY2FjaGUub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGNhY2hlKSkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICAgIHZhciBwID0gKGVsLm5vZGUub3duZXJTVkdFbGVtZW50ICYmIHdyYXAoZWwubm9kZS5vd25lclNWR0VsZW1lbnQpKSB8fFxuICAgICAgICAgICAgKGVsLm5vZGUucGFyZW50Tm9kZSAmJiB3cmFwKGVsLm5vZGUucGFyZW50Tm9kZSkpIHx8XG4gICAgICAgICAgICBTbmFwLnNlbGVjdChcInN2Z1wiKSB8fFxuICAgICAgICAgICAgU25hcCgwLCAwKSxcbiAgICAgICAgcGRlZnMgPSBwLnNlbGVjdChcImRlZnNcIiksXG4gICAgICAgIGRlZnMgID0gcGRlZnMgPT0gbnVsbCA/IGZhbHNlIDogcGRlZnMubm9kZTtcbiAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgZGVmcyA9IG1ha2UoXCJkZWZzXCIsIHAubm9kZSkubm9kZTtcbiAgICB9XG4gICAgU25hcC5fLnNvbWVEZWZzID0gZGVmcztcbiAgICByZXR1cm4gZGVmcztcbn1cblNuYXAuXy5nZXRTb21lRGVmcyA9IGdldFNvbWVEZWZzO1xuZnVuY3Rpb24gdW5pdDJweChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgZGVmcyA9IGdldFNvbWVEZWZzKGVsKSxcbiAgICAgICAgb3V0ID0ge30sXG4gICAgICAgIG1nciA9IGRlZnMucXVlcnlTZWxlY3RvcihcIi5zdmctLS1tZ3JcIik7XG4gICAgaWYgKCFtZ3IpIHtcbiAgICAgICAgbWdyID0gJChcInJlY3RcIik7XG4gICAgICAgICQobWdyLCB7d2lkdGg6IDEwLCBoZWlnaHQ6IDEwLCBcImNsYXNzXCI6IFwic3ZnLS0tbWdyXCJ9KTtcbiAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChtZ3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRXKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgPT0gK3ZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICAkKG1nciwge3dpZHRoOiB2YWx9KTtcbiAgICAgICAgcmV0dXJuIG1nci5nZXRCQm94KCkud2lkdGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEgodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PSArdmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgICQobWdyLCB7aGVpZ2h0OiB2YWx9KTtcbiAgICAgICAgcmV0dXJuIG1nci5nZXRCQm94KCkuaGVpZ2h0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXQobmFtLCBmKSB7XG4gICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIG91dFtuYW1dID0gZihlbC5hdHRyKG5hbSkpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbSA9PSBuYW1lKSB7XG4gICAgICAgICAgICBvdXQgPSBmKHZhbHVlID09IG51bGwgPyBlbC5hdHRyKG5hbSkgOiB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChlbC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgICBzZXQoXCJyeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcInJ5XCIsIGdldEgpO1xuICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICAgIHNldChcIndpZHRoXCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwiaGVpZ2h0XCIsIGdldEgpO1xuICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgc2V0KFwieFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcInlcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2lyY2xlXCI6XG4gICAgICAgICAgICBzZXQoXCJjeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImN5XCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwiclwiLCBnZXRXKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICBzZXQoXCJjeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImN5XCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwicnhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJyeVwiLCBnZXRIKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgICAgICBzZXQoXCJ4MVwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcIngyXCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwieTFcIiwgZ2V0SCk7XG4gICAgICAgICAgICBzZXQoXCJ5MlwiLCBnZXRIKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXJrZXJcIjpcbiAgICAgICAgICAgIHNldChcInJlZlhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJtYXJrZXJXaWR0aFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcInJlZllcIiwgZ2V0SCk7XG4gICAgICAgICAgICBzZXQoXCJtYXJrZXJIZWlnaHRcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmFkaWFsR3JhZGllbnRcIjpcbiAgICAgICAgICAgIHNldChcImZ4XCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwiZnlcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidHNwYW5cIjpcbiAgICAgICAgICAgIHNldChcImR4XCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwiZHlcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2V0KG5hbWUsIGdldFcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuLypcXFxuICogU25hcC5zZWxlY3RcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFdyYXBzIGEgRE9NIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IENTUyBzZWxlY3RvciBhcyBARWxlbWVudFxuIC0gcXVlcnkgKHN0cmluZykgQ1NTIHNlbGVjdG9yIG9mIHRoZSBlbGVtZW50XG4gPSAoRWxlbWVudCkgdGhlIGN1cnJlbnQgZWxlbWVudFxuXFwqL1xuU25hcC5zZWxlY3QgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICByZXR1cm4gd3JhcChnbG9iLmRvYy5xdWVyeVNlbGVjdG9yKHF1ZXJ5KSk7XG59O1xuLypcXFxuICogU25hcC5zZWxlY3RBbGxcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFdyYXBzIERPTSBlbGVtZW50cyBzcGVjaWZpZWQgYnkgQ1NTIHNlbGVjdG9yIGFzIHNldCBvciBhcnJheSBvZiBARWxlbWVudFxuIC0gcXVlcnkgKHN0cmluZykgQ1NTIHNlbGVjdG9yIG9mIHRoZSBlbGVtZW50XG4gPSAoRWxlbWVudCkgdGhlIGN1cnJlbnQgZWxlbWVudFxuXFwqL1xuU25hcC5zZWxlY3RBbGwgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICB2YXIgbm9kZWxpc3QgPSBnbG9iLmRvYy5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSxcbiAgICAgICAgc2V0ID0gKFNuYXAuc2V0IHx8IEFycmF5KSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZWxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2V0LnB1c2god3JhcChub2RlbGlzdFtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xufTtcblxuZnVuY3Rpb24gYWRkMmdyb3VwKGxpc3QpIHtcbiAgICBpZiAoIWlzKGxpc3QsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgbGlzdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgfVxuICAgIHZhciBpID0gMCxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgd2hpbGUgKHRoaXNbaV0pIGRlbGV0ZSB0aGlzW2krK107XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpc3RbaV0udHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICBsaXN0W2ldLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChlbC5ub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChsaXN0W2ldLm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpc1tqKytdID0gd3JhcChjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gRWxlbWVudChlbCkge1xuICAgIGlmIChlbC5zbmFwIGluIGh1Yikge1xuICAgICAgICByZXR1cm4gaHViW2VsLnNuYXBdO1xuICAgIH1cbiAgICB2YXIgaWQgPSB0aGlzLmlkID0gSUQoKSxcbiAgICAgICAgc3ZnO1xuICAgIHRyeSB7XG4gICAgICAgIHN2ZyA9IGVsLm93bmVyU1ZHRWxlbWVudDtcbiAgICB9IGNhdGNoKGUpIHt9XG4gICAgdGhpcy5ub2RlID0gZWw7XG4gICAgaWYgKHN2Zykge1xuICAgICAgICB0aGlzLnBhcGVyID0gbmV3IFBhcGVyKHN2Zyk7XG4gICAgfVxuICAgIHRoaXMudHlwZSA9IGVsLnRhZ05hbWU7XG4gICAgdGhpcy5hbmltcyA9IHt9O1xuICAgIHRoaXMuXyA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiBbXVxuICAgIH07XG4gICAgZWwuc25hcCA9IGlkO1xuICAgIGh1YltpZF0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJnXCIpIHtcbiAgICAgICAgdGhpcy5hZGQgPSBhZGQyZ3JvdXA7XG4gICAgICAgIGZvciAodmFyIG1ldGhvZCBpbiBQYXBlci5wcm90b3R5cGUpIGlmIChQYXBlci5wcm90b3R5cGVbaGFzXShtZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZF0gPSBQYXBlci5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFycmF5Rmlyc3RWYWx1ZShhcnIpIHtcbiAgICB2YXIgcmVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHJlcyA9IHJlcyB8fCBhcnJbaV07XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG59XG4oZnVuY3Rpb24gKGVscHJvdG8pIHtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hdHRyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHZXRzIG9yIHNldHMgZ2l2ZW4gYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICAtIHBhcmFtcyAob2JqZWN0KSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgb2YgYXR0cmlidXRlcyB5b3Ugd2FudCB0byBzZXRcbiAgICAgKiBvclxuICAgICAtIHBhcmFtIChzdHJpbmcpIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICogb3JcbiAgICAgPSAoc3RyaW5nKSB2YWx1ZSBvZiBhdHRyaWJ1dGVcbiAgICAgPiBVc2FnZVxuICAgICB8IGVsLmF0dHIoe1xuICAgICB8ICAgICBmaWxsOiBcIiNmYzBcIixcbiAgICAgfCAgICAgc3Ryb2tlOiBcIiMwMDBcIixcbiAgICAgfCAgICAgc3Ryb2tlV2lkdGg6IDIsIC8vIENhbWVsQ2FzZS4uLlxuICAgICB8ICAgICBcImZpbGwtb3BhY2l0eVwiOiAwLjUgLy8gb3IgZGFzaC1zZXBhcmF0ZWQgbmFtZXNcbiAgICAgfCB9KTtcbiAgICAgfCBjb25zb2xlLmxvZyhlbC5hdHRyKFwiZmlsbFwiKSk7IC8vICNmYzBcbiAgICBcXCovXG4gICAgZWxwcm90by5hdHRyID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBlbC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhwYXJhbXMsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGpzb25bcGFyYW1zXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGpzb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUZpcnN0VmFsdWUoZXZlKFwic25hcC51dGlsLmdldGF0dHIuXCIrcGFyYW1zLCBlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGF0dCBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbaGFzXShhdHQpKSB7XG4gICAgICAgICAgICAgICAgZXZlKFwic25hcC51dGlsLmF0dHIuXCIgKyBhdHQsIGVsLCBwYXJhbXNbYXR0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4vLyBTSUVSUkEgRWxlbWVudC5nZXRCQm94KCk6IFVuY2xlYXIgd2h5IHlvdSB3b3VsZCB3YW50IHRvIGV4cHJlc3MgdGhlIGRpbWVuc2lvbiBvZiB0aGUgYm94IGFzIGEgcGF0aC5cbi8vIFNJRVJSQSBFbGVtZW50LmdldEJCb3goKTogVW5jbGVhciB3aHkgeW91IHdvdWxkIHdhbnQgdG8gdXNlIHIwL3IxL3IyLiBBbHNvLCBiYXNpYyBkZWZpbml0aW9uczogd291bGRuJ3QgdGhlIF9zbWFsbGVzdCBjaXJjbGUgdGhhdCBjYW4gYmUgZW5jbG9zZWRfIGJlIGEgemVyby1yYWRpdXMgcG9pbnQ/XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0QkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGRlc2NyaXB0b3IgZm9yIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgYm91bmRpbmcgYm94IGRlc2NyaXB0b3I6XG4gICAgIG8ge1xuICAgICBvICAgICBjeDogKG51bWJlcikgeCBvZiB0aGUgY2VudGVyLFxuICAgICBvICAgICBjeTogKG51bWJlcikgeCBvZiB0aGUgY2VudGVyLFxuICAgICBvICAgICBoOiAobnVtYmVyKSBoZWlnaHQsXG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0LFxuICAgICBvICAgICBwYXRoOiAoc3RyaW5nKSBwYXRoIGNvbW1hbmQgZm9yIHRoZSBib3gsXG4gICAgIG8gICAgIHIwOiAobnVtYmVyKSByYWRpdXMgb2YgYSBjaXJjbGUgdGhhdCBmdWxseSBlbmNsb3NlcyB0aGUgYm94LFxuICAgICBvICAgICByMTogKG51bWJlcikgcmFkaXVzIG9mIHRoZSBzbWFsbGVzdCBjaXJjbGUgdGhhdCBjYW4gYmUgZW5jbG9zZWQsXG4gICAgIG8gICAgIHIyOiAobnVtYmVyKSByYWRpdXMgb2YgdGhlIGxhcmdlc3QgY2lyY2xlIHRoYXQgY2FuIGJlIGVuY2xvc2VkLFxuICAgICBvICAgICB2YjogKHN0cmluZykgYm94IGFzIGEgdmlld2JveCBjb21tYW5kLFxuICAgICBvICAgICB3OiAobnVtYmVyKSB3aWR0aCxcbiAgICAgbyAgICAgd2lkdGg6IChudW1iZXIpIHdpZHRoLFxuICAgICBvICAgICB4MjogKG51bWJlcikgeCBvZiB0aGUgcmlnaHQgc2lkZSxcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBvZiB0aGUgbGVmdCBzaWRlLFxuICAgICBvICAgICB5MjogKG51bWJlcikgeSBvZiB0aGUgYm90dG9tIGVkZ2UsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgb2YgdGhlIHRvcCBlZGdlXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmdldEJCb3ggPSBmdW5jdGlvbiAoaXNXaXRob3V0VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXM7XG4gICAgICAgIGlmIChlbC50eXBlID09IFwidXNlXCIpIHtcbiAgICAgICAgICAgIGVsID0gZWwub3JpZ2luYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgXyA9IGVsLl87XG4gICAgICAgIGlmIChpc1dpdGhvdXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIF8uYmJveHd0ID0gU25hcC5wYXRoLmdldFtlbC50eXBlXSA/IFNuYXAucGF0aC5nZXRCQm94KGVsLnJlYWxQYXRoID0gU25hcC5wYXRoLmdldFtlbC50eXBlXShlbCkpIDogU25hcC5fLmJveChlbC5ub2RlLmdldEJCb3goKSk7XG4gICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveChfLmJib3h3dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5yZWFsUGF0aCA9IChTbmFwLnBhdGguZ2V0W2VsLnR5cGVdIHx8IFNuYXAucGF0aC5nZXQuZGVmbHQpKGVsKTtcbiAgICAgICAgICAgIF8uYmJveCA9IFNuYXAucGF0aC5nZXRCQm94KFNuYXAucGF0aC5tYXAoZWwucmVhbFBhdGgsIGVsLm1hdHJpeCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLl8uYm94KF8uYmJveCk7XG4gICAgfTtcbiAgICB2YXIgcHJvcFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICAgIH07XG4vLyBTSUVSUkEgRWxlbWVudC50cmFuc2Zvcm0oKTogc2VlbXMgdG8gYWxsb3cgdHdvIHJldHVybiB2YWx1ZXMsIG9uZSBvZiB3aGljaCAoX0VsZW1lbnRfKSBpcyB1bmRlZmluZWQuXG4vLyBTSUVSUkEgRWxlbWVudC50cmFuc2Zvcm0oKTogaWYgdGhpcyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LCBpdCdzIHVuY2xlYXIgaG93IGl0IGNhbiBib3RoIF9nZXRfIGFuZCBfc2V0XyBhIHRyYW5zZm9ybS5cbi8vIFNJRVJSQSBFbGVtZW50LnRyYW5zZm9ybSgpOiBVbmNsZWFyIGhvdyBTbmFwIHRyYW5zZm9ybSBzdHJpbmcgZm9ybWF0IGRpZmZlcnMgZnJvbSBTVkcncy5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50cmFuc2Zvcm1cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEdldHMgb3Igc2V0cyB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICAtIHRzdHIgKHN0cmluZykgdHJhbnNmb3JtIHN0cmluZyBpbiBTbmFwIG9yIFNWRyBmb3JtYXRcbiAgICAgPSAoRWxlbWVudCkgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqIG9yXG4gICAgID0gKG9iamVjdCkgdHJhbnNmb3JtYXRpb24gZGVzY3JpcHRvcjpcbiAgICAgbyB7XG4gICAgIG8gICAgIHN0cmluZyAoc3RyaW5nKSB0cmFuc2Zvcm0gc3RyaW5nLFxuICAgICBvICAgICBnbG9iYWxNYXRyaXggKE1hdHJpeCkgbWF0cml4IG9mIGFsbCB0cmFuc2Zvcm1hdGlvbnMgYXBwbGllZCB0byBlbGVtZW50IG9yIGl0cyBwYXJlbnRzLFxuICAgICBvICAgICBsb2NhbE1hdHJpeCAoTWF0cml4KSBtYXRyaXggb2YgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgb25seSB0byB0aGUgZWxlbWVudCxcbiAgICAgbyAgICAgZGlmZk1hdHJpeCAoTWF0cml4KSBtYXRyaXggb2YgZGlmZmVyZW5jZSBiZXR3ZWVuIGdsb2JhbCBhbmQgbG9jYWwgdHJhbnNmb3JtYXRpb25zLFxuICAgICBvICAgICBnbG9iYWwgKHN0cmluZykgZ2xvYmFsIHRyYW5zZm9ybWF0aW9uIGFzIHN0cmluZyxcbiAgICAgbyAgICAgbG9jYWwgKHN0cmluZykgbG9jYWwgdHJhbnNmb3JtYXRpb24gYXMgc3RyaW5nLFxuICAgICBvICAgICB0b1N0cmluZyAoZnVuY3Rpb24pIHJldHVybnMgYHN0cmluZ2AgcHJvcGVydHlcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24gKHRzdHIpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIGlmICh0c3RyID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBnbG9iYWwgPSBuZXcgTWF0cml4KHRoaXMubm9kZS5nZXRDVE0oKSksXG4gICAgICAgICAgICAgICAgbG9jYWwgPSBleHRyYWN0VHJhbnNmb3JtKHRoaXMpLFxuICAgICAgICAgICAgICAgIGxvY2FsU3RyaW5nID0gbG9jYWwudG9UcmFuc2Zvcm1TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBTdHIobG9jYWwpID09IFN0cih0aGlzLm1hdHJpeCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8udHJhbnNmb3JtIDogbG9jYWxTdHJpbmc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICAgICAgICAgIGdsb2JhbE1hdHJpeDogZ2xvYmFsLFxuICAgICAgICAgICAgICAgIGxvY2FsTWF0cml4OiBsb2NhbCxcbiAgICAgICAgICAgICAgICBkaWZmTWF0cml4OiBnbG9iYWwuY2xvbmUoKS5hZGQobG9jYWwuaW52ZXJ0KCkpLFxuICAgICAgICAgICAgICAgIGdsb2JhbDogZ2xvYmFsLnRvVHJhbnNmb3JtU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbG9jYWw6IGxvY2FsU3RyaW5nLFxuICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBwcm9wU3RyaW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0c3RyIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICAvLyBtYXkgYmUgbmVlZCB0byBhcHBseSBpdCBkaXJlY3RseVxuICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGVcbiAgICAgICAgICAgIHRzdHIgPSB0c3RyLnRvVHJhbnNmb3JtU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmFjdFRyYW5zZm9ybSh0aGlzLCB0c3RyKTtcblxuICAgICAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIiB8fCB0aGlzLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtncmFkaWVudFRyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09IFwicGF0dGVyblwiKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtwYXR0ZXJuVHJhbnNmb3JtOiB0aGlzLm1hdHJpeH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMubm9kZSwge3RyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucGFyZW50XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50J3MgcGFyZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGhpcy5ub2RlLnBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYXBwZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBlbGVtZW50IHRvIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnR8U2V0KSBlbGVtZW50IHRvIGFwcGVuZFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWRkXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuYXBwZW5kXG4gICAgXFwqL1xuICAgIGVscHJvdG8uYXBwZW5kID0gZWxwcm90by5hZGQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBlbC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5hZGQoZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChlbC5ub2RlKTtcbiAgICAgICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFwcGVuZFRvXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBcHBlbmRzIHRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBwYXJlbnQgZWxlbWVudCB0byBhcHBlbmQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIGNoaWxkIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5hcHBlbmRUbyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgICAgICBlbC5hcHBlbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5wcmVwZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gZWxlbWVudCB0byB0aGUgY3VycmVudCBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgZWxlbWVudCB0byBwcmVwZW5kXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnByZXBlbmQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBlbCA9IHdyYXAoZWwpO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudCgpO1xuICAgICAgICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShlbC5ub2RlLCB0aGlzLm5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmFkZCAmJiB0aGlzLmFkZCgpO1xuICAgICAgICAgICAgZWwucGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmFkZCgpO1xuICAgICAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnByZXBlbmRUb1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUHJlcGVuZHMgdGhlIGN1cnJlbnQgZWxlbWVudCB0byB0aGUgZ2l2ZW4gb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnQpIHBhcmVudCBlbGVtZW50IHRvIHByZXBlbmQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIGNoaWxkIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5wcmVwZW5kVG8gPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgZWwucHJlcGVuZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5iZWZvcmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgZ2l2ZW4gZWxlbWVudCBiZWZvcmUgdGhlIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnQpIGVsZW1lbnQgdG8gaW5zZXJ0XG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmJlZm9yZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoZWwudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICB2YXIgaXQgPSB0aGlzO1xuICAgICAgICAgICAgZWwuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgaXQubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbC5ub2RlLCBpdC5ub2RlKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFkZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCgpLmFkZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudCgpO1xuICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwubm9kZSwgdGhpcy5ub2RlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmFkZCgpO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFkZCgpO1xuICAgICAgICBlbC5wYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWZ0ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgZ2l2ZW4gZWxlbWVudCBhZnRlciB0aGUgY3VycmVudCBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgZWxlbWVudCB0byBpbnNlcnRcbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYWZ0ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudCgpO1xuICAgICAgICBpZiAodGhpcy5ub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwubm9kZSwgdGhpcy5ub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsLm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgZWwucGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lmluc2VydEJlZm9yZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSW5zZXJ0cyB0aGUgZWxlbWVudCBhZnRlciB0aGUgZ2l2ZW4gb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnQpIGVsZW1lbnQgbmV4dCB0byB3aG9tIGluc2VydCB0b1xuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50KCk7XG4gICAgICAgIGVsLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLCBlbC5ub2RlKTtcbiAgICAgICAgdGhpcy5wYXBlciA9IGVsLnBhcGVyO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFkZCgpO1xuICAgICAgICBlbC5wYXJlbnQoKSAmJiBlbC5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5pbnNlcnRBZnRlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSW5zZXJ0cyB0aGUgZWxlbWVudCBhZnRlciB0aGUgZ2l2ZW4gb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnQpIGVsZW1lbnQgbmV4dCB0byB3aG9tIGluc2VydCB0b1xuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbCA9IHdyYXAoZWwpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgZWwubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm5vZGUsIGVsLm5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB0aGlzLnBhcGVyID0gZWwucGFwZXI7XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIGVsLnBhcmVudCgpICYmIGVsLnBhcmVudCgpLmFkZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnJlbW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50IGZyb20gdGhlIERPTVxuICAgICA9IChFbGVtZW50KSB0aGUgZGV0YWNoZWQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50KCk7XG4gICAgICAgIHRoaXMubm9kZS5wYXJlbnROb2RlICYmIHRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhcGVyO1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFkZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnNlbGVjdFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2F0aGVycyB0aGUgbmVzdGVkIEBFbGVtZW50IG1hdGNoaW5nIHRoZSBnaXZlbiBzZXQgb2YgQ1NTIHNlbGVjdG9yc1xuICAgICAqKlxuICAgICAtIHF1ZXJ5IChzdHJpbmcpIENTUyBzZWxlY3RvclxuICAgICA9IChFbGVtZW50KSByZXN1bHQgb2YgcXVlcnkgc2VsZWN0aW9uXG4gICAgXFwqL1xuICAgIGVscHJvdG8uc2VsZWN0ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB3cmFwKHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKHF1ZXJ5KSk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5zZWxlY3RBbGxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEdhdGhlcnMgbmVzdGVkIEBFbGVtZW50IG9iamVjdHMgbWF0Y2hpbmcgdGhlIGdpdmVuIHNldCBvZiBDU1Mgc2VsZWN0b3JzXG4gICAgICoqXG4gICAgIC0gcXVlcnkgKHN0cmluZykgQ1NTIHNlbGVjdG9yXG4gICAgID0gKFNldHxhcnJheSkgcmVzdWx0IG9mIHF1ZXJ5IHNlbGVjdGlvblxuICAgIFxcKi9cbiAgICBlbHByb3RvLnNlbGVjdEFsbCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgbm9kZWxpc3QgPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSksXG4gICAgICAgICAgICBzZXQgPSAoU25hcC5zZXQgfHwgQXJyYXkpKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZWxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNldC5wdXNoKHdyYXAobm9kZWxpc3RbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYXNQWFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBnaXZlbiBhdHRyaWJ1dGUgb2YgdGhlIGVsZW1lbnQgYXMgYSBgcHhgIHZhbHVlIChub3QgJSwgZW0sIGV0Yy4pXG4gICAgICoqXG4gICAgIC0gYXR0ciAoc3RyaW5nKSBhdHRyaWJ1dGUgbmFtZVxuICAgICAtIHZhbHVlIChzdHJpbmcpICNvcHRpb25hbCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgPSAoRWxlbWVudCkgcmVzdWx0IG9mIHF1ZXJ5IHNlbGVjdGlvblxuICAgIFxcKi9cbiAgICBlbHByb3RvLmFzUFggPSBmdW5jdGlvbiAoYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5hdHRyKGF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiArdW5pdDJweCh0aGlzLCBhdHRyLCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvLyBTSUVSUkEgRWxlbWVudC51c2UoKTogSSBzdWdnZXN0IGFkZGluZyBhIG5vdGUgYWJvdXQgaG93IHRvIGFjY2VzcyB0aGUgb3JpZ2luYWwgZWxlbWVudCB0aGUgcmV0dXJuZWQgPHVzZT4gaW5zdGFudGlhdGVzLiBJdCdzIGEgcGFydCBvZiBTVkcgd2l0aCB3aGljaCBvcmRpbmFyeSB3ZWIgZGV2ZWxvcGVycyBtYXkgYmUgbGVhc3QgZmFtaWxpYXIuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudXNlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgYDx1c2U+YCBlbGVtZW50IGxpbmtlZCB0byB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBgPHVzZT5gIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by51c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1c2UsXG4gICAgICAgICAgICBpZCA9IHRoaXMubm9kZS5pZDtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgaWQgPSB0aGlzLmlkO1xuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJsaW5lYXJHcmFkaWVudFwiIHx8IHRoaXMudHlwZSA9PSBcInJhZGlhbEdyYWRpZW50XCIgfHxcbiAgICAgICAgICAgIHRoaXMudHlwZSA9PSBcInBhdHRlcm5cIikge1xuICAgICAgICAgICAgdXNlID0gbWFrZSh0aGlzLnR5cGUsIHRoaXMubm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVzZSA9IG1ha2UoXCJ1c2VcIiwgdGhpcy5ub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgICQodXNlLm5vZGUsIHtcbiAgICAgICAgICAgIFwieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkXG4gICAgICAgIH0pO1xuICAgICAgICB1c2Uub3JpZ2luYWwgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdXNlO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuY2xvbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZWxlbWVudCBhbmQgaW5zZXJ0cyBpdCBhZnRlciB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgY2xvbmVcbiAgICBcXCovXG4gICAgZnVuY3Rpb24gZml4aWRzKGVsKSB7XG4gICAgICAgIHZhciBlbHMgPSBlbC5zZWxlY3RBbGwoXCIqXCIpLFxuICAgICAgICAgICAgaXQsXG4gICAgICAgICAgICB1cmwgPSAvXlxccyp1cmxcXCgoXCJ8J3wpKC4qKVxcMVxcKVxccyokLyxcbiAgICAgICAgICAgIGlkcyA9IFtdLFxuICAgICAgICAgICAgdXNlcyA9IHt9O1xuICAgICAgICBmdW5jdGlvbiB1cmx0ZXN0KGl0LCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gJChpdC5ub2RlLCBuYW1lKTtcbiAgICAgICAgICAgIHZhbCA9IHZhbCAmJiB2YWwubWF0Y2godXJsKTtcbiAgICAgICAgICAgIHZhbCA9IHZhbCAmJiB2YWxbMl07XG4gICAgICAgICAgICBpZiAodmFsICYmIHZhbC5jaGFyQXQoKSA9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB1c2VzW3ZhbF0gPSAodXNlc1t2YWxdIHx8IFtdKS5jb25jYXQoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgICAgICAgICAgICAgIGF0dHJbbmFtZV0gPSBVUkwoaWQpO1xuICAgICAgICAgICAgICAgICAgICAkKGl0Lm5vZGUsIGF0dHIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxpbmt0ZXN0KGl0KSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gJChpdC5ub2RlLCBcInhsaW5rOmhyZWZcIik7XG4gICAgICAgICAgICBpZiAodmFsICYmIHZhbC5jaGFyQXQoKSA9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB1c2VzW3ZhbF0gPSAodXNlc1t2YWxdIHx8IFtdKS5jb25jYXQoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LmF0dHIoXCJ4bGluazpocmVmXCIsIFwiI1wiICsgaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVscy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpdCA9IGVsc1tpXTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwiZmlsbFwiKTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwic3Ryb2tlXCIpO1xuICAgICAgICAgICAgdXJsdGVzdChpdCwgXCJmaWx0ZXJcIik7XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcIm1hc2tcIik7XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcImNsaXAtcGF0aFwiKTtcbiAgICAgICAgICAgIGxpbmt0ZXN0KGl0KTtcbiAgICAgICAgICAgIHZhciBvbGRpZCA9ICQoaXQubm9kZSwgXCJpZFwiKTtcbiAgICAgICAgICAgIGlmIChvbGRpZCkge1xuICAgICAgICAgICAgICAgICQoaXQubm9kZSwge2lkOiBpdC5pZH0pO1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb2xkOiBvbGRpZCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBpZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZzID0gdXNlc1tpZHNbaV0ub2xkXTtcbiAgICAgICAgICAgIGlmIChmcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGZzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZnNbal0oaWRzW2ldLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxwcm90by5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcCh0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgaWYgKCQoY2xvbmUubm9kZSwgXCJpZFwiKSkge1xuICAgICAgICAgICAgJChjbG9uZS5ub2RlLCB7aWQ6IGNsb25lLmlkfSk7XG4gICAgICAgIH1cbiAgICAgICAgZml4aWRzKGNsb25lKTtcbiAgICAgICAgY2xvbmUuaW5zZXJ0QWZ0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuLy8gU0lFUlJBIEVsZW1lbnQudG9EZWZzKCk6IElmIHRoaXMgX21vdmVzXyBhbiBlbGVtZW50IHRvIHRoZSA8ZGVmcz4gcmVnaW9uLCB3aHkgaXMgdGhlIHJldHVybiB2YWx1ZSBhIF9jbG9uZV8/IEFsc28gdW5jbGVhciB3aHkgaXQncyBjYWxsZWQgdGhlIF9yZWxhdGl2ZV8gPGRlZnM+IHNlY3Rpb24uIFBlcmhhcHMgX3NoYXJlZF8/XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9EZWZzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBNb3ZlcyBlbGVtZW50IHRvIHRoZSBzaGFyZWQgYDxkZWZzPmAgYXJlYVxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgY2xvbmVcbiAgICBcXCovXG4gICAgZWxwcm90by50b0RlZnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZzID0gZ2V0U29tZURlZnModGhpcyk7XG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbi8vIFNJRVJSQSBFbGVtZW50LnBhdHRlcm4oKTogeC95L3dpZHRoL2hlaWdodCBkYXRhIHR5cGVzIGFyZSBsaXN0ZWQgYXMgYm90aCBTdHJpbmcgYW5kIE51bWJlci4gSXMgdGhhdCBhbiBlcnJvciwgb3IgZG9lcyBpdCBtZWFuIHN0cmluZ3MgYXJlIGNvZXJjZWQ/XG4vLyBTSUVSUkEgRWxlbWVudC5wYXR0ZXJuKCk6IGNsYXJpZnkgdGhhdCB4L3kgYXJlIG9mZnNldHMgdGhhdCBlLmcuLCBtYXkgYWRkIGd1dHRlcnMgYmV0d2VlbiB0aGUgdGlsZXMuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucGF0dGVyblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGA8cGF0dGVybj5gIGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgICogVG8gY3JlYXRlIGEgcGF0dGVybiB5b3UgaGF2ZSB0byBzcGVjaWZ5IHRoZSBwYXR0ZXJuIHJlY3Q6XG4gICAgIC0geCAoc3RyaW5nfG51bWJlcilcbiAgICAgLSB5IChzdHJpbmd8bnVtYmVyKVxuICAgICAtIHdpZHRoIChzdHJpbmd8bnVtYmVyKVxuICAgICAtIGhlaWdodCAoc3RyaW5nfG51bWJlcilcbiAgICAgPSAoRWxlbWVudCkgdGhlIGA8cGF0dGVybj5gIGVsZW1lbnRcbiAgICAgKiBZb3UgY2FuIHVzZSBwYXR0ZXJuIGxhdGVyIG9uIGFzIGFuIGFyZ3VtZW50IGZvciBgZmlsbGAgYXR0cmlidXRlOlxuICAgICB8IHZhciBwID0gcGFwZXIucGF0aChcIk0xMC01LTEwLDE1TTE1LDAsMCwxNU0wLTUtMjAsMTVcIikuYXR0cih7XG4gICAgIHwgICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgfCAgICAgICAgIHN0cm9rZTogXCIjYmFkYTU1XCIsXG4gICAgIHwgICAgICAgICBzdHJva2VXaWR0aDogNVxuICAgICB8ICAgICB9KS5wYXR0ZXJuKDAsIDAsIDEwLCAxMCksXG4gICAgIHwgICAgIGMgPSBwYXBlci5jaXJjbGUoMjAwLCAyMDAsIDEwMCk7XG4gICAgIHwgYy5hdHRyKHtcbiAgICAgfCAgICAgZmlsbDogcFxuICAgICB8IH0pO1xuICAgIFxcKi9cbiAgICBlbHByb3RvLnBhdHRlcm4gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IG1ha2UoXCJwYXR0ZXJuXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSAmJiBcInhcIiBpbiB4KSB7XG4gICAgICAgICAgICB5ID0geC55O1xuICAgICAgICAgICAgd2lkdGggPSB4LndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0geC5oZWlnaHQ7XG4gICAgICAgICAgICB4ID0geC54O1xuICAgICAgICB9XG4gICAgICAgICQocC5ub2RlLCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsXG4gICAgICAgICAgICBpZDogcC5pZCxcbiAgICAgICAgICAgIHZpZXdCb3g6IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XS5qb2luKFwiIFwiKVxuICAgICAgICB9KTtcbiAgICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG4vLyBTSUVSUkEgRWxlbWVudC5tYXJrZXIoKTogY2xhcmlmeSB3aGF0IGEgcmVmZXJlbmNlIHBvaW50IGlzLiBFLmcuLCBoZWxwcyB5b3Ugb2Zmc2V0IHRoZSBvYmplY3QgZnJvbSBpdHMgZWRnZSBzdWNoIGFzIHdoZW4gY2VudGVyaW5nIGl0IG92ZXIgYSBwYXRoLlxuLy8gU0lFUlJBIEVsZW1lbnQubWFya2VyKCk6IEkgc3VnZ2VzdCB0aGUgbWV0aG9kIHNob3VsZCBhY2NlcHQgZGVmYXVsdCByZWZlcmVuY2UgcG9pbnQgdmFsdWVzLiAgUGVyaGFwcyBjZW50ZXJlZCB3aXRoIChyZWZYID0gd2lkdGgvMikgYW5kIChyZWZZID0gaGVpZ2h0LzIpPyBBbHNvLCBjb3VsZG4ndCBpdCBhc3N1bWUgdGhlIGVsZW1lbnQncyBjdXJyZW50IF93aWR0aF8gYW5kIF9oZWlnaHRfPyBBbmQgcGxlYXNlIHNwZWNpZnkgd2hhdCBfeF8gYW5kIF95XyBtZWFuOiBvZmZzZXRzPyBJZiBzbywgZnJvbSB3aGVyZT8gIENvdWxkbid0IHRoZXkgYWxzbyBiZSBhc3NpZ25lZCBkZWZhdWx0IHZhbHVlcz9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tYXJrZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPG1hcmtlcj5gIGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgICogVG8gY3JlYXRlIGEgbWFya2VyIHlvdSBoYXZlIHRvIHNwZWNpZnkgdGhlIGJvdW5kaW5nIHJlY3QgYW5kIHJlZmVyZW5jZSBwb2ludDpcbiAgICAgLSB4IChudW1iZXIpXG4gICAgIC0geSAobnVtYmVyKVxuICAgICAtIHdpZHRoIChudW1iZXIpXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpXG4gICAgIC0gcmVmWCAobnVtYmVyKVxuICAgICAtIHJlZlkgKG51bWJlcilcbiAgICAgPSAoRWxlbWVudCkgdGhlIGA8bWFya2VyPmAgZWxlbWVudFxuICAgICAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgbWFya2VyIGxhdGVyIGFzIGFuIGFyZ3VtZW50IGZvciBgbWFya2VyLXN0YXJ0YCwgYG1hcmtlci1lbmRgLCBgbWFya2VyLW1pZGAsIGFuZCBgbWFya2VyYCBhdHRyaWJ1dGVzLiBUaGUgYG1hcmtlcmAgYXR0cmlidXRlIHBsYWNlcyB0aGUgbWFya2VyIGF0IGV2ZXJ5IHBvaW50IGFsb25nIHRoZSBwYXRoLCBhbmQgYG1hcmtlci1taWRgIHBsYWNlcyB0aGVtIGF0IGV2ZXJ5IHBvaW50IGV4Y2VwdCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAgICBcXCovXG4gICAgLy8gVE9ETyBhZGQgdXNhZ2UgZm9yIG1hcmtlcnNcbiAgICBlbHByb3RvLm1hcmtlciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZWZYLCByZWZZKSB7XG4gICAgICAgIHZhciBwID0gbWFrZShcIm1hcmtlclwiLCBnZXRTb21lRGVmcyh0aGlzKSk7XG4gICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmdldEJCb3goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoeCwgXCJvYmplY3RcIikgJiYgXCJ4XCIgaW4geCkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHdpZHRoID0geC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgcmVmWCA9IHgucmVmWCB8fCB4LmN4O1xuICAgICAgICAgICAgcmVmWSA9IHgucmVmWSB8fCB4LmN5O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuICAgICAgICAkKHAubm9kZSwge1xuICAgICAgICAgICAgdmlld0JveDogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oUyksXG4gICAgICAgICAgICBtYXJrZXJXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICBtYXJrZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIG9yaWVudDogXCJhdXRvXCIsXG4gICAgICAgICAgICByZWZYOiByZWZYIHx8IDAsXG4gICAgICAgICAgICByZWZZOiByZWZZIHx8IDAsXG4gICAgICAgICAgICBpZDogcC5pZFxuICAgICAgICB9KTtcbiAgICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG4gICAgLy8gYW5pbWF0aW9uXG4gICAgZnVuY3Rpb24gc2xpY2UoZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBhcnIuc2xpY2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmID8gZihyZXMpIDogcmVzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKGF0dHIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWFzaW5nID09IFwiZnVuY3Rpb25cIiAmJiAhZWFzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICBlYXNpbmcgPSBtaW5hLmxpbmVhcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLmR1ciA9IG1zO1xuICAgICAgICBlYXNpbmcgJiYgKHRoaXMuZWFzaW5nID0gZWFzaW5nKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgKHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBTSUVSUkEgQWxsIG9iamVjdCBtZXRob2RzIHNob3VsZCBmZWF0dXJlIHNhbXBsZSBjb2RlLiBUaGlzIGlzIGp1c3Qgb25lIGluc3RhbmNlLlxuICAgIC8qXFxcbiAgICAgKiBTbmFwLmFuaW1hdGlvblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhbiBhbmltYXRpb24gb2JqZWN0XG4gICAgICoqXG4gICAgIC0gYXR0ciAob2JqZWN0KSBhdHRyaWJ1dGVzIG9mIGZpbmFsIGRlc3RpbmF0aW9uXG4gICAgIC0gZHVyYXRpb24gKG51bWJlcikgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiwgaW4gbWlsbGlzZWNvbmRzXG4gICAgIC0gZWFzaW5nIChmdW5jdGlvbikgI29wdGlvbmFsIG9uZSBvZiBlYXNpbmcgZnVuY3Rpb25zIG9mIEBtaW5hIG9yIGN1c3RvbSBvbmVcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pICNvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGZpcmVzIHdoZW4gYW5pbWF0aW9uIGVuZHNcbiAgICAgPSAob2JqZWN0KSBhbmltYXRpb24gb2JqZWN0XG4gICAgXFwqL1xuICAgIFNuYXAuYW5pbWF0aW9uID0gZnVuY3Rpb24gKGF0dHIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGF0dHIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmluQW5pbVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhIHNldCBvZiBhbmltYXRpb25zIHRoYXQgbWF5IGJlIGFibGUgdG8gbWFuaXB1bGF0ZSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgaW4gZm9ybWF0OlxuICAgICBvIHtcbiAgICAgbyAgICAgYW5pbSAob2JqZWN0KSBhbmltYXRpb24gb2JqZWN0LFxuICAgICBvICAgICBjdXJTdGF0dXMgKG51bWJlcikgMC4uMSDigJQgc3RhdHVzIG9mIHRoZSBhbmltYXRpb246IDAg4oCUIGp1c3Qgc3RhcnRlZCwgMSDigJQganVzdCBmaW5pc2hlZCxcbiAgICAgbyAgICAgc3RhdHVzIChmdW5jdGlvbikgZ2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RvcCAoZnVuY3Rpb24pIHN0b3BzIHRoZSBhbmltYXRpb25cbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5BbmltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLFxuICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGlkIGluIGVsLmFuaW1zKSBpZiAoZWwuYW5pbXNbaGFzXShpZCkpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbTogbmV3IEFuaW1hdGlvbihhLl9hdHRycywgYS5kdXIsIGEuZWFzaW5nLCBhLl9jYWxsYmFjayksXG4gICAgICAgICAgICAgICAgICAgIGN1clN0YXR1czogYS5zdGF0dXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGF0dXModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0oZWwuYW5pbXNbaWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmFuaW1hdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJ1bnMgZ2VuZXJpYyBhbmltYXRpb24gb2Ygb25lIG51bWJlciBpbnRvIGFub3RoZXIgd2l0aCBhIGNhcmluZyBmdW5jdGlvblxuICAgICAqKlxuICAgICAtIGZyb20gKG51bWJlcnxhcnJheSkgbnVtYmVyIG9yIGFycmF5IG9mIG51bWJlcnNcbiAgICAgLSB0byAobnVtYmVyfGFycmF5KSBudW1iZXIgb3IgYXJyYXkgb2YgbnVtYmVyc1xuICAgICAtIHNldHRlciAoZnVuY3Rpb24pIGNhcmluZyBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG51bWJlciBhcmd1bWVudFxuICAgICAtIGR1cmF0aW9uIChudW1iZXIpIGR1cmF0aW9uLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIGZyb20gQG1pbmEgb3IgY3VzdG9tXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGFuaW1hdGlvbiBlbmRzXG4gICAgID0gKG9iamVjdCkgYW5pbWF0aW9uIG9iamVjdCBpbiBAbWluYSBmb3JtYXRcbiAgICAgbyB7XG4gICAgIG8gICAgIGlkIChzdHJpbmcpIGFuaW1hdGlvbiBpZCwgY29uc2lkZXIgaXQgcmVhZC1vbmx5LFxuICAgICBvICAgICBkdXJhdGlvbiAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgZWFzaW5nIChmdW5jdGlvbikgZWFzaW5nLFxuICAgICBvICAgICBzcGVlZCAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgc3BlZWQgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RhdHVzIChmdW5jdGlvbikgZ2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RvcCAoZnVuY3Rpb24pIHN0b3BzIHRoZSBhbmltYXRpb25cbiAgICAgbyB9XG4gICAgIHwgdmFyIHJlY3QgPSBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApO1xuICAgICB8IFNuYXAuYW5pbWF0ZSgwLCAxMCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICB8ICAgICByZWN0LmF0dHIoe1xuICAgICB8ICAgICAgICAgeDogdmFsXG4gICAgIHwgICAgIH0pO1xuICAgICB8IH0sIDEwMDApO1xuICAgICB8IC8vIGluIGdpdmVuIGNvbnRleHQgaXMgZXF1aXZhbGVudCB0b1xuICAgICB8IHJlY3QuYW5pbWF0ZSh7eDogMTB9LCAxMDAwKTtcbiAgICBcXCovXG4gICAgU25hcC5hbmltYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCBzZXR0ZXIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWFzaW5nID09IFwiZnVuY3Rpb25cIiAmJiAhZWFzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICBlYXNpbmcgPSBtaW5hLmxpbmVhcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gbWluYS50aW1lKCksXG4gICAgICAgICAgICBhbmltID0gbWluYShmcm9tLCB0bywgbm93LCBub3cgKyBtcywgbWluYS50aW1lLCBzZXR0ZXIsIGVhc2luZyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGV2ZS5vbmNlKFwibWluYS5maW5pc2guXCIgKyBhbmltLmlkLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBhbmltO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU3RvcHMgYWxsIHRoZSBhbmltYXRpb25zIGZvciB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5pbXMgPSB0aGlzLmluQW5pbSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhbmltcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBhbmltc1tpXS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBTSUVSUkEgRWxlbWVudC5hbmltYXRlKCk6IEZvciBfYXR0cnNfLCBjbGFyaWZ5IGlmIHRoZXkgcmVwcmVzZW50IHRoZSBkZXN0aW5hdGlvbiB2YWx1ZXMsIGFuZCBpZiB0aGUgYW5pbWF0aW9uIGV4ZWN1dGVzIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50J3MgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgIC8vIFNJRVJSQSB3b3VsZCBhIF9jdXN0b21fIGFuaW1hdGlvbiBmdW5jdGlvbiBiZSBhbiBTVkcga2V5U3BsaW5lcyB2YWx1ZT9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hbmltYXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBbmltYXRlcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICAtIGF0dHJzIChvYmplY3QpIGtleS12YWx1ZSBwYWlycyBvZiBkZXN0aW5hdGlvbiBhdHRyaWJ1dGVzXG4gICAgIC0gZHVyYXRpb24gKG51bWJlcikgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIGZyb20gQG1pbmEgb3IgY3VzdG9tXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB3aGVuIHRoZSBhbmltYXRpb24gZW5kc1xuICAgICA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChhdHRycywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIEFuaW1hdGlvbikge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhdHRycy5jYWxsYmFjaztcbiAgICAgICAgICAgIGVhc2luZyA9IGF0dHJzLmVhc2luZztcbiAgICAgICAgICAgIG1zID0gZWFzaW5nLmR1cjtcbiAgICAgICAgICAgIGF0dHJzID0gYXR0cnMuYXR0cjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmtleXMgPSBbXSwgdGtleXMgPSBbXSwga2V5cyA9IHt9LCBmcm9tLCB0bywgZiwgZXEsXG4gICAgICAgICAgICBlbCA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykgaWYgKGF0dHJzW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgaWYgKGVsLmVxdWFsKSB7XG4gICAgICAgICAgICAgICAgZXEgPSBlbC5lcXVhbChrZXksIFN0cihhdHRyc1trZXldKSk7XG4gICAgICAgICAgICAgICAgZnJvbSA9IGVxLmZyb207XG4gICAgICAgICAgICAgICAgdG8gPSBlcS50bztcbiAgICAgICAgICAgICAgICBmID0gZXEuZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9ICtlbC5hdHRyKGtleSk7XG4gICAgICAgICAgICAgICAgdG8gPSArYXR0cnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW4gPSBpcyhmcm9tLCBcImFycmF5XCIpID8gZnJvbS5sZW5ndGggOiAxO1xuICAgICAgICAgICAga2V5c1trZXldID0gc2xpY2UoZmtleXMubGVuZ3RoLCBma2V5cy5sZW5ndGggKyBsZW4sIGYpO1xuICAgICAgICAgICAgZmtleXMgPSBma2V5cy5jb25jYXQoZnJvbSk7XG4gICAgICAgICAgICB0a2V5cyA9IHRrZXlzLmNvbmNhdCh0byk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vdyA9IG1pbmEudGltZSgpLFxuICAgICAgICAgICAgYW5pbSA9IG1pbmEoZmtleXMsIHRrZXlzLCBub3csIG5vdyArIG1zLCBtaW5hLnRpbWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlzKSBpZiAoa2V5c1toYXNdKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cltrZXldID0ga2V5c1trZXldKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLmF0dHIoYXR0cik7XG4gICAgICAgICAgICB9LCBlYXNpbmcpO1xuICAgICAgICBlbC5hbmltc1thbmltLmlkXSA9IGFuaW07XG4gICAgICAgIGFuaW0uX2F0dHJzID0gYXR0cnM7XG4gICAgICAgIGFuaW0uX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIGV2ZS5vbmNlKFwibWluYS5maW5pc2guXCIgKyBhbmltLmlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWxldGUgZWwuYW5pbXNbYW5pbS5pZF07XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZS5vbmNlKFwibWluYS5zdG9wLlwiICsgYW5pbS5pZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsLmFuaW1zW2FuaW0uaWRdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgdmFyIGVsZGF0YSA9IHt9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmRhdGFcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgb3IgcmV0cmlldmVzIGdpdmVuIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBnaXZlbiBrZXkuIChEb27igJl0IGNvbmZ1c2VcbiAgICAgKiB3aXRoIGBkYXRhLWAgYXR0cmlidXRlcylcbiAgICAgKlxuICAgICAqIFNlZSBhbHNvIEBFbGVtZW50LnJlbW92ZURhdGFcbiAgICAgLSBrZXkgKHN0cmluZykga2V5IHRvIHN0b3JlIGRhdGFcbiAgICAgLSB2YWx1ZSAoYW55KSAjb3B0aW9uYWwgdmFsdWUgdG8gc3RvcmVcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgICAqIG9yLCBpZiB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkOlxuICAgICA9IChhbnkpIHZhbHVlXG4gICAgID4gVXNhZ2VcbiAgICAgfCBmb3IgKHZhciBpID0gMCwgaSA8IDUsIGkrKykge1xuICAgICB8ICAgICBwYXBlci5jaXJjbGUoMTAgKyAxNSAqIGksIDEwLCAxMClcbiAgICAgfCAgICAgICAgICAuYXR0cih7ZmlsbDogXCIjMDAwXCJ9KVxuICAgICB8ICAgICAgICAgIC5kYXRhKFwiaVwiLCBpKVxuICAgICB8ICAgICAgICAgIC5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgIHwgICAgICAgICAgICAgYWxlcnQodGhpcy5kYXRhKFwiaVwiKSk7XG4gICAgIHwgICAgICAgICAgfSk7XG4gICAgIHwgfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmRhdGEgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IGVsZGF0YVt0aGlzLmlkXSA9IGVsZGF0YVt0aGlzLmlkXSB8fCB7fTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRhdGEuZ2V0LlwiICsgdGhpcy5pZCwgdGhpcywgZGF0YSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoU25hcC5pcyhrZXksIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBrZXkpIGlmIChrZXlbaGFzXShpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEoaSwga2V5W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRhdGEuZ2V0LlwiICsgdGhpcy5pZCwgdGhpcywgZGF0YVtrZXldLCBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgZXZlKFwic25hcC5kYXRhLnNldC5cIiArIHRoaXMuaWQsIHRoaXMsIHZhbHVlLCBrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnJlbW92ZURhdGFcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGFuIGVsZW1lbnQgYnkgZ2l2ZW4ga2V5LlxuICAgICAqIElmIGtleSBpcyBub3QgcHJvdmlkZWQsIHJlbW92ZXMgYWxsIHRoZSBkYXRhIG9mIHRoZSBlbGVtZW50LlxuICAgICAtIGtleSAoc3RyaW5nKSAjb3B0aW9uYWwga2V5XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5yZW1vdmVEYXRhID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGVsZGF0YVt0aGlzLmlkXSA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxkYXRhW3RoaXMuaWRdICYmIGRlbGV0ZSBlbGRhdGFbdGhpcy5pZF1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm91dGVyU1ZHXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIFNWRyBjb2RlIGZvciB0aGUgZWxlbWVudCwgZXF1aXZhbGVudCB0byBIVE1MJ3MgYG91dGVySFRNTGAuXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbyBARWxlbWVudC5pbm5lclNWR1xuICAgICA9IChzdHJpbmcpIFNWRyBjb2RlIGZvciB0aGUgZWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b1N0cmluZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBFbGVtZW50Lm91dGVyU1ZHXG4gICAgXFwqL1xuICAgIGVscHJvdG8ub3V0ZXJTVkcgPSBlbHByb3RvLnRvU3RyaW5nID0gdG9TdHJpbmcoMSk7XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5uZXJTVkdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgU1ZHIGNvZGUgZm9yIHRoZSBlbGVtZW50J3MgY29udGVudHMsIGVxdWl2YWxlbnQgdG8gSFRNTCdzIGBpbm5lckhUTUxgXG4gICAgID0gKHN0cmluZykgU1ZHIGNvZGUgZm9yIHRoZSBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5uZXJTVkcgPSB0b1N0cmluZygpO1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB0eXBlID8gXCI8XCIgKyB0aGlzLnR5cGUgOiBcIlwiLFxuICAgICAgICAgICAgICAgIGF0dHIgPSB0aGlzLm5vZGUuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBjaGxkID0gdGhpcy5ub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGF0dHIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCIgXCIgKyBhdHRyW2ldLm5hbWUgKyAnPVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cltpXS52YWx1ZS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHR5cGUgJiYgKHJlcyArPSBcIj5cIik7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBjaGxkLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNobGRbaV0ubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IGNobGRbaV0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNobGRbaV0ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IHdyYXAoY2hsZFtpXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eXBlICYmIChyZXMgKz0gXCI8L1wiICsgdGhpcy50eXBlICsgXCI+XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlICYmIChyZXMgKz0gXCIvPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxufShFbGVtZW50LnByb3RvdHlwZSkpO1xuLy8gU0lFUlJBIFNuYXAucGFyc2UoKSBhY2NlcHRzICYgcmV0dXJucyBhIGZyYWdtZW50LCBidXQgdGhlcmUncyBubyBpbmZvIG9uIHdoYXQgaXQgZG9lcyBpbiBiZXR3ZWVuLiBXaGF0IGlmIGl0IGRvZXNuJ3QgcGFyc2U/XG4vKlxcXG4gKiBTbmFwLnBhcnNlXG4gWyBtZXRob2QgXVxuICoqXG4gKiBQYXJzZXMgU1ZHIGZyYWdtZW50IGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgQEZyYWdtZW50XG4gKipcbiAtIHN2ZyAoc3RyaW5nKSBTVkcgc3RyaW5nXG4gPSAoRnJhZ21lbnQpIHRoZSBARnJhZ21lbnRcblxcKi9cblNuYXAucGFyc2UgPSBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgdmFyIGYgPSBnbG9iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIGZ1bGwgPSB0cnVlLFxuICAgICAgICBkaXYgPSBnbG9iLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHN2ZyA9IFN0cihzdmcpO1xuICAgIGlmICghc3ZnLm1hdGNoKC9eXFxzKjxcXHMqc3ZnKD86XFxzfD4pLykpIHtcbiAgICAgICAgc3ZnID0gXCI8c3ZnPlwiICsgc3ZnICsgXCI8L3N2Zz5cIjtcbiAgICAgICAgZnVsbCA9IGZhbHNlO1xuICAgIH1cbiAgICBkaXYuaW5uZXJIVE1MID0gc3ZnO1xuICAgIHN2ZyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXTtcbiAgICBpZiAoc3ZnKSB7XG4gICAgICAgIGlmIChmdWxsKSB7XG4gICAgICAgICAgICBmID0gc3ZnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGl2LmlubmVySFRNTCA9IEU7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChmKTtcbn07XG5mdW5jdGlvbiBGcmFnbWVudChmcmFnKSB7XG4gICAgdGhpcy5ub2RlID0gZnJhZztcbn1cbi8qXFxcbiAqIEZyYWdtZW50LnNlbGVjdFxuIFsgbWV0aG9kIF1cbiAqKlxuICogU2VlIEBFbGVtZW50LnNlbGVjdFxuXFwqL1xuRnJhZ21lbnQucHJvdG90eXBlLnNlbGVjdCA9IEVsZW1lbnQucHJvdG90eXBlLnNlbGVjdDtcbi8qXFxcbiAqIEZyYWdtZW50LnNlbGVjdEFsbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogU2VlIEBFbGVtZW50LnNlbGVjdEFsbFxuXFwqL1xuRnJhZ21lbnQucHJvdG90eXBlLnNlbGVjdEFsbCA9IEVsZW1lbnQucHJvdG90eXBlLnNlbGVjdEFsbDtcbi8vIFNJRVJSQSBTbmFwLmZyYWdtZW50KCkgY291bGQgZXNwZWNpYWxseSB1c2UgYSBjb2RlIGV4YW1wbGVcbi8qXFxcbiAqIFNuYXAuZnJhZ21lbnRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENyZWF0ZXMgYSBET00gZnJhZ21lbnQgZnJvbSBhIGdpdmVuIGxpc3Qgb2YgZWxlbWVudHMgb3Igc3RyaW5nc1xuICoqXG4gLSB2YXJhcmdzICjigKYpIFNWRyBzdHJpbmdcbiA9IChGcmFnbWVudCkgdGhlIEBGcmFnbWVudFxuXFwqL1xuU25hcC5mcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgIGYgPSBnbG9iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0ubm9kZSAmJiBpdGVtLm5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGYuYXBwZW5kQ2hpbGQoaXRlbS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChTbmFwLnBhcnNlKGl0ZW0pLm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoZik7XG59O1xuXG5mdW5jdGlvbiBtYWtlKG5hbWUsIHBhcmVudCkge1xuICAgIHZhciByZXMgPSAkKG5hbWUpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZXMpO1xuICAgIHZhciBlbCA9IHdyYXAocmVzKTtcbiAgICBlbC50eXBlID0gbmFtZTtcbiAgICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBQYXBlcih3LCBoKSB7XG4gICAgdmFyIHJlcyxcbiAgICAgICAgZGVzYyxcbiAgICAgICAgZGVmcyxcbiAgICAgICAgcHJvdG8gPSBQYXBlci5wcm90b3R5cGU7XG4gICAgaWYgKHcgJiYgdy50YWdOYW1lID09IFwic3ZnXCIpIHtcbiAgICAgICAgaWYgKHcuc25hcCBpbiBodWIpIHtcbiAgICAgICAgICAgIHJldHVybiBodWJbdy5zbmFwXTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBuZXcgRWxlbWVudCh3KTtcbiAgICAgICAgZGVzYyA9IHcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkZXNjXCIpWzBdO1xuICAgICAgICBkZWZzID0gdy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRlZnNcIilbMF07XG4gICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgZGVzYyA9ICQoXCJkZXNjXCIpO1xuICAgICAgICAgICAgZGVzYy5hcHBlbmRDaGlsZChnbG9iLmRvYy5jcmVhdGVUZXh0Tm9kZShcIkNyZWF0ZWQgd2l0aCBTbmFwXCIpKTtcbiAgICAgICAgICAgIHJlcy5ub2RlLmFwcGVuZENoaWxkKGRlc2MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmcykge1xuICAgICAgICAgICAgZGVmcyA9ICQoXCJkZWZzXCIpO1xuICAgICAgICAgICAgcmVzLm5vZGUuYXBwZW5kQ2hpbGQoZGVmcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLmRlZnMgPSBkZWZzO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvdG8pIGlmIChwcm90b1toYXNdKGtleSkpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gcHJvdG9ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXMucGFwZXIgPSByZXMucm9vdCA9IHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSBtYWtlKFwic3ZnXCIsIGdsb2IuZG9jLmJvZHkpO1xuICAgICAgICAkKHJlcy5ub2RlLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLjEsXG4gICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgIHhtbG5zOiB4bWxuc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHdyYXAoZG9tKSB7XG4gICAgaWYgKCFkb20pIHtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgaWYgKGRvbSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgZG9tIGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgaWYgKGRvbS50YWdOYW1lID09IFwic3ZnXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXBlcihkb20pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVsZW1lbnQoZG9tKTtcbn1cbi8vIGdyYWRpZW50cycgaGVscGVyc1xuZnVuY3Rpb24gR3N0b3BzKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdEFsbChcInN0b3BcIik7XG59XG5mdW5jdGlvbiBHYWRkU3RvcChjb2xvciwgb2Zmc2V0KSB7XG4gICAgdmFyIHN0b3AgPSAkKFwic3RvcFwiKSxcbiAgICAgICAgYXR0ciA9IHtcbiAgICAgICAgICAgIG9mZnNldDogK29mZnNldCArIFwiJVwiXG4gICAgICAgIH07XG4gICAgY29sb3IgPSBTbmFwLmNvbG9yKGNvbG9yKTtcbiAgICBhdHRyW1wic3RvcC1jb2xvclwiXSA9IGNvbG9yLmhleDtcbiAgICBpZiAoY29sb3Iub3BhY2l0eSA8IDEpIHtcbiAgICAgICAgYXR0cltcInN0b3Atb3BhY2l0eVwiXSA9IGNvbG9yLm9wYWNpdHk7XG4gICAgfVxuICAgICQoc3RvcCwgYXR0cik7XG4gICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHN0b3ApO1xuICAgIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gR2dldEJCb3goKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PSBcImxpbmVhckdyYWRpZW50XCIpIHtcbiAgICAgICAgdmFyIHgxID0gJCh0aGlzLm5vZGUsIFwieDFcIikgfHwgMCxcbiAgICAgICAgICAgIHgyID0gJCh0aGlzLm5vZGUsIFwieDJcIikgfHwgMSxcbiAgICAgICAgICAgIHkxID0gJCh0aGlzLm5vZGUsIFwieTFcIikgfHwgMCxcbiAgICAgICAgICAgIHkyID0gJCh0aGlzLm5vZGUsIFwieTJcIikgfHwgMDtcbiAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3goeDEsIHkxLCBtYXRoLmFicyh4MiAtIHgxKSwgbWF0aC5hYnMoeTIgLSB5MSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjeCA9IHRoaXMubm9kZS5jeCB8fCAuNSxcbiAgICAgICAgICAgIGN5ID0gdGhpcy5ub2RlLmN5IHx8IC41LFxuICAgICAgICAgICAgciA9IHRoaXMubm9kZS5yIHx8IDA7XG4gICAgICAgIHJldHVybiBTbmFwLl8uYm94KGN4IC0gciwgY3kgLSByLCByICogMiwgciAqIDIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdyYWRpZW50KGRlZnMsIHN0cikge1xuICAgIHZhciBncmFkID0gYXJyYXlGaXJzdFZhbHVlKGV2ZShcInNuYXAudXRpbC5ncmFkLnBhcnNlXCIsIG51bGwsIHN0cikpLFxuICAgICAgICBlbDtcbiAgICBpZiAoIWdyYWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdyYWQucGFyYW1zLnVuc2hpZnQoZGVmcyk7XG4gICAgaWYgKGdyYWQudHlwZS50b0xvd2VyQ2FzZSgpID09IFwibFwiKSB7XG4gICAgICAgIGVsID0gZ3JhZGllbnRMaW5lYXIuYXBwbHkoMCwgZ3JhZC5wYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gZ3JhZGllbnRSYWRpYWwuYXBwbHkoMCwgZ3JhZC5wYXJhbXMpO1xuICAgIH1cbiAgICBpZiAoZ3JhZC50eXBlICE9IGdyYWQudHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICQoZWwubm9kZSwge1xuICAgICAgICAgICAgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc3RvcHMgPSBncmFkLnN0b3BzLFxuICAgICAgICBsZW4gPSBzdG9wcy5sZW5ndGgsXG4gICAgICAgIHN0YXJ0ID0gMCxcbiAgICAgICAgaiA9IDA7XG4gICAgZnVuY3Rpb24gc2VlZChpLCBlbmQpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSAoZW5kIC0gc3RhcnQpIC8gKGkgLSBqKTtcbiAgICAgICAgZm9yICh2YXIgayA9IGo7IGsgPCBpOyBrKyspIHtcbiAgICAgICAgICAgIHN0b3BzW2tdLm9mZnNldCA9ICsoK3N0YXJ0ICsgc3RlcCAqIChrIC0gaikpLnRvRml4ZWQoMik7XG4gICAgICAgIH1cbiAgICAgICAgaiA9IGk7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cbiAgICBsZW4tLTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBpZiAoXCJvZmZzZXRcIiBpbiBzdG9wc1tpXSkge1xuICAgICAgICBzZWVkKGksIHN0b3BzW2ldLm9mZnNldCk7XG4gICAgfVxuICAgIHN0b3BzW2xlbl0ub2Zmc2V0ID0gc3RvcHNbbGVuXS5vZmZzZXQgfHwgMTAwO1xuICAgIHNlZWQobGVuLCBzdG9wc1tsZW5dLm9mZnNldCk7XG4gICAgZm9yIChpID0gMDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW2ldO1xuICAgICAgICBlbC5hZGRTdG9wKHN0b3AuY29sb3IsIHN0b3Aub2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gZ3JhZGllbnRMaW5lYXIoZGVmcywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgZWwgPSBtYWtlKFwibGluZWFyR3JhZGllbnRcIiwgZGVmcyk7XG4gICAgZWwuc3RvcHMgPSBHc3RvcHM7XG4gICAgZWwuYWRkU3RvcCA9IEdhZGRTdG9wO1xuICAgIGVsLmdldEJCb3ggPSBHZ2V0QkJveDtcbiAgICBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICAkKGVsLm5vZGUsIHtcbiAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgIHkyOiB5MlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gZ3JhZGllbnRSYWRpYWwoZGVmcywgY3gsIGN5LCByLCBmeCwgZnkpIHtcbiAgICB2YXIgZWwgPSBtYWtlKFwicmFkaWFsR3JhZGllbnRcIiwgZGVmcyk7XG4gICAgZWwuc3RvcHMgPSBHc3RvcHM7XG4gICAgZWwuYWRkU3RvcCA9IEdhZGRTdG9wO1xuICAgIGVsLmdldEJCb3ggPSBHZ2V0QkJveDtcbiAgICBpZiAoY3ggIT0gbnVsbCkge1xuICAgICAgICAkKGVsLm5vZGUsIHtcbiAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgIHI6IHJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmeCAhPSBudWxsICYmIGZ5ICE9IG51bGwpIHtcbiAgICAgICAgJChlbC5ub2RlLCB7XG4gICAgICAgICAgICBmeDogZngsXG4gICAgICAgICAgICBmeTogZnlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cbi8vIFBhcGVyIHByb3RvdHlwZSBtZXRob2RzXG4oZnVuY3Rpb24gKHByb3RvKSB7XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmVsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGFuIGVsZW1lbnQgb24gcGFwZXIgd2l0aCBhIGdpdmVuIG5hbWUgYW5kIG5vIGF0dHJpYnV0ZXNcbiAgICAgKipcbiAgICAgLSBuYW1lIChzdHJpbmcpIHRhZyBuYW1lXG4gICAgIC0gYXR0ciAob2JqZWN0KSBhdHRyaWJ1dGVzXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApOyAvLyBpcyB0aGUgc2FtZSBhcy4uLlxuICAgICB8IHZhciBjID0gcGFwZXIuZWwoXCJjaXJjbGVcIikuYXR0cih7XG4gICAgIHwgICAgIGN4OiAxMCxcbiAgICAgfCAgICAgY3k6IDEwLFxuICAgICB8ICAgICByOiAxMFxuICAgICB8IH0pO1xuICAgICB8IC8vIGFuZCB0aGUgc2FtZSBhc1xuICAgICB8IHZhciBjID0gcGFwZXIuZWwoXCJjaXJjbGVcIiwge1xuICAgICB8ICAgICBjeDogMTAsXG4gICAgIHwgICAgIGN5OiAxMCxcbiAgICAgfCAgICAgcjogMTBcbiAgICAgfCB9KTtcbiAgICBcXCovXG4gICAgcHJvdG8uZWwgPSBmdW5jdGlvbiAobmFtZSwgYXR0cikge1xuICAgICAgICByZXR1cm4gbWFrZShuYW1lLCB0aGlzLm5vZGUpLmF0dHIoYXR0cik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIucmVjdFxuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgKiBEcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGVmdCBjb3JuZXJcbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgY29ybmVyXG4gICAgIC0gd2lkdGggKG51bWJlcikgd2lkdGhcbiAgICAgLSBoZWlnaHQgKG51bWJlcikgaGVpZ2h0XG4gICAgIC0gcnggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgcmFkaXVzIGZvciByb3VuZGVkIGNvcm5lcnMsIGRlZmF1bHQgaXMgMFxuICAgICAtIHJ5IChudW1iZXIpICNvcHRpb25hbCB2ZXJ0aWNhbCByYWRpdXMgZm9yIHJvdW5kZWQgY29ybmVycywgZGVmYXVsdCBpcyByeCBvciAwXG4gICAgID0gKG9iamVjdCkgdGhlIGByZWN0YCBlbGVtZW50XG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCAvLyByZWd1bGFyIHJlY3RhbmdsZVxuICAgICB8IHZhciBjID0gcGFwZXIucmVjdCgxMCwgMTAsIDUwLCA1MCk7XG4gICAgIHwgLy8gcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzXG4gICAgIHwgdmFyIGMgPSBwYXBlci5yZWN0KDQwLCA0MCwgNTAsIDUwLCAxMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgcngsIHJ5KSB7XG4gICAgICAgIHZhciBhdHRyO1xuICAgICAgICBpZiAocnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnkgPSByeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoeCwgXCJvYmplY3RcIikgJiYgXCJ4XCIgaW4geCkge1xuICAgICAgICAgICAgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocnggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHIucnggPSByeDtcbiAgICAgICAgICAgICAgICBhdHRyLnJ5ID0gcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJyZWN0XCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmNpcmNsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSBjaXJjbGVcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZVxuICAgICAtIHIgKG51bWJlcikgcmFkaXVzXG4gICAgID0gKG9iamVjdCkgdGhlIGBjaXJjbGVgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDUwLCA1MCwgNDApO1xuICAgIFxcKi9cbiAgICBwcm90by5jaXJjbGUgPSBmdW5jdGlvbiAoY3gsIGN5LCByKSB7XG4gICAgICAgIHZhciBhdHRyO1xuICAgICAgICBpZiAoaXMoY3gsIFwib2JqZWN0XCIpICYmIFwiY3hcIiBpbiBjeCkge1xuICAgICAgICAgICAgYXR0ciA9IGN4O1xuICAgICAgICB9IGVsc2UgaWYgKGN4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPSB7XG4gICAgICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICByOiByXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwiY2lyY2xlXCIsIGF0dHIpO1xuICAgIH07XG5cbiAgICAvKlxcXG4gICAgICogUGFwZXIuaW1hZ2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFBsYWNlcyBhbiBpbWFnZSBvbiB0aGUgc3VyZmFjZVxuICAgICAqKlxuICAgICAtIHNyYyAoc3RyaW5nKSBVUkkgb2YgdGhlIHNvdXJjZSBpbWFnZVxuICAgICAtIHggKG51bWJlcikgeCBvZmZzZXQgcG9zaXRpb25cbiAgICAgLSB5IChudW1iZXIpIHkgb2Zmc2V0IHBvc2l0aW9uXG4gICAgIC0gd2lkdGggKG51bWJlcikgd2lkdGggb2YgdGhlIGltYWdlXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAgICAgPSAob2JqZWN0KSB0aGUgYGltYWdlYCBlbGVtZW50XG4gICAgICogb3JcbiAgICAgPSAob2JqZWN0KSBTbmFwIGVsZW1lbnQgb2JqZWN0IHdpdGggdHlwZSBgaW1hZ2VgXG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgYyA9IHBhcGVyLmltYWdlKFwiYXBwbGUucG5nXCIsIDEwLCAxMCwgODAsIDgwKTtcbiAgICBcXCovXG4gICAgcHJvdG8uaW1hZ2UgPSBmdW5jdGlvbiAoc3JjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBlbCA9IG1ha2UoXCJpbWFnZVwiLCB0aGlzLm5vZGUpO1xuICAgICAgICBpZiAoaXMoc3JjLCBcIm9iamVjdFwiKSAmJiBcInNyY1wiIGluIHNyYykge1xuICAgICAgICAgICAgZWwuYXR0cihzcmMpO1xuICAgICAgICB9IGVsc2UgaWYgKHNyYyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc2V0ID0ge1xuICAgICAgICAgICAgICAgIFwieGxpbms6aHJlZlwiOiBzcmMsXG4gICAgICAgICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoeCAhPSBudWxsICYmIHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldC54ID0geDtcbiAgICAgICAgICAgICAgICBzZXQueSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2lkdGggIT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldC53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHNldC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZWxvYWQoc3JjLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJChlbC5ub2RlLCBzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5lbGxpcHNlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhbiBlbGxpcHNlXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZVxuICAgICAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBjZW50cmVcbiAgICAgLSByeCAobnVtYmVyKSBob3Jpem9udGFsIHJhZGl1c1xuICAgICAtIHJ5IChudW1iZXIpIHZlcnRpY2FsIHJhZGl1c1xuICAgICA9IChvYmplY3QpIHRoZSBgZWxsaXBzZWAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5lbGxpcHNlKDUwLCA1MCwgNDAsIDIwKTtcbiAgICBcXCovXG4gICAgcHJvdG8uZWxsaXBzZSA9IGZ1bmN0aW9uIChjeCwgY3ksIHJ4LCByeSkge1xuICAgICAgICB2YXIgZWwgPSBtYWtlKFwiZWxsaXBzZVwiLCB0aGlzLm5vZGUpO1xuICAgICAgICBpZiAoaXMoY3gsIFwib2JqZWN0XCIpICYmIFwiY3hcIiBpbiBjeCkge1xuICAgICAgICAgICAgZWwuYXR0cihjeCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3ggIT0gbnVsbCkge1xuICAgICAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICByeDogcngsXG4gICAgICAgICAgICAgICAgcnk6IHJ5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvLyBTSUVSUkEgUGFwZXIucGF0aCgpOiBVbmNsZWFyIGZyb20gdGhlIGxpbmsgd2hhdCBhIENhdG11bGwtUm9tIGN1cnZldG8gaXMsIGFuZCB3aHkgaXQgd291bGQgbWFrZSBsaWZlIGFueSBlYXNpZXIuXG4gICAgLypcXFxuICAgICAqIFBhcGVyLnBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPHBhdGg+YCBlbGVtZW50IHVzaW5nIHRoZSBnaXZlbiBzdHJpbmcgYXMgdGhlIHBhdGgncyBkZWZpbml0aW9uXG4gICAgIC0gcGF0aFN0cmluZyAoc3RyaW5nKSAjb3B0aW9uYWwgcGF0aCBzdHJpbmcgaW4gU1ZHIGZvcm1hdFxuICAgICAqIFBhdGggc3RyaW5nIGNvbnNpc3RzIG9mIG9uZS1sZXR0ZXIgY29tbWFuZHMsIGZvbGxvd2VkIGJ5IGNvbW1hIHNlcHJhcmF0ZWQgYXJndW1lbnRzIGluIG51bWVyaWNhbCBmb3JtLiBFeGFtcGxlOlxuICAgICB8IFwiTTEwLDIwTDMwLDQwXCJcbiAgICAgKiBUaGlzIGV4YW1wbGUgZmVhdHVyZXMgdHdvIGNvbW1hbmRzOiBgTWAsIHdpdGggYXJndW1lbnRzIGAoMTAsIDIwKWAgYW5kIGBMYCB3aXRoIGFyZ3VtZW50cyBgKDMwLCA0MClgLiBVcHBlcmNhc2UgbGV0dGVyIGNvbW1hbmRzIGV4cHJlc3MgY29vcmRpbmF0ZXMgaW4gYWJzb2x1dGUgdGVybXMsIHdoaWxlIGxvd2VyY2FzZSBjb21tYW5kcyBleHByZXNzIHRoZW0gaW4gcmVsYXRpdmUgdGVybXMgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBkZWNsYXJlZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAjIDxwPkhlcmUgaXMgc2hvcnQgbGlzdCBvZiBjb21tYW5kcyBhdmFpbGFibGUsIGZvciBtb3JlIGRldGFpbHMgc2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVwiIHRpdGxlPVwiRGV0YWlscyBvZiBhIHBhdGgncyBkYXRhIGF0dHJpYnV0ZSdzIGZvcm1hdCBhcmUgZGVzY3JpYmVkIGluIHRoZSBTVkcgc3BlY2lmaWNhdGlvbi5cIj5TVkcgcGF0aCBzdHJpbmcgZm9ybWF0PC9hPiBvciA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vU1ZHL1R1dG9yaWFsL1BhdGhzXCI+YXJ0aWNsZSBhYm91dCBwYXRoIHN0cmluZ3MgYXQgTUROPC9hPi48L3A+XG4gICAgICMgPHRhYmxlPjx0aGVhZD48dHI+PHRoPkNvbW1hbmQ8L3RoPjx0aD5OYW1lPC90aD48dGg+UGFyYW1ldGVyczwvdGg+PC90cj48L3RoZWFkPjx0Ym9keT5cbiAgICAgIyA8dHI+PHRkPk08L3RkPjx0ZD5tb3ZldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5aPC90ZD48dGQ+Y2xvc2VwYXRoPC90ZD48dGQ+KG5vbmUpPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+TDwvdGQ+PHRkPmxpbmV0bzwvdGQ+PHRkPih4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkg8L3RkPjx0ZD5ob3Jpem9udGFsIGxpbmV0bzwvdGQ+PHRkPngrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+VjwvdGQ+PHRkPnZlcnRpY2FsIGxpbmV0bzwvdGQ+PHRkPnkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+QzwvdGQ+PHRkPmN1cnZldG88L3RkPjx0ZD4oeDEgeTEgeDIgeTIgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5TPC90ZD48dGQ+c21vb3RoIGN1cnZldG88L3RkPjx0ZD4oeDIgeTIgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5RPC90ZD48dGQ+cXVhZHJhdGljIELDqXppZXIgY3VydmV0bzwvdGQ+PHRkPih4MSB5MSB4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlQ8L3RkPjx0ZD5zbW9vdGggcXVhZHJhdGljIELDqXppZXIgY3VydmV0bzwvdGQ+PHRkPih4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkE8L3RkPjx0ZD5lbGxpcHRpY2FsIGFyYzwvdGQ+PHRkPihyeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlI8L3RkPjx0ZD48YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXRtdWxs4oCTUm9tX3NwbGluZSNDYXRtdWxsLkUyLjgwLjkzUm9tX3NwbGluZVwiPkNhdG11bGwtUm9tIGN1cnZldG88L2E+KjwvdGQ+PHRkPngxIHkxICh4IHkpKzwvdGQ+PC90cj48L3Rib2R5PjwvdGFibGU+XG4gICAgICogKiBfQ2F0bXVsbC1Sb20gY3VydmV0b18gaXMgYSBub3Qgc3RhbmRhcmQgU1ZHIGNvbW1hbmQgYW5kIGFkZGVkIHRvIG1ha2UgbGlmZSBlYXNpZXIuXG4gICAgICogTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlbiBhIHBhdGggY29uc2lzdHMgb2Ygb25seSB0aHJlZSBjb21tYW5kczogYE0xMCwxMFLigKZ6YC4gSW4gdGhpcyBjYXNlIHRoZSBwYXRoIGNvbm5lY3RzIGJhY2sgdG8gaXRzIHN0YXJ0aW5nIHBvaW50LlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5wYXRoKFwiTTEwIDEwTDkwIDkwXCIpO1xuICAgICB8IC8vIGRyYXcgYSBkaWFnb25hbCBsaW5lOlxuICAgICB8IC8vIG1vdmUgdG8gMTAsMTAsIGxpbmUgdG8gOTAsOTBcbiAgICBcXCovXG4gICAgcHJvdG8ucGF0aCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBlbCA9IG1ha2UoXCJwYXRoXCIsIHRoaXMubm9kZSk7XG4gICAgICAgIGlmIChpcyhkLCBcIm9iamVjdFwiKSAmJiAhaXMoZCwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgZWwuYXR0cihkKTtcbiAgICAgICAgfSBlbHNlIGlmIChkKSB7XG4gICAgICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICAgICAgICBkOiBkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbi8vIFNJRVJSQSBQYXBlci5nKCk6IERvbid0IHVuZGVyc3RhbmQgdGhlIGNvZGUgY29tbWVudCBhYm91dCB0aGUgb3JkZXIgYmVpbmcgX2RpZmZlcmVudC5fIFdvdWxkbid0IGl0IGJlIGEgcmVjdCBmb2xsb3dlZCBieSBhIGNpcmNsZT9cbiAgICAvKlxcXG4gICAgICogUGFwZXIuZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGdyb3VwIGVsZW1lbnRcbiAgICAgKipcbiAgICAgLSB2YXJhcmdzICjigKYpICNvcHRpb25hbCBlbGVtZW50cyB0byBuZXN0IHdpdGhpbiB0aGUgZ3JvdXBcbiAgICAgPSAob2JqZWN0KSB0aGUgYGdgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjMSA9IHBhcGVyLmNpcmNsZSgpLFxuICAgICB8ICAgICBjMiA9IHBhcGVyLnJlY3QoKSxcbiAgICAgfCAgICAgZyA9IHBhcGVyLmcoYzIsIGMxKTsgLy8gbm90ZSB0aGF0IHRoZSBvcmRlciBvZiBlbGVtZW50cyBpcyBkaWZmZXJlbnRcbiAgICAgKiBvclxuICAgICB8IHZhciBjMSA9IHBhcGVyLmNpcmNsZSgpLFxuICAgICB8ICAgICBjMiA9IHBhcGVyLnJlY3QoKSxcbiAgICAgfCAgICAgZyA9IHBhcGVyLmcoKTtcbiAgICAgfCBnLmFkZChjMiwgYzEpO1xuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogUGFwZXIuZ3JvdXBcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNlZSBAUGFwZXIuZ1xuICAgIFxcKi9cbiAgICBwcm90by5ncm91cCA9IHByb3RvLmcgPSBmdW5jdGlvbiAoZmlyc3QpIHtcbiAgICAgICAgdmFyIGVsID0gbWFrZShcImdcIiwgdGhpcy5ub2RlKTtcbiAgICAgICAgZWwuYWRkID0gYWRkMmdyb3VwO1xuICAgICAgICBmb3IgKHZhciBtZXRob2QgaW4gcHJvdG8pIGlmIChwcm90b1toYXNdKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGVsW21ldGhvZF0gPSBwcm90b1ttZXRob2RdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgZmlyc3QgJiYgIWZpcnN0LnR5cGUpIHtcbiAgICAgICAgICAgIGVsLmF0dHIoZmlyc3QpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsLmFkZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIudGV4dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSB0ZXh0IHN0cmluZ1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb25cbiAgICAgLSB0ZXh0IChzdHJpbmd8YXJyYXkpIFRoZSB0ZXh0IHN0cmluZyB0byBkcmF3IG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gbmVzdCB3aXRoaW4gc2VwYXJhdGUgYDx0c3Bhbj5gIGVsZW1lbnRzXG4gICAgID0gKG9iamVjdCkgdGhlIGB0ZXh0YCBlbGVtZW50XG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgdDEgPSBwYXBlci50ZXh0KDUwLCA1MCwgXCJTbmFwXCIpO1xuICAgICB8IHZhciB0MiA9IHBhcGVyLnRleHQoNTAsIDUwLCBbXCJTXCIsXCJuXCIsXCJhXCIsXCJwXCJdKTtcbiAgICAgfCAvLyBUZXh0IHBhdGggdXNhZ2VcbiAgICAgfCB0MS5hdHRyKHt0ZXh0cGF0aDogXCJNMTAsMTBMMTAwLDEwMFwifSk7XG4gICAgIHwgLy8gb3JcbiAgICAgfCB2YXIgcHRoID0gcGFwZXIucGF0aChcIk0xMCwxMEwxMDAsMTAwXCIpO1xuICAgICB8IHQxLmF0dHIoe3RleHRwYXRoOiBwdGh9KTtcbiAgICBcXCovXG4gICAgcHJvdG8udGV4dCA9IGZ1bmN0aW9uICh4LCB5LCB0ZXh0KSB7XG4gICAgICAgIHZhciBlbCA9IG1ha2UoXCJ0ZXh0XCIsIHRoaXMubm9kZSk7XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgZWwuYXR0cih4KTtcbiAgICAgICAgfSBlbHNlIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsLmF0dHIoe1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0IHx8IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5saW5lXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIGxpbmVcbiAgICAgKipcbiAgICAgLSB4MSAobnVtYmVyKSB4IGNvb3JkaW5hdGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0XG4gICAgIC0geTEgKG51bWJlcikgeSBjb29yZGluYXRlIHBvc2l0aW9uIG9mIHRoZSBzdGFydFxuICAgICAtIHgyIChudW1iZXIpIHggY29vcmRpbmF0ZSBwb3NpdGlvbiBvZiB0aGUgZW5kXG4gICAgIC0geTIgKG51bWJlcikgeSBjb29yZGluYXRlIHBvc2l0aW9uIG9mIHRoZSBlbmRcbiAgICAgPSAob2JqZWN0KSB0aGUgYGxpbmVgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciB0MSA9IHBhcGVyLmxpbmUoNTAsIDUwLCAxMDAsIDEwMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLmxpbmUgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgdmFyIGVsID0gbWFrZShcImxpbmVcIiwgdGhpcy5ub2RlKTtcbiAgICAgICAgaWYgKGlzKHgxLCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgZWwuYXR0cih4MSk7XG4gICAgICAgIH0gZWxzZSBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIucG9seWxpbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERyYXdzIGEgcG9seWxpbmVcbiAgICAgKipcbiAgICAgLSBwb2ludHMgKGFycmF5KSBhcnJheSBvZiBwb2ludHNcbiAgICAgKiBvclxuICAgICAtIHZhcmFyZ3MgKOKApikgcG9pbnRzXG4gICAgID0gKG9iamVjdCkgdGhlIGBwb2x5bGluZWAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIHAxID0gcGFwZXIucG9seWxpbmUoWzEwLCAxMCwgMTAwLCAxMDBdKTtcbiAgICAgfCB2YXIgcDIgPSBwYXBlci5wb2x5bGluZSgxMCwgMTAsIDEwMCwgMTAwKTtcbiAgICBcXCovXG4gICAgcHJvdG8ucG9seWxpbmUgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcG9pbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWwgPSBtYWtlKFwicG9seWxpbmVcIiwgdGhpcy5ub2RlKTtcbiAgICAgICAgaWYgKGlzKHBvaW50cywgXCJvYmplY3RcIikgJiYgIWlzKHBvaW50cywgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgZWwuYXR0cihwb2ludHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnBvbHlnb25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERyYXdzIGEgcG9seWdvbi4gU2VlIEBQYXBlci5wb2x5bGluZVxuICAgIFxcKi9cbiAgICBwcm90by5wb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsID0gbWFrZShcInBvbHlnb25cIiwgdGhpcy5ub2RlKTtcbiAgICAgICAgaWYgKGlzKHBvaW50cywgXCJvYmplY3RcIikgJiYgIWlzKHBvaW50cywgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgZWwuYXR0cihwb2ludHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLy8gZ3JhZGllbnRzXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBQYXBlci5ncmFkaWVudFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgICAgICoqXG4gICAgICAgICAtIGdyYWRpZW50IChzdHJpbmcpIGdyYWRpZW50IGRlc2NyaXB0b3JcbiAgICAgICAgID4gR3JhZGllbnQgRGVzY3JpcHRvclxuICAgICAgICAgKiBUaGUgZ3JhZGllbnQgZGVzY3JpcHRvciBpcyBhbiBleHByZXNzaW9uIGZvcm1hdHRlZCBhc1xuICAgICAgICAgKiBmb2xsb3dzOiBgPHR5cGU+KDxjb29yZHM+KTxjb2xvcnM+YC4gIFRoZSBgPHR5cGU+YCBjYW4gYmVcbiAgICAgICAgICogZWl0aGVyIGxpbmVhciBvciByYWRpYWwuICBUaGUgdXBwZXJjYXNlIGBMYCBvciBgUmAgbGV0dGVyc1xuICAgICAgICAgKiBpbmRpY2F0ZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvZmZzZXQgZnJvbSB0aGUgU1ZHIHN1cmZhY2UuXG4gICAgICAgICAqIExvd2VyY2FzZSBgbGAgb3IgYHJgIGxldHRlcnMgaW5kaWNhdGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICogY2FsY3VsYXRlZCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgZ3JhZGllbnQgaXNcbiAgICAgICAgICogYXBwbGllZC4gIENvb3JkaW5hdGVzIHNwZWNpZnkgYSBsaW5lYXIgZ3JhZGllbnQgdmVjdG9yIGFzXG4gICAgICAgICAqIGB4MWAsIGB5MWAsIGB4MmAsIGB5MmAsIG9yIGEgcmFkaWFsIGdyYWRpZW50IGFzIGBjeGAsIGBjeWAsXG4gICAgICAgICAqIGByYCBhbmQgb3B0aW9uYWwgYGZ4YCwgYGZ5YCBzcGVjaWZ5aW5nIGEgZm9jYWwgcG9pbnQgYXdheVxuICAgICAgICAgKiBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZS4gU3BlY2lmeSBgPGNvbG9ycz5gIGFzIGEgbGlzdFxuICAgICAgICAgKiBvZiBkYXNoLXNlcGFyYXRlZCBDU1MgY29sb3IgdmFsdWVzLiAgRWFjaCBjb2xvciBtYXkgYmVcbiAgICAgICAgICogZm9sbG93ZWQgYnkgYSBjdXN0b20gb2Zmc2V0IHZhbHVlLCBzZXBhcmF0ZWQgd2l0aCBhIGNvbG9uXG4gICAgICAgICAqIGNoYXJhY3Rlci5cbiAgICAgICAgID4gRXhhbXBsZXNcbiAgICAgICAgICogTGluZWFyIGdyYWRpZW50LCByZWxhdGl2ZSBmcm9tIHRvcC1sZWZ0IGNvcm5lciB0byBib3R0b20tcmlnaHRcbiAgICAgICAgICogY29ybmVyLCBmcm9tIGJsYWNrIHRocm91Z2ggcmVkIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwibCgwLCAwLCAxLCAxKSMwMDAtI2YwMC0jZmZmXCIpO1xuICAgICAgICAgKiBMaW5lYXIgZ3JhZGllbnQsIGFic29sdXRlIGZyb20gKDAsIDApIHRvICgxMDAsIDEwMCksIGZyb20gYmxhY2tcbiAgICAgICAgICogdGhyb3VnaCByZWQgYXQgMjUlIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwiTCgwLCAwLCAxMDAsIDEwMCkjMDAwLSNmMDA6MjUlLSNmZmZcIik7XG4gICAgICAgICAqIFJhZGlhbCBncmFkaWVudCwgcmVsYXRpdmUgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50IHdpdGggcmFkaXVzXG4gICAgICAgICAqIGhhbGYgdGhlIHdpZHRoLCBmcm9tIGJsYWNrIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwicigwLjUsIDAuNSwgMC41KSMwMDAtI2ZmZlwiKTtcbiAgICAgICAgICogVG8gYXBwbHkgdGhlIGdyYWRpZW50OlxuICAgICAgICAgfCBwYXBlci5jaXJjbGUoNTAsIDUwLCA0MCkuYXR0cih7XG4gICAgICAgICB8ICAgICBmaWxsOiBnXG4gICAgICAgICB8IH0pO1xuICAgICAgICAgPSAob2JqZWN0KSB0aGUgYGdyYWRpZW50YCBlbGVtZW50XG4gICAgICAgIFxcKi9cbiAgICAgICAgcHJvdG8uZ3JhZGllbnQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnQodGhpcy5kZWZzLCBzdHIpO1xuICAgICAgICB9O1xuICAgICAgICBwcm90by5ncmFkaWVudExpbmVhciA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAgICAgcmV0dXJuIGdyYWRpZW50TGluZWFyKHRoaXMuZGVmcywgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICB9O1xuICAgICAgICBwcm90by5ncmFkaWVudFJhZGlhbCA9IGZ1bmN0aW9uIChjeCwgY3ksIHIsIGZ4LCBmeSkge1xuICAgICAgICAgICAgcmV0dXJuIGdyYWRpZW50UmFkaWFsKHRoaXMuZGVmcywgY3gsIGN5LCByLCBmeCwgZnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIFBhcGVyLnRvU3RyaW5nXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIFNWRyBjb2RlIGZvciB0aGUgQFBhcGVyXG4gICAgICAgICA9IChzdHJpbmcpIFNWRyBjb2RlIGZvciB0aGUgQFBhcGVyXG4gICAgICAgIFxcKi9cbiAgICAgICAgcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGdsb2IuZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgICAgICBkID0gZ2xvYi5kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgICAgICBzdmcgPSB0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICAgICAgICAgIHJlcztcbiAgICAgICAgICAgIGYuYXBwZW5kQ2hpbGQoZCk7XG4gICAgICAgICAgICBkLmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgICAgICAgICAkKHN2Zywge3htbG5zOiB4bWxuc30pO1xuICAgICAgICAgICAgcmVzID0gZC5pbm5lckhUTUw7XG4gICAgICAgICAgICBmLnJlbW92ZUNoaWxkKGYuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIFBhcGVyLmNsZWFyXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBjaGlsZCBub2RlcyBvZiB0aGUgcGFwZXIsIGV4Y2VwdCA8ZGVmcz4uXG4gICAgICAgIFxcKi9cbiAgICAgICAgcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZS5maXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5leHQ7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgIT0gXCJkZWZzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KCkpO1xufShQYXBlci5wcm90b3R5cGUpKTtcblxuLy8gc2ltcGxlIGFqYXhcbi8qXFxcbiAqIFNuYXAuYWpheFxuIFsgbWV0aG9kIF1cbiAqKlxuICogU2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIEFqYXhcbiAqKlxuIC0gdXJsIChzdHJpbmcpIFVSTFxuIC0gcG9zdERhdGEgKG9iamVjdHxzdHJpbmcpIGRhdGEgZm9yIHBvc3QgcmVxdWVzdFxuIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSBjYWxsYmFja1xuIC0gc2NvcGUgKG9iamVjdCkgI29wdGlvbmFsIHNjb3BlIG9mIGNhbGxiYWNrXG4gKiBvclxuIC0gdXJsIChzdHJpbmcpIFVSTFxuIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSBjYWxsYmFja1xuIC0gc2NvcGUgKG9iamVjdCkgI29wdGlvbmFsIHNjb3BlIG9mIGNhbGxiYWNrXG4gPSAoWE1MSHR0cFJlcXVlc3QpIHRoZSBYTUxIdHRwUmVxdWVzdCBvYmplY3QsIGp1c3QgaW4gY2FzZVxuXFwqL1xuU25hcC5hamF4ID0gZnVuY3Rpb24gKHVybCwgcG9zdERhdGEsIGNhbGxiYWNrLCBzY29wZSl7XG4gICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCxcbiAgICAgICAgaWQgPSBJRCgpO1xuICAgIGlmIChyZXEpIHtcbiAgICAgICAgaWYgKGlzKHBvc3REYXRhLCBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzY29wZSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBwb3N0RGF0YTtcbiAgICAgICAgICAgIHBvc3REYXRhID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChpcyhwb3N0RGF0YSwgXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIHZhciBwZCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBvc3REYXRhKSBpZiAocG9zdERhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHBkLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwb3N0RGF0YVtrZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3N0RGF0YSA9IHBkLmpvaW4oXCImXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlcS5vcGVuKChwb3N0RGF0YSA/IFwiUE9TVFwiIDogXCJHRVRcIiksIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLCBcIlhNTEh0dHBSZXF1ZXN0XCIpO1xuICAgICAgICBpZiAocG9zdERhdGEpIHtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFqYXguXCIgKyBpZCArIFwiLjBcIiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFqYXguXCIgKyBpZCArIFwiLjIwMFwiLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBldmUub25jZShcInNuYXAuYWpheC5cIiArIGlkICsgXCIuMzA0XCIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgIT0gNCkgcmV0dXJuO1xuICAgICAgICAgICAgZXZlKFwic25hcC5hamF4LlwiICsgaWQgKyBcIi5cIiArIHJlcS5zdGF0dXMsIHNjb3BlLCByZXEpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgfVxuICAgICAgICByZXEuc2VuZChwb3N0RGF0YSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxufTtcbi8qXFxcbiAqIFNuYXAubG9hZFxuIFsgbWV0aG9kIF1cbiAqKlxuICogTG9hZHMgZXh0ZXJuYWwgU1ZHIGZpbGUgYXMgYSBARnJhZ21lbnQgKHNlZSBAU25hcC5hamF4IGZvciBtb3JlIGFkdmFuY2VkIEFKQVgpXG4gKipcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuXFwqL1xuU25hcC5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgU25hcC5hamF4KHVybCwgZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICB2YXIgZiA9IFNuYXAucGFyc2UocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNjb3BlID8gY2FsbGJhY2suY2FsbChzY29wZSwgZikgOiBjYWxsYmFjayhmKTtcbiAgICB9KTtcbn07XG5cbi8vIEF0dHJpYnV0ZXMgZXZlbnQgaGFuZGxlcnNcbmV2ZS5vbihcInNuYXAudXRpbC5hdHRyLm1hc2tcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZyYWdtZW50ICYmIHZhbHVlLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5ub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBnZXRTb21lRGVmcyh0aGlzKS5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHdyYXAodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50eXBlID09IFwibWFza1wiKSB7XG4gICAgICAgICAgICB2YXIgbWFzayA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFzayA9IG1ha2UoXCJtYXNrXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgICAgIG1hc2subm9kZS5hcHBlbmRDaGlsZCh2YWx1ZS5ub2RlKTtcbiAgICAgICAgICAgICFtYXNrLm5vZGUuaWQgJiYgJChtYXNrLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBpZDogbWFzay5pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgIG1hc2s6IFVSTChtYXNrLmlkKVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbihmdW5jdGlvbiAoY2xpcEl0KSB7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xpcFwiLCBjbGlwSXQpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmNsaXAtcGF0aFwiLCBjbGlwSXQpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmNsaXBQYXRoXCIsIGNsaXBJdCk7XG59KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudCkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PSBcImNsaXBQYXRoXCIpIHtcbiAgICAgICAgICAgIHZhciBjbGlwID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGlwID0gbWFrZShcImNsaXBQYXRoXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgICAgIGNsaXAubm9kZS5hcHBlbmRDaGlsZCh2YWx1ZS5ub2RlKTtcbiAgICAgICAgICAgICFjbGlwLm5vZGUuaWQgJiYgJChjbGlwLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBpZDogY2xpcC5pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgIFwiY2xpcC1wYXRoXCI6IFVSTChjbGlwLmlkKVxuICAgICAgICB9KTtcbiAgICB9XG59KSk7XG5mdW5jdGlvbiBmaWxsU3Ryb2tlKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZyYWdtZW50ICYmIHZhbHVlLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJlxuICAgICAgICAgICAgKHZhbHVlLm5vZGUuZmlyc3RDaGlsZC50YWdOYW1lID09IFwicmFkaWFsR3JhZGllbnRcIiB8fFxuICAgICAgICAgICAgdmFsdWUubm9kZS5maXJzdENoaWxkLnRhZ05hbWUgPT0gXCJsaW5lYXJHcmFkaWVudFwiIHx8XG4gICAgICAgICAgICB2YWx1ZS5ub2RlLmZpcnN0Q2hpbGQudGFnTmFtZSA9PSBcInBhdHRlcm5cIikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZ2V0U29tZURlZnModGhpcykuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUgPSB3cmFwKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PSBcInJhZGlhbEdyYWRpZW50XCIgfHwgdmFsdWUudHlwZSA9PSBcImxpbmVhckdyYWRpZW50XCJcbiAgICAgICAgICAgICAgIHx8IHZhbHVlLnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLm5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh2YWx1ZS5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmaWxsID0gVVJMKHZhbHVlLm5vZGUuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxsID0gdmFsdWUuYXR0cihuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGwgPSBTbmFwLmNvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChmaWxsLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWQgPSBncmFkaWVudChnZXRTb21lRGVmcyh0aGlzKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChncmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JhZC5ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGdyYWQubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBncmFkLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaWxsID0gVVJMKGdyYWQubm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsbCA9IFN0cihmaWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgYXR0cnNbbmFtZV0gPSBmaWxsO1xuICAgICAgICAkKHRoaXMubm9kZSwgYXR0cnMpO1xuICAgICAgICB0aGlzLm5vZGUuc3R5bGVbbmFtZV0gPSBFO1xuICAgIH07XG59XG5ldmUub24oXCJzbmFwLnV0aWwuYXR0ci5maWxsXCIsIGZpbGxTdHJva2UoXCJmaWxsXCIpKTtcbmV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnN0cm9rZVwiLCBmaWxsU3Ryb2tlKFwic3Ryb2tlXCIpKTtcbnZhciBncmFkcmcgPSAvXihbbHJdKSg/OlxcKChbXildKilcXCkpPyguKikkL2k7XG5ldmUub24oXCJzbmFwLnV0aWwuZ3JhZC5wYXJzZVwiLCBmdW5jdGlvbiBwYXJzZUdyYWQoc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gU3RyKHN0cmluZyk7XG4gICAgdmFyIHRva2VucyA9IHN0cmluZy5tYXRjaChncmFkcmcpO1xuICAgIGlmICghdG9rZW5zKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IHRva2Vuc1sxXSxcbiAgICAgICAgcGFyYW1zID0gdG9rZW5zWzJdLFxuICAgICAgICBzdG9wcyA9IHRva2Vuc1szXTtcbiAgICBwYXJhbXMgPSBwYXJhbXMuc3BsaXQoL1xccyosXFxzKi8pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuICtlbCA9PSBlbCA/ICtlbCA6IGVsO1xuICAgIH0pO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID09IDEgJiYgcGFyYW1zWzBdID09IDApIHtcbiAgICAgICAgcGFyYW1zID0gW107XG4gICAgfVxuICAgIHN0b3BzID0gc3RvcHMuc3BsaXQoXCItXCIpO1xuICAgIHN0b3BzID0gc3RvcHMubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbCA9IGVsLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBlbFswXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZWxbMV0pIHtcbiAgICAgICAgICAgIG91dC5vZmZzZXQgPSBlbFsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBzdG9wczogc3RvcHNcbiAgICB9O1xufSk7XG5cbmV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmRcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgZXZlLnN0b3AoKTtcbiAgICBpZiAoaXModmFsdWUsIFwiYXJyYXlcIikgJiYgaXModmFsdWVbMF0sIFwiYXJyYXlcIikpIHtcbiAgICAgICAgdmFsdWUgPSBTbmFwLnBhdGgudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlID0gU3RyKHZhbHVlKTtcbiAgICBpZiAodmFsdWUubWF0Y2goL1tydW9dL2kpKSB7XG4gICAgICAgIHZhbHVlID0gU25hcC5wYXRoLnRvQWJzb2x1dGUodmFsdWUpO1xuICAgIH1cbiAgICAkKHRoaXMubm9kZSwge2Q6IHZhbHVlfSk7XG59KSgtMSk7XG5ldmUub24oXCJzbmFwLnV0aWwuYXR0ci4jdGV4dFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBldmUuc3RvcCgpO1xuICAgIHZhbHVlID0gU3RyKHZhbHVlKTtcbiAgICB2YXIgdHh0ID0gZ2xvYi5kb2MuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgIHdoaWxlICh0aGlzLm5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodHh0KTtcbn0pKC0xKTtcbmV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnBhdGhcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgZXZlLnN0b3AoKTtcbiAgICB0aGlzLmF0dHIoe2Q6IHZhbHVlfSk7XG59KSgtMSk7XG5ldmUub24oXCJzbmFwLnV0aWwuYXR0ci52aWV3Qm94XCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciB2YjtcbiAgICBpZiAoaXModmFsdWUsIFwib2JqZWN0XCIpICYmIFwieFwiIGluIHZhbHVlKSB7XG4gICAgICAgIHZiID0gW3ZhbHVlLngsIHZhbHVlLnksIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHRdLmpvaW4oXCIgXCIpO1xuICAgIH0gZWxzZSBpZiAoaXModmFsdWUsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgdmIgPSB2YWx1ZS5qb2luKFwiIFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YiA9IHZhbHVlO1xuICAgIH1cbiAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICB2aWV3Qm94OiB2YlxuICAgIH0pO1xuICAgIGV2ZS5zdG9wKCk7XG59KSgtMSk7XG5ldmUub24oXCJzbmFwLnV0aWwuYXR0ci50cmFuc2Zvcm1cIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0odmFsdWUpO1xuICAgIGV2ZS5zdG9wKCk7XG59KSgtMSk7XG5ldmUub24oXCJzbmFwLnV0aWwuYXR0ci5yXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJyZWN0XCIpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgIHJ4OiB2YWx1ZSxcbiAgICAgICAgICAgIHJ5OiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG59KSgtMSk7XG5ldmUub24oXCJzbmFwLnV0aWwuYXR0ci50ZXh0cGF0aFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBldmUuc3RvcCgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgdmFyIGlkLCB0cCwgbm9kZTtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiB0aGlzLnRleHRQYXRoKSB7XG4gICAgICAgICAgICB0cCA9IHRoaXMudGV4dFBhdGg7XG4gICAgICAgICAgICB3aGlsZSAodHAubm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRwLm5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRleHRQYXRoO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyh2YWx1ZSwgXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHZhciBkZWZzID0gZ2V0U29tZURlZnModGhpcyksXG4gICAgICAgICAgICAgICAgcGF0aCA9IHdyYXAoZGVmcy5wYXJlbnROb2RlKS5wYXRoKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQocGF0aC5ub2RlKTtcbiAgICAgICAgICAgIGlkID0gcGF0aC5pZDtcbiAgICAgICAgICAgIHBhdGguYXR0cih7aWQ6IGlkfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHdyYXAodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlkID0gdmFsdWUuYXR0cihcImlkXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSB2YWx1ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYXR0cih7aWQ6IGlkfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdHAgPSB0aGlzLnRleHRQYXRoO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgICAgIGlmICh0cCkge1xuICAgICAgICAgICAgICAgIHRwLmF0dHIoe1wieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRwID0gJChcInRleHRQYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJ4bGluazpocmVmXCI6IFwiI1wiICsgaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRwLmFwcGVuZENoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodHApO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dFBhdGggPSB3cmFwKHRwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pKC0xKTtcbmV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnRleHRcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBub2RlID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgdHVuZXIgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0gJChcInRzcGFuXCIpO1xuICAgICAgICAgICAgICAgIGlmIChpcyhjaHVuaywgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kQ2hpbGQodHVuZXIoY2h1bmtbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5hcHBlbmRDaGlsZChnbG9iLmRvYy5jcmVhdGVUZXh0Tm9kZShjaHVuaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQubm9ybWFsaXplICYmIG91dC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0dW5lZCA9IHR1bmVyKHZhbHVlKTtcbiAgICAgICAgd2hpbGUgKHR1bmVkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodHVuZWQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXZlLnN0b3AoKTtcbn0pKC0xKTtcbi8vIGRlZmF1bHRcbnZhciBjc3NBdHRyID0ge1xuICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCI6IDAsXG4gICAgXCJiYXNlbGluZS1zaGlmdFwiOiAwLFxuICAgIFwiY2xpcFwiOiAwLFxuICAgIFwiY2xpcC1wYXRoXCI6IDAsXG4gICAgXCJjbGlwLXJ1bGVcIjogMCxcbiAgICBcImNvbG9yXCI6IDAsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCI6IDAsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogMCxcbiAgICBcImNvbG9yLXByb2ZpbGVcIjogMCxcbiAgICBcImNvbG9yLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwiY3Vyc29yXCI6IDAsXG4gICAgXCJkaXJlY3Rpb25cIjogMCxcbiAgICBcImRpc3BsYXlcIjogMCxcbiAgICBcImRvbWluYW50LWJhc2VsaW5lXCI6IDAsXG4gICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiAwLFxuICAgIFwiZmlsbFwiOiAwLFxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IDAsXG4gICAgXCJmaWxsLXJ1bGVcIjogMCxcbiAgICBcImZpbHRlclwiOiAwLFxuICAgIFwiZmxvb2QtY29sb3JcIjogMCxcbiAgICBcImZsb29kLW9wYWNpdHlcIjogMCxcbiAgICBcImZvbnRcIjogMCxcbiAgICBcImZvbnQtZmFtaWx5XCI6IDAsXG4gICAgXCJmb250LXNpemVcIjogMCxcbiAgICBcImZvbnQtc2l6ZS1hZGp1c3RcIjogMCxcbiAgICBcImZvbnQtc3RyZXRjaFwiOiAwLFxuICAgIFwiZm9udC1zdHlsZVwiOiAwLFxuICAgIFwiZm9udC12YXJpYW50XCI6IDAsXG4gICAgXCJmb250LXdlaWdodFwiOiAwLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiOiAwLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogMCxcbiAgICBcImltYWdlLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwia2VybmluZ1wiOiAwLFxuICAgIFwibGV0dGVyLXNwYWNpbmdcIjogMCxcbiAgICBcImxpZ2h0aW5nLWNvbG9yXCI6IDAsXG4gICAgXCJtYXJrZXJcIjogMCxcbiAgICBcIm1hcmtlci1lbmRcIjogMCxcbiAgICBcIm1hcmtlci1taWRcIjogMCxcbiAgICBcIm1hcmtlci1zdGFydFwiOiAwLFxuICAgIFwibWFza1wiOiAwLFxuICAgIFwib3BhY2l0eVwiOiAwLFxuICAgIFwib3ZlcmZsb3dcIjogMCxcbiAgICBcInBvaW50ZXItZXZlbnRzXCI6IDAsXG4gICAgXCJzaGFwZS1yZW5kZXJpbmdcIjogMCxcbiAgICBcInN0b3AtY29sb3JcIjogMCxcbiAgICBcInN0b3Atb3BhY2l0eVwiOiAwLFxuICAgIFwic3Ryb2tlXCI6IDAsXG4gICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IDAsXG4gICAgXCJzdHJva2UtZGFzaG9mZnNldFwiOiAwLFxuICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogMCxcbiAgICBcInN0cm9rZS1saW5lam9pblwiOiAwLFxuICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjogMCxcbiAgICBcInN0cm9rZS1vcGFjaXR5XCI6IDAsXG4gICAgXCJzdHJva2Utd2lkdGhcIjogMCxcbiAgICBcInRleHQtYW5jaG9yXCI6IDAsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogMCxcbiAgICBcInRleHQtcmVuZGVyaW5nXCI6IDAsXG4gICAgXCJ1bmljb2RlLWJpZGlcIjogMCxcbiAgICBcInZpc2liaWxpdHlcIjogMCxcbiAgICBcIndvcmQtc3BhY2luZ1wiOiAwLFxuICAgIFwid3JpdGluZy1tb2RlXCI6IDBcbn07XG5cbmV2ZS5vbihcInNuYXAudXRpbC5hdHRyXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBhdHQgPSBldmUubnQoKSxcbiAgICAgICAgYXR0ciA9IHt9O1xuICAgIGF0dCA9IGF0dC5zdWJzdHJpbmcoYXR0Lmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgIGF0dHJbYXR0XSA9IHZhbHVlO1xuICAgIHZhciBzdHlsZSA9IGF0dC5yZXBsYWNlKC8tKFxcdykvZ2ksIGZ1bmN0aW9uIChhbGwsIGxldHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KSxcbiAgICAgICAgY3NzID0gYXR0LnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi1cIiArIGxldHRlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICBpZiAoY3NzQXR0cltoYXNdKGNzcykpIHtcbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlW3N0eWxlXSA9IHZhbHVlID09IG51bGwgPyBFIDogdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCh0aGlzLm5vZGUsIGF0dHIpO1xuICAgIH1cbn0pO1xuZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIudHJhbnNmb3JtXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBldmUuc3RvcCgpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgpO1xufSkoLTEpO1xuZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIudGV4dHBhdGhcIiwgZnVuY3Rpb24gKCkge1xuICAgIGV2ZS5zdG9wKCk7XG4gICAgcmV0dXJuIHRoaXMudGV4dFBhdGg7XG59KSgtMSk7XG4vLyBNYXJrZXJzXG4oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldHRlcihlbmQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnbG9iLmRvYy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmtlci1cIiArIGVuZCk7XG4gICAgICAgICAgICBpZiAoc3R5bGUgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBTbmFwKGdsb2IuZG9jLmdldEVsZW1lbnRCeUlkKHN0eWxlLm1hdGNoKHJlVVJMVmFsdWUpWzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHRlcihlbmQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJtYXJrZXJcIiArIGVuZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGVuZC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJcIiB8fCAhdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGVbbmFtZV0gPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PSBcIm1hcmtlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdmFsdWUubm9kZS5pZDtcbiAgICAgICAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICQodmFsdWUubm9kZSwge2lkOiB2YWx1ZS5pZH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGVbbmFtZV0gPSBVUkwoaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIubWFya2VyLWVuZFwiLCBnZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5tYXJrZXJFbmRcIiwgZ2V0dGVyKFwiZW5kXCIpKSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIubWFya2VyLXN0YXJ0XCIsIGdldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIubWFya2VyU3RhcnRcIiwgZ2V0dGVyKFwic3RhcnRcIikpKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5tYXJrZXItbWlkXCIsIGdldHRlcihcIm1pZFwiKSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlck1pZFwiLCBnZXR0ZXIoXCJtaWRcIikpKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXJrZXItZW5kXCIsIHNldHRlcihcImVuZFwiKSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLm1hcmtlckVuZFwiLCBzZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXJrZXItc3RhcnRcIiwgc2V0dGVyKFwic3RhcnRcIikpKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXJrZXJTdGFydFwiLCBzZXR0ZXIoXCJzdGFydFwiKSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLm1hcmtlci1taWRcIiwgc2V0dGVyKFwibWlkXCIpKSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyTWlkXCIsIHNldHRlcihcIm1pZFwiKSkoLTEpO1xufSgpKTtcbmV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnJcIiwgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJyZWN0XCIgJiYgJCh0aGlzLm5vZGUsIFwicnhcIikgPT0gJCh0aGlzLm5vZGUsIFwicnlcIikpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuICQodGhpcy5ub2RlLCBcInJ4XCIpO1xuICAgIH1cbn0pKC0xKTtcbmZ1bmN0aW9uIHRleHRFeHRyYWN0KG5vZGUpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKGNoaS5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGkudGFnTmFtZSA9PSBcInRzcGFuXCIpIHtcbiAgICAgICAgICAgIGlmIChjaGkuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBjaGkuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goY2hpLmZpcnN0Q2hpbGQubm9kZVZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2godGV4dEV4dHJhY3QoY2hpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnRleHRcIiwgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIgfHwgdGhpcy50eXBlID09IFwidHNwYW5cIikge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICB2YXIgb3V0ID0gdGV4dEV4dHJhY3QodGhpcy5ub2RlKTtcbiAgICAgICAgcmV0dXJuIG91dC5sZW5ndGggPT0gMSA/IG91dFswXSA6IG91dDtcbiAgICB9XG59KSgtMSk7XG5ldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci4jdGV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS50ZXh0Q29udGVudDtcbn0pKC0xKTtcbmV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnZpZXdCb3hcIiwgZnVuY3Rpb24gKCkge1xuICAgIGV2ZS5zdG9wKCk7XG4gICAgdmFyIHZiID0gJCh0aGlzLm5vZGUsIFwidmlld0JveFwiKS5zcGxpdChzZXBhcmF0b3IpO1xuICAgIHJldHVybiBTbmFwLl8uYm94KCt2YlswXSwgK3ZiWzFdLCArdmJbMl0sICt2YlszXSk7XG4gICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgd2h5IEkgbmVlZCB0byB6LWluZGV4IGl0XG59KSgtMSk7XG5ldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5wb2ludHNcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwID0gJCh0aGlzLm5vZGUsIFwicG9pbnRzXCIpO1xuICAgIGV2ZS5zdG9wKCk7XG4gICAgcmV0dXJuIHAuc3BsaXQoc2VwYXJhdG9yKTtcbn0pO1xuZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIucGF0aFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHAgPSAkKHRoaXMubm9kZSwgXCJkXCIpO1xuICAgIGV2ZS5zdG9wKCk7XG4gICAgcmV0dXJuIHA7XG59KTtcbi8vIGRlZmF1bHRcbmV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXR0ID0gZXZlLm50KCk7XG4gICAgYXR0ID0gYXR0LnN1YnN0cmluZyhhdHQubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgdmFyIGNzcyA9IGF0dC5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbiAobGV0dGVyKSB7XG4gICAgICAgIHJldHVybiBcIi1cIiArIGxldHRlci50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICAgIGlmIChjc3NBdHRyW2hhc10oY3NzKSkge1xuICAgICAgICByZXR1cm4gZ2xvYi5kb2MuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm5vZGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoY3NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJCh0aGlzLm5vZGUsIGF0dCk7XG4gICAgfVxufSk7XG52YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuICAgICAgICBib2R5ID0gZG9jLmJvZHksXG4gICAgICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBjbGllbnRUb3AgPSBkb2NFbGVtLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwLCBjbGllbnRMZWZ0ID0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwLFxuICAgICAgICB0b3AgID0gYm94LnRvcCAgKyAoZy53aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3AgKSAtIGNsaWVudFRvcCxcbiAgICAgICAgbGVmdCA9IGJveC5sZWZ0ICsgKGcud2luLnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQpIC0gY2xpZW50TGVmdDtcbiAgICByZXR1cm4ge1xuICAgICAgICB5OiB0b3AsXG4gICAgICAgIHg6IGxlZnRcbiAgICB9O1xufTtcbi8qXFxcbiAqIFNuYXAuZ2V0RWxlbWVudEJ5UG9pbnRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgeW91IHRvcG1vc3QgZWxlbWVudCB1bmRlciBnaXZlbiBwb2ludC5cbiAqKlxuID0gKG9iamVjdCkgU25hcCBlbGVtZW50IG9iamVjdFxuIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB3aW5kb3dcbiAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgd2luZG93XG4gPiBVc2FnZVxuIHwgU25hcC5nZXRFbGVtZW50QnlQb2ludChtb3VzZVgsIG1vdXNlWSkuYXR0cih7c3Ryb2tlOiBcIiNmMDBcIn0pO1xuXFwqL1xuU25hcC5nZXRFbGVtZW50QnlQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHBhcGVyID0gdGhpcyxcbiAgICAgICAgc3ZnID0gcGFwZXIuY2FudmFzLFxuICAgICAgICB0YXJnZXQgPSBnbG9iLmRvYy5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChnbG9iLndpbi5vcGVyYSAmJiB0YXJnZXQudGFnTmFtZSA9PSBcInN2Z1wiKSB7XG4gICAgICAgIHZhciBzbyA9IGdldE9mZnNldCh0YXJnZXQpLFxuICAgICAgICAgICAgc3IgPSB0YXJnZXQuY3JlYXRlU1ZHUmVjdCgpO1xuICAgICAgICBzci54ID0geCAtIHNvLng7XG4gICAgICAgIHNyLnkgPSB5IC0gc28ueTtcbiAgICAgICAgc3Iud2lkdGggPSBzci5oZWlnaHQgPSAxO1xuICAgICAgICB2YXIgaGl0cyA9IHRhcmdldC5nZXRJbnRlcnNlY3Rpb25MaXN0KHNyLCBudWxsKTtcbiAgICAgICAgaWYgKGhpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBoaXRzW2hpdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB3cmFwKHRhcmdldCk7XG59O1xuLypcXFxuICogU25hcC5wbHVnaW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIExldCB5b3Ugd3JpdGUgcGx1Z2lucy4gWW91IHBhc3MgaW4gYSBmdW5jdGlvbiB3aXRoIGZvdXIgYXJndW1lbnRzLCBsaWtlIHRoaXM6XG4gfCBTbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2JhbCkge1xuIHwgICAgIFNuYXAubmV3bWV0aG9kID0gZnVuY3Rpb24gKCkge307XG4gfCAgICAgRWxlbWVudC5wcm90b3R5cGUubmV3bWV0aG9kID0gZnVuY3Rpb24gKCkge307XG4gfCAgICAgUGFwZXIucHJvdG90eXBlLm5ld21ldGhvZCA9IGZ1bmN0aW9uICgpIHt9O1xuIHwgfSk7XG4gKiBJbnNpZGUgdGhlIGZ1bmN0aW9uIHlvdSBoYXZlIGFjY2VzcyB0byBhbGwgbWFpbiBvYmplY3RzIChhbmQgdGhlaXJcbiAqIHByb3RvdHlwZXMpLiBUaGlzIGFsbG93IHlvdSB0byBleHRlbmQgYW55dGhpbmcgeW91IHdhbnQuXG4gKipcbiAtIGYgKGZ1bmN0aW9uKSB5b3VyIHBsdWdpbiBib2R5XG5cXCovXG5TbmFwLnBsdWdpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgZihTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYik7XG59O1xuZ2xvYi53aW4uU25hcCA9IFNuYXA7XG5yZXR1cm4gU25hcDtcbn0od2luZG93IHx8IHRoaXMpKTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iKSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBjbG9uZSA9IFNuYXAuXy5jbG9uZSxcbiAgICAgICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICBwMnMgPSAvLD8oW2Etel0pLD8vZ2ksXG4gICAgICAgIHRvRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgICBtYXRoID0gTWF0aCxcbiAgICAgICAgUEkgPSBtYXRoLlBJLFxuICAgICAgICBtbWluID0gbWF0aC5taW4sXG4gICAgICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICAgICAgcG93ID0gbWF0aC5wb3csXG4gICAgICAgIGFicyA9IG1hdGguYWJzO1xuICAgIGZ1bmN0aW9uIHBhdGhzKHBzKSB7XG4gICAgICAgIHZhciBwID0gcGF0aHMucHMgPSBwYXRocy5wcyB8fCB7fTtcbiAgICAgICAgaWYgKHBbcHNdKSB7XG4gICAgICAgICAgICBwW3BzXS5zbGVlcCA9IDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBbcHNdID0ge1xuICAgICAgICAgICAgICAgIHNsZWVwOiAxMDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcCkgaWYgKHBbaGFzXShrZXkpICYmIGtleSAhPSBwcykge1xuICAgICAgICAgICAgICAgIHBba2V5XS5zbGVlcC0tO1xuICAgICAgICAgICAgICAgICFwW2tleV0uc2xlZXAgJiYgZGVsZXRlIHBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwW3BzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm94KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHkgPSB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHdpZHRoID0geC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgaDogaGVpZ2h0LFxuICAgICAgICAgICAgeDI6IHggKyB3aWR0aCxcbiAgICAgICAgICAgIHkyOiB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgY3g6IHggKyB3aWR0aCAvIDIsXG4gICAgICAgICAgICBjeTogeSArIGhlaWdodCAvIDIsXG4gICAgICAgICAgICByMTogbWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgcjI6IG1hdGgubWF4KHdpZHRoLCBoZWlnaHQpIC8gMixcbiAgICAgICAgICAgIHIwOiBtYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgcGF0aDogcmVjdFBhdGgoeCwgeSwgd2lkdGgsIGhlaWdodCksXG4gICAgICAgICAgICB2YjogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oXCIgXCIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKFwiLFwiKS5yZXBsYWNlKHAycywgXCIkMVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aENsb25lKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcmVzID0gY2xvbmUocGF0aEFycmF5KTtcbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYmV6bGVuKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kRG90c0F0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSxcbiAgICAgICAgICAgICAgICBnZXRUb3RMZW4ocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIGxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExlbmd0aEZhY3RvcnkoaXN0b3RhbCwgc3VicGF0aCkge1xuICAgICAgICBmdW5jdGlvbiBPKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICsoK3ZhbCkudG9GaXhlZCgzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5fLmNhY2hlcihmdW5jdGlvbiAocGF0aCwgbGVuZ3RoLCBvbmx5c3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChwYXRoIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLmF0dHIoXCJkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgICAgICB2YXIgeCwgeSwgcCwgbCwgc3AgPSBcIlwiLCBzdWJwYXRocyA9IHt9LCBwb2ludCxcbiAgICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gK3BbMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuICsgbCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnBhdGggJiYgIXN1YnBhdGhzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBnZXRQb2ludEF0U2VnbWVudExlbmd0aCh4LCB5LCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCBwWzZdLCBsZW5ndGggLSBsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwICs9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDXCIgKyBPKHBvaW50LnN0YXJ0LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LnN0YXJ0LnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50Lm0ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQubS55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC55KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlzdGFydCkge3JldHVybiBzcDt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicGF0aHMuc3RhcnQgPSBzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNXCIgKyBPKHBvaW50LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LnkpICsgXCJDXCIgKyBPKHBvaW50Lm4ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQubi55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC5lbmQueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQuZW5kLnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBbNV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBbNl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuICs9IGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArcFs2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXN0b3RhbCAmJiAhc3VicGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gZ2V0UG9pbnRBdFNlZ21lbnRMZW5ndGgoeCwgeSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgcFs2XSwgbGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IGw7XG4gICAgICAgICAgICAgICAgICAgIHggPSArcFs1XTtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICtwWzZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcCArPSBwLnNoaWZ0KCkgKyBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicGF0aHMuZW5kID0gc3A7XG4gICAgICAgICAgICBwb2ludCA9IGlzdG90YWwgPyBsZW4gOiBzdWJwYXRoID8gc3VicGF0aHMgOiBmaW5kRG90c0F0U2VnbWVudCh4LCB5LCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSwgbnVsbCwgU25hcC5fLmNsb25lKTtcbiAgICB9XG4gICAgdmFyIGdldFRvdGFsTGVuZ3RoID0gZ2V0TGVuZ3RoRmFjdG9yeSgxKSxcbiAgICAgICAgZ2V0UG9pbnRBdExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoKSxcbiAgICAgICAgZ2V0U3VicGF0aHNBdExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoMCwgMSk7XG4gICAgZnVuY3Rpb24gZmluZERvdHNBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQpIHtcbiAgICAgICAgdmFyIHQxID0gMSAtIHQsXG4gICAgICAgICAgICB0MTMgPSBwb3codDEsIDMpLFxuICAgICAgICAgICAgdDEyID0gcG93KHQxLCAyKSxcbiAgICAgICAgICAgIHQyID0gdCAqIHQsXG4gICAgICAgICAgICB0MyA9IHQyICogdCxcbiAgICAgICAgICAgIHggPSB0MTMgKiBwMXggKyB0MTIgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgdDMgKiBwMngsXG4gICAgICAgICAgICB5ID0gdDEzICogcDF5ICsgdDEyICogMyAqIHQgKiBjMXkgKyB0MSAqIDMgKiB0ICogdCAqIGMyeSArIHQzICogcDJ5LFxuICAgICAgICAgICAgbXggPSBwMXggKyAyICogdCAqIChjMXggLSBwMXgpICsgdDIgKiAoYzJ4IC0gMiAqIGMxeCArIHAxeCksXG4gICAgICAgICAgICBteSA9IHAxeSArIDIgKiB0ICogKGMxeSAtIHAxeSkgKyB0MiAqIChjMnkgLSAyICogYzF5ICsgcDF5KSxcbiAgICAgICAgICAgIG54ID0gYzF4ICsgMiAqIHQgKiAoYzJ4IC0gYzF4KSArIHQyICogKHAyeCAtIDIgKiBjMnggKyBjMXgpLFxuICAgICAgICAgICAgbnkgPSBjMXkgKyAyICogdCAqIChjMnkgLSBjMXkpICsgdDIgKiAocDJ5IC0gMiAqIGMyeSArIGMxeSksXG4gICAgICAgICAgICBheCA9IHQxICogcDF4ICsgdCAqIGMxeCxcbiAgICAgICAgICAgIGF5ID0gdDEgKiBwMXkgKyB0ICogYzF5LFxuICAgICAgICAgICAgY3ggPSB0MSAqIGMyeCArIHQgKiBwMngsXG4gICAgICAgICAgICBjeSA9IHQxICogYzJ5ICsgdCAqIHAyeSxcbiAgICAgICAgICAgIGFscGhhID0gKDkwIC0gbWF0aC5hdGFuMihteCAtIG54LCBteSAtIG55KSAqIDE4MCAvIFBJKTtcbiAgICAgICAgLy8gKG14ID4gbnggfHwgbXkgPCBueSkgJiYgKGFscGhhICs9IDE4MCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIG06IHt4OiBteCwgeTogbXl9LFxuICAgICAgICAgICAgbjoge3g6IG54LCB5OiBueX0sXG4gICAgICAgICAgICBzdGFydDoge3g6IGF4LCB5OiBheX0sXG4gICAgICAgICAgICBlbmQ6IHt4OiBjeCwgeTogY3l9LFxuICAgICAgICAgICAgYWxwaGE6IGFscGhhXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJlemllckJCb3gocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnkpIHtcbiAgICAgICAgaWYgKCFTbmFwLmlzKHAxeCwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgcDF4ID0gW3AxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmJveCA9IGN1cnZlRGltLmFwcGx5KG51bGwsIHAxeCk7XG4gICAgICAgIHJldHVybiBib3goXG4gICAgICAgICAgICBiYm94Lm1pbi54LFxuICAgICAgICAgICAgYmJveC5taW4ueSxcbiAgICAgICAgICAgIGJib3gubWF4LnggLSBiYm94Lm1pbi54LFxuICAgICAgICAgICAgYmJveC5tYXgueSAtIGJib3gubWluLnlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gIHggPj0gYmJveC54ICYmXG4gICAgICAgICAgICAgICAgeCA8PSBiYm94LnggKyBiYm94LndpZHRoICYmXG4gICAgICAgICAgICAgICAgeSA+PSBiYm94LnkgJiZcbiAgICAgICAgICAgICAgICB5IDw9IGJib3gueSArIGJib3guaGVpZ2h0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0JCb3hJbnRlcnNlY3QoYmJveDEsIGJib3gyKSB7XG4gICAgICAgIGJib3gxID0gYm94KGJib3gxKTtcbiAgICAgICAgYmJveDIgPSBib3goYmJveDIpO1xuICAgICAgICByZXR1cm4gaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueDIsIGJib3gxLnkpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueCwgYmJveDEueTIpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueDIsIGJib3gxLnkyKVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngsIGJib3gyLnkpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueDIsIGJib3gyLnkpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueCwgYmJveDIueTIpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueDIsIGJib3gyLnkyKVxuICAgICAgICAgICAgfHwgKGJib3gxLnggPCBiYm94Mi54MiAmJiBiYm94MS54ID4gYmJveDIueFxuICAgICAgICAgICAgICAgIHx8IGJib3gyLnggPCBiYm94MS54MiAmJiBiYm94Mi54ID4gYmJveDEueClcbiAgICAgICAgICAgICYmIChiYm94MS55IDwgYmJveDIueTIgJiYgYmJveDEueSA+IGJib3gyLnlcbiAgICAgICAgICAgICAgICB8fCBiYm94Mi55IDwgYmJveDEueTIgJiYgYmJveDIueSA+IGJib3gxLnkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNlMyh0LCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICB2YXIgdDEgPSAtMyAqIHAxICsgOSAqIHAyIC0gOSAqIHAzICsgMyAqIHA0LFxuICAgICAgICAgICAgdDIgPSB0ICogdDEgKyA2ICogcDEgLSAxMiAqIHAyICsgNiAqIHAzO1xuICAgICAgICByZXR1cm4gdCAqIHQyIC0gMyAqIHAxICsgMyAqIHAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB6KSB7XG4gICAgICAgIGlmICh6ID09IG51bGwpIHtcbiAgICAgICAgICAgIHogPSAxO1xuICAgICAgICB9XG4gICAgICAgIHogPSB6ID4gMSA/IDEgOiB6IDwgMCA/IDAgOiB6O1xuICAgICAgICB2YXIgejIgPSB6IC8gMixcbiAgICAgICAgICAgIG4gPSAxMixcbiAgICAgICAgICAgIFR2YWx1ZXMgPSBbLS4xMjUyLC4xMjUyLC0uMzY3OCwuMzY3OCwtLjU4NzMsLjU4NzMsLS43Njk5LC43Njk5LC0uOTA0MSwuOTA0MSwtLjk4MTYsLjk4MTZdLFxuICAgICAgICAgICAgQ3ZhbHVlcyA9IFswLjI0OTEsMC4yNDkxLDAuMjMzNSwwLjIzMzUsMC4yMDMyLDAuMjAzMiwwLjE2MDEsMC4xNjAxLDAuMTA2OSwwLjEwNjksMC4wNDcyLDAuMDQ3Ml0sXG4gICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGN0ID0gejIgKiBUdmFsdWVzW2ldICsgejIsXG4gICAgICAgICAgICAgICAgeGJhc2UgPSBiYXNlMyhjdCwgeDEsIHgyLCB4MywgeDQpLFxuICAgICAgICAgICAgICAgIHliYXNlID0gYmFzZTMoY3QsIHkxLCB5MiwgeTMsIHk0KSxcbiAgICAgICAgICAgICAgICBjb21iID0geGJhc2UgKiB4YmFzZSArIHliYXNlICogeWJhc2U7XG4gICAgICAgICAgICBzdW0gKz0gQ3ZhbHVlc1tpXSAqIG1hdGguc3FydChjb21iKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gejIgKiBzdW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRvdExlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGxsKSB7XG4gICAgICAgIGlmIChsbCA8IDAgfHwgYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCkgPCBsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gMSxcbiAgICAgICAgICAgIHN0ZXAgPSB0IC8gMixcbiAgICAgICAgICAgIHQyID0gdCAtIHN0ZXAsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZSA9IC4wMTtcbiAgICAgICAgbCA9IGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHQyKTtcbiAgICAgICAgd2hpbGUgKGFicyhsIC0gbGwpID4gZSkge1xuICAgICAgICAgICAgc3RlcCAvPSAyO1xuICAgICAgICAgICAgdDIgKz0gKGwgPCBsbCA/IDEgOiAtMSkgKiBzdGVwO1xuICAgICAgICAgICAgbCA9IGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHQyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyc2VjdCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbW1heCh4MSwgeDIpIDwgbW1pbih4MywgeDQpIHx8XG4gICAgICAgICAgICBtbWluKHgxLCB4MikgPiBtbWF4KHgzLCB4NCkgfHxcbiAgICAgICAgICAgIG1tYXgoeTEsIHkyKSA8IG1taW4oeTMsIHk0KSB8fFxuICAgICAgICAgICAgbW1pbih5MSwgeTIpID4gbW1heCh5MywgeTQpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBueCA9ICh4MSAqIHkyIC0geTEgKiB4MikgKiAoeDMgLSB4NCkgLSAoeDEgLSB4MikgKiAoeDMgKiB5NCAtIHkzICogeDQpLFxuICAgICAgICAgICAgbnkgPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gKHgxIC0geDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzIC0geDQpO1xuXG4gICAgICAgIGlmICghZGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHggPSBueCAvIGRlbm9taW5hdG9yLFxuICAgICAgICAgICAgcHkgPSBueSAvIGRlbm9taW5hdG9yLFxuICAgICAgICAgICAgcHgyID0gK3B4LnRvRml4ZWQoMiksXG4gICAgICAgICAgICBweTIgPSArcHkudG9GaXhlZCgyKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcHgyIDwgK21taW4oeDEsIHgyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweDIgPiArbW1heCh4MSwgeDIpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB4MiA8ICttbWluKHgzLCB4NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHgyID4gK21tYXgoeDMsIHg0KS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweTIgPCArbW1pbih5MSwgeTIpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB5MiA+ICttbWF4KHkxLCB5MikudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyIDwgK21taW4oeTMsIHk0KS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweTIgPiArbW1heCh5MywgeTQpLnRvRml4ZWQoMilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt4OiBweCwgeTogcHl9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcihiZXoxLCBiZXoyKSB7XG4gICAgICAgIHJldHVybiBpbnRlckhlbHBlcihiZXoxLCBiZXoyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJDb3VudChiZXoxLCBiZXoyKSB7XG4gICAgICAgIHJldHVybiBpbnRlckhlbHBlcihiZXoxLCBiZXoyLCAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJIZWxwZXIoYmV6MSwgYmV6MiwganVzdENvdW50KSB7XG4gICAgICAgIHZhciBiYm94MSA9IGJlemllckJCb3goYmV6MSksXG4gICAgICAgICAgICBiYm94MiA9IGJlemllckJCb3goYmV6Mik7XG4gICAgICAgIGlmICghaXNCQm94SW50ZXJzZWN0KGJib3gxLCBiYm94MikpIHtcbiAgICAgICAgICAgIHJldHVybiBqdXN0Q291bnQgPyAwIDogW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGwxID0gYmV6bGVuLmFwcGx5KDAsIGJlejEpLFxuICAgICAgICAgICAgbDIgPSBiZXpsZW4uYXBwbHkoMCwgYmV6MiksXG4gICAgICAgICAgICBuMSA9IH5+KGwxIC8gNSksXG4gICAgICAgICAgICBuMiA9IH5+KGwyIC8gNSksXG4gICAgICAgICAgICBkb3RzMSA9IFtdLFxuICAgICAgICAgICAgZG90czIgPSBbXSxcbiAgICAgICAgICAgIHh5ID0ge30sXG4gICAgICAgICAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjEgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoMCwgYmV6MS5jb25jYXQoaSAvIG4xKSk7XG4gICAgICAgICAgICBkb3RzMS5wdXNoKHt4OiBwLngsIHk6IHAueSwgdDogaSAvIG4xfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG4yICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBwID0gZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoMCwgYmV6Mi5jb25jYXQoaSAvIG4yKSk7XG4gICAgICAgICAgICBkb3RzMi5wdXNoKHt4OiBwLngsIHk6IHAueSwgdDogaSAvIG4yfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG4xOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjI7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBkaSA9IGRvdHMxW2ldLFxuICAgICAgICAgICAgICAgICAgICBkaTEgPSBkb3RzMVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGRqID0gZG90czJbal0sXG4gICAgICAgICAgICAgICAgICAgIGRqMSA9IGRvdHMyW2ogKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgY2kgPSBhYnMoZGkxLnggLSBkaS54KSA8IC4wMDEgPyBcInlcIiA6IFwieFwiLFxuICAgICAgICAgICAgICAgICAgICBjaiA9IGFicyhkajEueCAtIGRqLngpIDwgLjAwMSA/IFwieVwiIDogXCJ4XCIsXG4gICAgICAgICAgICAgICAgICAgIGlzID0gaW50ZXJzZWN0KGRpLngsIGRpLnksIGRpMS54LCBkaTEueSwgZGoueCwgZGoueSwgZGoxLngsIGRqMS55KTtcbiAgICAgICAgICAgICAgICBpZiAoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHh5W2lzLngudG9GaXhlZCg0KV0gPT0gaXMueS50b0ZpeGVkKDQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4eVtpcy54LnRvRml4ZWQoNCldID0gaXMueS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDEgPSBkaS50ICsgYWJzKChpc1tjaV0gLSBkaVtjaV0pIC8gKGRpMVtjaV0gLSBkaVtjaV0pKSAqIChkaTEudCAtIGRpLnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBkai50ICsgYWJzKChpc1tjal0gLSBkaltjal0pIC8gKGRqMVtjal0gLSBkaltjal0pKSAqIChkajEudCAtIGRqLnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxICYmIHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGp1c3RDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGlzLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGlzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxOiB0MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDI6IHQyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aEludGVyc2VjdGlvbihwYXRoMSwgcGF0aDIpIHtcbiAgICAgICAgcmV0dXJuIGludGVyUGF0aEhlbHBlcihwYXRoMSwgcGF0aDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXRoSW50ZXJzZWN0aW9uTnVtYmVyKHBhdGgxLCBwYXRoMikge1xuICAgICAgICByZXR1cm4gaW50ZXJQYXRoSGVscGVyKHBhdGgxLCBwYXRoMiwgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyUGF0aEhlbHBlcihwYXRoMSwgcGF0aDIsIGp1c3RDb3VudCkge1xuICAgICAgICBwYXRoMSA9IHBhdGgyY3VydmUocGF0aDEpO1xuICAgICAgICBwYXRoMiA9IHBhdGgyY3VydmUocGF0aDIpO1xuICAgICAgICB2YXIgeDEsIHkxLCB4MiwgeTIsIHgxbSwgeTFtLCB4Mm0sIHkybSwgYmV6MSwgYmV6MixcbiAgICAgICAgICAgIHJlcyA9IGp1c3RDb3VudCA/IDAgOiBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aDEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBpID0gcGF0aDFbaV07XG4gICAgICAgICAgICBpZiAocGlbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICB4MSA9IHgxbSA9IHBpWzFdO1xuICAgICAgICAgICAgICAgIHkxID0geTFtID0gcGlbMl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwaVswXSA9PSBcIkNcIikge1xuICAgICAgICAgICAgICAgICAgICBiZXoxID0gW3gxLCB5MV0uY29uY2F0KHBpLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBiZXoxWzZdO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IGJlejFbN107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmV6MSA9IFt4MSwgeTEsIHgxLCB5MSwgeDFtLCB5MW0sIHgxbSwgeTFtXTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSB4MW07XG4gICAgICAgICAgICAgICAgICAgIHkxID0geTFtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBwYXRoMi5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaiA9IHBhdGgyW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGpbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geDJtID0gcGpbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHkybSA9IHBqWzJdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBqWzBdID09IFwiQ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmV6MiA9IFt4MiwgeTJdLmNvbmNhdChwai5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBiZXoyWzZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gYmV6Mls3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmV6MiA9IFt4MiwgeTIsIHgyLCB5MiwgeDJtLCB5Mm0sIHgybSwgeTJtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgybTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHkybTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRyID0gaW50ZXJIZWxwZXIoYmV6MSwgYmV6MiwganVzdENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqdXN0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gaW50cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gaW50ci5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uc2VnbWVudDEgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQyID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50cltrXS5iZXoxID0gYmV6MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50cltrXS5iZXoyID0gYmV6MjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChpbnRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1BvaW50SW5zaWRlUGF0aChwYXRoLCB4LCB5KSB7XG4gICAgICAgIHZhciBiYm94ID0gcGF0aEJCb3gocGF0aCk7XG4gICAgICAgIHJldHVybiBpc1BvaW50SW5zaWRlQkJveChiYm94LCB4LCB5KSAmJlxuICAgICAgICAgICAgICAgaW50ZXJQYXRoSGVscGVyKHBhdGgsIFtbXCJNXCIsIHgsIHldLCBbXCJIXCIsIGJib3gueDIgKyAxMF1dLCAxKSAlIDIgPT0gMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aEJCb3gocGF0aCkge1xuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aCk7XG4gICAgICAgIGlmIChwdGguYmJveCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lKHB0aC5iYm94KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBib3goKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gcGF0aDJjdXJ2ZShwYXRoKTtcbiAgICAgICAgdmFyIHggPSAwLFxuICAgICAgICAgICAgeSA9IDAsXG4gICAgICAgICAgICBYID0gW10sXG4gICAgICAgICAgICBZID0gW10sXG4gICAgICAgICAgICBwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXRoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHAgPSBwYXRoW2ldO1xuICAgICAgICAgICAgaWYgKHBbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICB4ID0gcFsxXTtcbiAgICAgICAgICAgICAgICB5ID0gcFsyXTtcbiAgICAgICAgICAgICAgICBYLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgWS5wdXNoKHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGltID0gY3VydmVEaW0oeCwgeSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgcFs2XSk7XG4gICAgICAgICAgICAgICAgWCA9IFguY29uY2F0KGRpbS5taW4ueCwgZGltLm1heC54KTtcbiAgICAgICAgICAgICAgICBZID0gWS5jb25jYXQoZGltLm1pbi55LCBkaW0ubWF4LnkpO1xuICAgICAgICAgICAgICAgIHggPSBwWzVdO1xuICAgICAgICAgICAgICAgIHkgPSBwWzZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB4bWluID0gbW1pbi5hcHBseSgwLCBYKSxcbiAgICAgICAgICAgIHltaW4gPSBtbWluLmFwcGx5KDAsIFkpLFxuICAgICAgICAgICAgeG1heCA9IG1tYXguYXBwbHkoMCwgWCksXG4gICAgICAgICAgICB5bWF4ID0gbW1heC5hcHBseSgwLCBZKSxcbiAgICAgICAgICAgIGJiID0gYm94KHhtaW4sIHltaW4sIHhtYXggLSB4bWluLCB5bWF4IC0geW1pbik7XG4gICAgICAgIHB0aC5iYm94ID0gY2xvbmUoYmIpO1xuICAgICAgICByZXR1cm4gYmI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3RQYXRoKHgsIHksIHcsIGgsIHIpIHtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgW1wiTVwiLCB4ICsgciwgeV0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCB3IC0gciAqIDIsIDBdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCAwLCBoIC0gciAqIDJdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgLXIsIHJdLFxuICAgICAgICAgICAgICAgIFtcImxcIiwgciAqIDIgLSB3LCAwXSxcbiAgICAgICAgICAgICAgICBbXCJhXCIsIHIsIHIsIDAsIDAsIDEsIC1yLCAtcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCAwLCByICogMiAtIGhdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgLXJdLFxuICAgICAgICAgICAgICAgIFtcInpcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IFtbXCJNXCIsIHgsIHldLCBbXCJsXCIsIHcsIDBdLCBbXCJsXCIsIDAsIGhdLCBbXCJsXCIsIC13LCAwXSwgW1wielwiXV07XG4gICAgICAgIHJlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGxpcHNlUGF0aCh4LCB5LCByeCwgcnksIGEpIHtcbiAgICAgICAgaWYgKGEgPT0gbnVsbCAmJiByeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByeSA9IHJ4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgICAgICAgICAgIHgxID0geCArIHJ4ICogTWF0aC5jb3MoLXJ5ICogcmFkKSxcbiAgICAgICAgICAgICAgICB4MiA9IHggKyByeCAqIE1hdGguY29zKC1hICogcmFkKSxcbiAgICAgICAgICAgICAgICB5MSA9IHkgKyByeCAqIE1hdGguc2luKC1yeSAqIHJhZCksXG4gICAgICAgICAgICAgICAgeTIgPSB5ICsgcnggKiBNYXRoLnNpbigtYSAqIHJhZCksXG4gICAgICAgICAgICAgICAgcmVzID0gW1tcIk1cIiwgeDEsIHkxXSwgW1wiQVwiLCByeCwgcngsIDAsICsoYSAtIHJ5ID4gMTgwKSwgMCwgeDIsIHkyXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBbXG4gICAgICAgICAgICAgICAgW1wiTVwiLCB4LCB5XSxcbiAgICAgICAgICAgICAgICBbXCJtXCIsIDAsIC1yeV0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIDIgKiByeV0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIC0yICogcnldLFxuICAgICAgICAgICAgICAgIFtcInpcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHZhciB1bml0MnB4ID0gU25hcC5fdW5pdDJweCxcbiAgICAgICAgZ2V0UGF0aCA9IHtcbiAgICAgICAgcGF0aDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuYXR0cihcInBhdGhcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHVuaXQycHgoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2VQYXRoKGF0dHIuY3gsIGF0dHIuY3ksIGF0dHIucik7XG4gICAgICAgIH0sXG4gICAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiBlbGxpcHNlUGF0aChhdHRyLmN4LCBhdHRyLmN5LCBhdHRyLnJ4LCBhdHRyLnJ5KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHVuaXQycHgoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGF0dHIueCwgYXR0ci55LCBhdHRyLndpZHRoLCBhdHRyLmhlaWdodCwgYXR0ci5yeCwgYXR0ci5yeSk7XG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gdW5pdDJweChlbCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdFBhdGgoYXR0ci54LCBhdHRyLnksIGF0dHIud2lkdGgsIGF0dHIuaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IGVsLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGc6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSBlbC5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0UGF0aChiYm94LngsIGJib3gueSwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBzeW1ib2w6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSBlbC5nZXRCQm94KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdFBhdGgoYmJveC54LCBiYm94LnksIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNXCIgKyBbZWwuYXR0cihcIngxXCIpLCBlbC5hdHRyKFwieTFcIiksIGVsLmF0dHIoXCJ4MlwiKSwgZWwuYXR0cihcInkyXCIpXTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWxpbmU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTVwiICsgZWwuYXR0cihcInBvaW50c1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNXCIgKyBlbC5hdHRyKFwicG9pbnRzXCIpICsgXCJ6XCI7XG4gICAgICAgIH0sXG4gICAgICAgIHN2ZzogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IGVsLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmx0OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBiYm94ID0gZWwubm9kZS5nZXRCQm94KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdFBhdGgoYmJveC54LCBiYm94LnksIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcGF0aFRvUmVsYXRpdmUocGF0aEFycmF5KSB7XG4gICAgICAgIHZhciBwdGggPSBwYXRocyhwYXRoQXJyYXkpLFxuICAgICAgICAgICAgbG93ZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZTtcbiAgICAgICAgaWYgKHB0aC5yZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLnJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFTbmFwLmlzKHBhdGhBcnJheSwgXCJhcnJheVwiKSB8fCAhU25hcC5pcyhwYXRoQXJyYXkgJiYgcGF0aEFycmF5WzBdLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBwYXRoQXJyYXkgPSBTbmFwLnBhcnNlUGF0aFN0cmluZyhwYXRoQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIHggPSAwLFxuICAgICAgICAgICAgeSA9IDAsXG4gICAgICAgICAgICBteCA9IDAsXG4gICAgICAgICAgICBteSA9IDAsXG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGlmIChwYXRoQXJyYXlbMF1bMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgIHggPSBwYXRoQXJyYXlbMF1bMV07XG4gICAgICAgICAgICB5ID0gcGF0aEFycmF5WzBdWzJdO1xuICAgICAgICAgICAgbXggPSB4O1xuICAgICAgICAgICAgbXkgPSB5O1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICAgIHJlcy5wdXNoKFtcIk1cIiwgeCwgeV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSBwYXRoQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIHIgPSByZXNbaV0gPSBbXSxcbiAgICAgICAgICAgICAgICBwYSA9IHBhdGhBcnJheVtpXTtcbiAgICAgICAgICAgIGlmIChwYVswXSAhPSBsb3dlckNhc2UuY2FsbChwYVswXSkpIHtcbiAgICAgICAgICAgICAgICByWzBdID0gbG93ZXJDYXNlLmNhbGwocGFbMF0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgclsyXSA9IHBhWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgclszXSA9IHBhWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls0XSA9IHBhWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls1XSA9IHBhWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls2XSA9ICsocGFbNl0gLSB4KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls3XSA9ICsocGFbN10gLSB5KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gKyhwYVsxXSAtIHkpLnRvRml4ZWQoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gcGFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBteSA9IHBhWzJdO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDEsIGpqID0gcGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbal0gPSArKHBhW2pdIC0gKChqICUgMikgPyB4IDogeSkpLnRvRml4ZWQoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByID0gcmVzW2ldID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHBhWzBdID09IFwibVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG14ID0gcGFbMV0gKyB4O1xuICAgICAgICAgICAgICAgICAgICBteSA9IHBhWzJdICsgeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gcGEubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICByZXNbaV1ba10gPSBwYVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuID0gcmVzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzW2ldWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgICAgICAgICAgeCA9IG14O1xuICAgICAgICAgICAgICAgICAgICB5ID0gbXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICAgICAgICAgIHggKz0gK3Jlc1tpXVtsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICAgICAgeSArPSArcmVzW2ldW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB4ICs9ICtyZXNbaV1bbGVuIC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gK3Jlc1tpXVtsZW4gLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICAgICAgcHRoLnJlbCA9IHBhdGhDbG9uZShyZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXRoVG9BYnNvbHV0ZShwYXRoQXJyYXkpIHtcbiAgICAgICAgdmFyIHB0aCA9IHBhdGhzKHBhdGhBcnJheSk7XG4gICAgICAgIGlmIChwdGguYWJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5hYnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXMocGF0aEFycmF5LCBcImFycmF5XCIpIHx8ICFpcyhwYXRoQXJyYXkgJiYgcGF0aEFycmF5WzBdLCBcImFycmF5XCIpKSB7IC8vIHJvdWdoIGFzc3VtcHRpb25cbiAgICAgICAgICAgIHBhdGhBcnJheSA9IFNuYXAucGFyc2VQYXRoU3RyaW5nKHBhdGhBcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRoQXJyYXkgfHwgIXBhdGhBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbW1wiTVwiLCAwLCAwXV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgeCA9IDAsXG4gICAgICAgICAgICB5ID0gMCxcbiAgICAgICAgICAgIG14ID0gMCxcbiAgICAgICAgICAgIG15ID0gMCxcbiAgICAgICAgICAgIHN0YXJ0ID0gMCxcbiAgICAgICAgICAgIHBhMDtcbiAgICAgICAgaWYgKHBhdGhBcnJheVswXVswXSA9PSBcIk1cIikge1xuICAgICAgICAgICAgeCA9ICtwYXRoQXJyYXlbMF1bMV07XG4gICAgICAgICAgICB5ID0gK3BhdGhBcnJheVswXVsyXTtcbiAgICAgICAgICAgIG14ID0geDtcbiAgICAgICAgICAgIG15ID0geTtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgICAgICByZXNbMF0gPSBbXCJNXCIsIHgsIHldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcnogPSBwYXRoQXJyYXkubGVuZ3RoID09IDMgJiZcbiAgICAgICAgICAgIHBhdGhBcnJheVswXVswXSA9PSBcIk1cIiAmJlxuICAgICAgICAgICAgcGF0aEFycmF5WzFdWzBdLnRvVXBwZXJDYXNlKCkgPT0gXCJSXCIgJiZcbiAgICAgICAgICAgIHBhdGhBcnJheVsyXVswXS50b1VwcGVyQ2FzZSgpID09IFwiWlwiO1xuICAgICAgICBmb3IgKHZhciByLCBwYSwgaSA9IHN0YXJ0LCBpaSA9IHBhdGhBcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICByZXMucHVzaChyID0gW10pO1xuICAgICAgICAgICAgcGEgPSBwYXRoQXJyYXlbaV07XG4gICAgICAgICAgICBwYTAgPSBwYVswXTtcbiAgICAgICAgICAgIGlmIChwYTAgIT0gcGEwLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByWzBdID0gcGEwLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChyWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gcGFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByWzJdID0gcGFbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByWzNdID0gcGFbM107XG4gICAgICAgICAgICAgICAgICAgICAgICByWzRdID0gcGFbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICByWzVdID0gcGFbNV07XG4gICAgICAgICAgICAgICAgICAgICAgICByWzZdID0gKyhwYVs2XSArIHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls3XSA9ICsocGFbN10gKyB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICtwYVsxXSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJSXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90cyA9IFt4LCB5XS5jb25jYXQocGEuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDIsIGpqID0gZG90cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90c1tqXSA9ICtkb3RzW2pdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RzWysral0gPSArZG90c1tqXSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGNhdG11bGxSb20yYmV6aWVyKGRvdHMsIGNyeikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJPXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzID0gZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdHMucHVzaChkb3RzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZG90cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdLCBwYVszXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IFtcIlVcIl0uY29uY2F0KHJlc1tyZXMubGVuZ3RoIC0gMV0uc2xpY2UoLTIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbXggPSArcGFbMV0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSArcGFbMl0gKyB5O1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMSwgamogPSBwYS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcltqXSA9ICtwYVtqXSArICgoaiAlIDIpID8geCA6IHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGEwID09IFwiUlwiKSB7XG4gICAgICAgICAgICAgICAgZG90cyA9IFt4LCB5XS5jb25jYXQocGEuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGNhdG11bGxSb20yYmV6aWVyKGRvdHMsIGNyeikpO1xuICAgICAgICAgICAgICAgIHIgPSBbXCJSXCJdLmNvbmNhdChwYS5zbGljZSgtMikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYTAgPT0gXCJPXCIpIHtcbiAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZG90cyA9IGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSk7XG4gICAgICAgICAgICAgICAgZG90cy5wdXNoKGRvdHNbMF0pO1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZG90cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhMCA9PSBcIlVcIikge1xuICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSwgcGFbM10pKTtcbiAgICAgICAgICAgICAgICByID0gW1wiVVwiXS5jb25jYXQocmVzW3Jlcy5sZW5ndGggLSAxXS5zbGljZSgtMikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwYS5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJba10gPSBwYVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYTAgPSBwYTAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChwYTAgIT0gXCJPXCIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBteDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBteTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICBwdGguYWJzID0gcGF0aENsb25lKHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGwyYyh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyLCB4MiwgeTJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxMmMoeDEsIHkxLCBheCwgYXksIHgyLCB5Mikge1xuICAgICAgICB2YXIgXzEzID0gMSAvIDMsXG4gICAgICAgICAgICBfMjMgPSAyIC8gMztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBfMTMgKiB4MSArIF8yMyAqIGF4LFxuICAgICAgICAgICAgICAgIF8xMyAqIHkxICsgXzIzICogYXksXG4gICAgICAgICAgICAgICAgXzEzICogeDIgKyBfMjMgKiBheCxcbiAgICAgICAgICAgICAgICBfMTMgKiB5MiArIF8yMyAqIGF5LFxuICAgICAgICAgICAgICAgIHgyLFxuICAgICAgICAgICAgICAgIHkyXG4gICAgICAgICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhMmMoeDEsIHkxLCByeCwgcnksIGFuZ2xlLCBsYXJnZV9hcmNfZmxhZywgc3dlZXBfZmxhZywgeDIsIHkyLCByZWN1cnNpdmUpIHtcbiAgICAgICAgLy8gZm9yIG1vcmUgaW5mb3JtYXRpb24gb2Ygd2hlcmUgdGhpcyBtYXRoIGNhbWUgZnJvbSB2aXNpdDpcbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgIHZhciBfMTIwID0gUEkgKiAxMjAgLyAxODAsXG4gICAgICAgICAgICByYWQgPSBQSSAvIDE4MCAqICgrYW5nbGUgfHwgMCksXG4gICAgICAgICAgICByZXMgPSBbXSxcbiAgICAgICAgICAgIHh5LFxuICAgICAgICAgICAgcm90YXRlID0gU25hcC5fLmNhY2hlcihmdW5jdGlvbiAoeCwgeSwgcmFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIFggPSB4ICogbWF0aC5jb3MocmFkKSAtIHkgKiBtYXRoLnNpbihyYWQpLFxuICAgICAgICAgICAgICAgICAgICBZID0geCAqIG1hdGguc2luKHJhZCkgKyB5ICogbWF0aC5jb3MocmFkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3g6IFgsIHk6IFl9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVjdXJzaXZlKSB7XG4gICAgICAgICAgICB4eSA9IHJvdGF0ZSh4MSwgeTEsIC1yYWQpO1xuICAgICAgICAgICAgeDEgPSB4eS54O1xuICAgICAgICAgICAgeTEgPSB4eS55O1xuICAgICAgICAgICAgeHkgPSByb3RhdGUoeDIsIHkyLCAtcmFkKTtcbiAgICAgICAgICAgIHgyID0geHkueDtcbiAgICAgICAgICAgIHkyID0geHkueTtcbiAgICAgICAgICAgIHZhciBjb3MgPSBtYXRoLmNvcyhQSSAvIDE4MCAqIGFuZ2xlKSxcbiAgICAgICAgICAgICAgICBzaW4gPSBtYXRoLnNpbihQSSAvIDE4MCAqIGFuZ2xlKSxcbiAgICAgICAgICAgICAgICB4ID0gKHgxIC0geDIpIC8gMixcbiAgICAgICAgICAgICAgICB5ID0gKHkxIC0geTIpIC8gMjtcbiAgICAgICAgICAgIHZhciBoID0gKHggKiB4KSAvIChyeCAqIHJ4KSArICh5ICogeSkgLyAocnkgKiByeSk7XG4gICAgICAgICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgICAgICAgICBoID0gbWF0aC5zcXJ0KGgpO1xuICAgICAgICAgICAgICAgIHJ4ID0gaCAqIHJ4O1xuICAgICAgICAgICAgICAgIHJ5ID0gaCAqIHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJ4MiA9IHJ4ICogcngsXG4gICAgICAgICAgICAgICAgcnkyID0gcnkgKiByeSxcbiAgICAgICAgICAgICAgICBrID0gKGxhcmdlX2FyY19mbGFnID09IHN3ZWVwX2ZsYWcgPyAtMSA6IDEpICpcbiAgICAgICAgICAgICAgICAgICAgbWF0aC5zcXJ0KGFicygocngyICogcnkyIC0gcngyICogeSAqIHkgLSByeTIgKiB4ICogeCkgLyAocngyICogeSAqIHkgKyByeTIgKiB4ICogeCkpKSxcbiAgICAgICAgICAgICAgICBjeCA9IGsgKiByeCAqIHkgLyByeSArICh4MSArIHgyKSAvIDIsXG4gICAgICAgICAgICAgICAgY3kgPSBrICogLXJ5ICogeCAvIHJ4ICsgKHkxICsgeTIpIC8gMixcbiAgICAgICAgICAgICAgICBmMSA9IG1hdGguYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpLFxuICAgICAgICAgICAgICAgIGYyID0gbWF0aC5hc2luKCgoeTIgLSBjeSkgLyByeSkudG9GaXhlZCg5KSk7XG5cbiAgICAgICAgICAgIGYxID0geDEgPCBjeCA/IFBJIC0gZjEgOiBmMTtcbiAgICAgICAgICAgIGYyID0geDIgPCBjeCA/IFBJIC0gZjIgOiBmMjtcbiAgICAgICAgICAgIGYxIDwgMCAmJiAoZjEgPSBQSSAqIDIgKyBmMSk7XG4gICAgICAgICAgICBmMiA8IDAgJiYgKGYyID0gUEkgKiAyICsgZjIpO1xuICAgICAgICAgICAgaWYgKHN3ZWVwX2ZsYWcgJiYgZjEgPiBmMikge1xuICAgICAgICAgICAgICAgIGYxID0gZjEgLSBQSSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSkge1xuICAgICAgICAgICAgICAgIGYyID0gZjIgLSBQSSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmMSA9IHJlY3Vyc2l2ZVswXTtcbiAgICAgICAgICAgIGYyID0gcmVjdXJzaXZlWzFdO1xuICAgICAgICAgICAgY3ggPSByZWN1cnNpdmVbMl07XG4gICAgICAgICAgICBjeSA9IHJlY3Vyc2l2ZVszXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGYgPSBmMiAtIGYxO1xuICAgICAgICBpZiAoYWJzKGRmKSA+IF8xMjApIHtcbiAgICAgICAgICAgIHZhciBmMm9sZCA9IGYyLFxuICAgICAgICAgICAgICAgIHgyb2xkID0geDIsXG4gICAgICAgICAgICAgICAgeTJvbGQgPSB5MjtcbiAgICAgICAgICAgIGYyID0gZjEgKyBfMTIwICogKHN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSA/IDEgOiAtMSk7XG4gICAgICAgICAgICB4MiA9IGN4ICsgcnggKiBtYXRoLmNvcyhmMik7XG4gICAgICAgICAgICB5MiA9IGN5ICsgcnkgKiBtYXRoLnNpbihmMik7XG4gICAgICAgICAgICByZXMgPSBhMmMoeDIsIHkyLCByeCwgcnksIGFuZ2xlLCAwLCBzd2VlcF9mbGFnLCB4Mm9sZCwgeTJvbGQsIFtmMiwgZjJvbGQsIGN4LCBjeV0pO1xuICAgICAgICB9XG4gICAgICAgIGRmID0gZjIgLSBmMTtcbiAgICAgICAgdmFyIGMxID0gbWF0aC5jb3MoZjEpLFxuICAgICAgICAgICAgczEgPSBtYXRoLnNpbihmMSksXG4gICAgICAgICAgICBjMiA9IG1hdGguY29zKGYyKSxcbiAgICAgICAgICAgIHMyID0gbWF0aC5zaW4oZjIpLFxuICAgICAgICAgICAgdCA9IG1hdGgudGFuKGRmIC8gNCksXG4gICAgICAgICAgICBoeCA9IDQgLyAzICogcnggKiB0LFxuICAgICAgICAgICAgaHkgPSA0IC8gMyAqIHJ5ICogdCxcbiAgICAgICAgICAgIG0xID0gW3gxLCB5MV0sXG4gICAgICAgICAgICBtMiA9IFt4MSArIGh4ICogczEsIHkxIC0gaHkgKiBjMV0sXG4gICAgICAgICAgICBtMyA9IFt4MiArIGh4ICogczIsIHkyIC0gaHkgKiBjMl0sXG4gICAgICAgICAgICBtNCA9IFt4MiwgeTJdO1xuICAgICAgICBtMlswXSA9IDIgKiBtMVswXSAtIG0yWzBdO1xuICAgICAgICBtMlsxXSA9IDIgKiBtMVsxXSAtIG0yWzFdO1xuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpLmpvaW4oKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB2YXIgbmV3cmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld3Jlc1tpXSA9IGkgJSAyID8gcm90YXRlKHJlc1tpIC0gMV0sIHJlc1tpXSwgcmFkKS55IDogcm90YXRlKHJlc1tpXSwgcmVzW2kgKyAxXSwgcmFkKS54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld3JlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRG90QXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0KSB7XG4gICAgICAgIHZhciB0MSA9IDEgLSB0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcG93KHQxLCAzKSAqIHAxeCArIHBvdyh0MSwgMikgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgcG93KHQsIDMpICogcDJ4LFxuICAgICAgICAgICAgeTogcG93KHQxLCAzKSAqIHAxeSArIHBvdyh0MSwgMikgKiAzICogdCAqIGMxeSArIHQxICogMyAqIHQgKiB0ICogYzJ5ICsgcG93KHQsIDMpICogcDJ5XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1cnZlRGltKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KSB7XG4gICAgICAgIHZhciBhID0gKGMyeCAtIDIgKiBjMXggKyBwMXgpIC0gKHAyeCAtIDIgKiBjMnggKyBjMXgpLFxuICAgICAgICAgICAgYiA9IDIgKiAoYzF4IC0gcDF4KSAtIDIgKiAoYzJ4IC0gYzF4KSxcbiAgICAgICAgICAgIGMgPSBwMXggLSBjMXgsXG4gICAgICAgICAgICB0MSA9ICgtYiArIG1hdGguc3FydChiICogYiAtIDQgKiBhICogYykpIC8gMiAvIGEsXG4gICAgICAgICAgICB0MiA9ICgtYiAtIG1hdGguc3FydChiICogYiAtIDQgKiBhICogYykpIC8gMiAvIGEsXG4gICAgICAgICAgICB5ID0gW3AxeSwgcDJ5XSxcbiAgICAgICAgICAgIHggPSBbcDF4LCBwMnhdLFxuICAgICAgICAgICAgZG90O1xuICAgICAgICBhYnModDEpID4gXCIxZTEyXCIgJiYgKHQxID0gLjUpO1xuICAgICAgICBhYnModDIpID4gXCIxZTEyXCIgJiYgKHQyID0gLjUpO1xuICAgICAgICBpZiAodDEgPiAwICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgZG90ID0gZmluZERvdEF0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgdDEpO1xuICAgICAgICAgICAgeC5wdXNoKGRvdC54KTtcbiAgICAgICAgICAgIHkucHVzaChkb3QueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQyID4gMCAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgIGRvdCA9IGZpbmREb3RBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQyKTtcbiAgICAgICAgICAgIHgucHVzaChkb3QueCk7XG4gICAgICAgICAgICB5LnB1c2goZG90LnkpO1xuICAgICAgICB9XG4gICAgICAgIGEgPSAoYzJ5IC0gMiAqIGMxeSArIHAxeSkgLSAocDJ5IC0gMiAqIGMyeSArIGMxeSk7XG4gICAgICAgIGIgPSAyICogKGMxeSAtIHAxeSkgLSAyICogKGMyeSAtIGMxeSk7XG4gICAgICAgIGMgPSBwMXkgLSBjMXk7XG4gICAgICAgIHQxID0gKC1iICsgbWF0aC5zcXJ0KGIgKiBiIC0gNCAqIGEgKiBjKSkgLyAyIC8gYTtcbiAgICAgICAgdDIgPSAoLWIgLSBtYXRoLnNxcnQoYiAqIGIgLSA0ICogYSAqIGMpKSAvIDIgLyBhO1xuICAgICAgICBhYnModDEpID4gXCIxZTEyXCIgJiYgKHQxID0gLjUpO1xuICAgICAgICBhYnModDIpID4gXCIxZTEyXCIgJiYgKHQyID0gLjUpO1xuICAgICAgICBpZiAodDEgPiAwICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgZG90ID0gZmluZERvdEF0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgdDEpO1xuICAgICAgICAgICAgeC5wdXNoKGRvdC54KTtcbiAgICAgICAgICAgIHkucHVzaChkb3QueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQyID4gMCAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgIGRvdCA9IGZpbmREb3RBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQyKTtcbiAgICAgICAgICAgIHgucHVzaChkb3QueCk7XG4gICAgICAgICAgICB5LnB1c2goZG90LnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IHt4OiBtbWluLmFwcGx5KDAsIHgpLCB5OiBtbWluLmFwcGx5KDAsIHkpfSxcbiAgICAgICAgICAgIG1heDoge3g6IG1tYXguYXBwbHkoMCwgeCksIHk6IG1tYXguYXBwbHkoMCwgeSl9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGgyY3VydmUocGF0aCwgcGF0aDIpIHtcbiAgICAgICAgdmFyIHB0aCA9ICFwYXRoMiAmJiBwYXRocyhwYXRoKTtcbiAgICAgICAgaWYgKCFwYXRoMiAmJiBwdGguY3VydmUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmN1cnZlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHBhdGhUb0Fic29sdXRlKHBhdGgpLFxuICAgICAgICAgICAgcDIgPSBwYXRoMiAmJiBwYXRoVG9BYnNvbHV0ZShwYXRoMiksXG4gICAgICAgICAgICBhdHRycyA9IHt4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbH0sXG4gICAgICAgICAgICBhdHRyczIgPSB7eDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGx9LFxuICAgICAgICAgICAgcHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgZCkge1xuICAgICAgICAgICAgICAgIHZhciBueCwgbnk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJDXCIsIGQueCwgZC55LCBkLngsIGQueSwgZC54LCBkLnldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhKHBhdGhbMF0gaW4ge1Q6MSwgUToxfSkgJiYgKGQucXggPSBkLnF5ID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkLlggPSBwYXRoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5ZID0gcGF0aFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGEyYy5hcHBseSgwLCBbZC54LCBkLnldLmNvbmNhdChwYXRoLnNsaWNlKDEpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBueCA9IGQueCArIChkLnggLSAoZC5ieCB8fCBkLngpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG55ID0gZC55ICsgKGQueSAtIChkLmJ5IHx8IGQueSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIiwgbngsIG55XS5jb25jYXQocGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBkLnggKyAoZC54IC0gKGQucXggfHwgZC54KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnF5ID0gZC55ICsgKGQueSAtIChkLnF5IHx8IGQueSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KHEyYyhkLngsIGQueSwgZC5xeCwgZC5xeSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnF4ID0gcGF0aFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KHEyYyhkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSwgcGF0aFszXSwgcGF0aFs0XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChsMmMoZC54LCBkLnksIHBhdGhbMV0sIGQueSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBkLngsIHBhdGhbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGwyYyhkLngsIGQueSwgZC5YLCBkLlkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXhBcmMgPSBmdW5jdGlvbiAocHAsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHBbaV0ubGVuZ3RoID4gNykge1xuICAgICAgICAgICAgICAgICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHAuc3BsaWNlKGkrKywgMCwgW1wiQ1wiXS5jb25jYXQocGkuc3BsaWNlKDAsIDYpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml4TSA9IGZ1bmN0aW9uIChwYXRoMSwgcGF0aDIsIGExLCBhMiwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoMSAmJiBwYXRoMiAmJiBwYXRoMVtpXVswXSA9PSBcIk1cIiAmJiBwYXRoMltpXVswXSAhPSBcIk1cIikge1xuICAgICAgICAgICAgICAgICAgICBwYXRoMi5zcGxpY2UoaSwgMCwgW1wiTVwiLCBhMi54LCBhMi55XSk7XG4gICAgICAgICAgICAgICAgICAgIGExLmJ4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYTEuYnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBhMS54ID0gcGF0aDFbaV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGExLnkgPSBwYXRoMVtpXVsyXTtcbiAgICAgICAgICAgICAgICAgICAgaWkgPSBtbWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbW1heChwLmxlbmd0aCwgcDIgJiYgcDIubGVuZ3RoIHx8IDApOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcFtpXSA9IHByb2Nlc3NQYXRoKHBbaV0sIGF0dHJzKTtcbiAgICAgICAgICAgIGZpeEFyYyhwLCBpKTtcbiAgICAgICAgICAgIHAyICYmIChwMltpXSA9IHByb2Nlc3NQYXRoKHAyW2ldLCBhdHRyczIpKTtcbiAgICAgICAgICAgIHAyICYmIGZpeEFyYyhwMiwgaSk7XG4gICAgICAgICAgICBmaXhNKHAsIHAyLCBhdHRycywgYXR0cnMyLCBpKTtcbiAgICAgICAgICAgIGZpeE0ocDIsIHAsIGF0dHJzMiwgYXR0cnMsIGkpO1xuICAgICAgICAgICAgdmFyIHNlZyA9IHBbaV0sXG4gICAgICAgICAgICAgICAgc2VnMiA9IHAyICYmIHAyW2ldLFxuICAgICAgICAgICAgICAgIHNlZ2xlbiA9IHNlZy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgc2VnMmxlbiA9IHAyICYmIHNlZzIubGVuZ3RoO1xuICAgICAgICAgICAgYXR0cnMueCA9IHNlZ1tzZWdsZW4gLSAyXTtcbiAgICAgICAgICAgIGF0dHJzLnkgPSBzZWdbc2VnbGVuIC0gMV07XG4gICAgICAgICAgICBhdHRycy5ieCA9IHRvRmxvYXQoc2VnW3NlZ2xlbiAtIDRdKSB8fCBhdHRycy54O1xuICAgICAgICAgICAgYXR0cnMuYnkgPSB0b0Zsb2F0KHNlZ1tzZWdsZW4gLSAzXSkgfHwgYXR0cnMueTtcbiAgICAgICAgICAgIGF0dHJzMi5ieCA9IHAyICYmICh0b0Zsb2F0KHNlZzJbc2VnMmxlbiAtIDRdKSB8fCBhdHRyczIueCk7XG4gICAgICAgICAgICBhdHRyczIuYnkgPSBwMiAmJiAodG9GbG9hdChzZWcyW3NlZzJsZW4gLSAzXSkgfHwgYXR0cnMyLnkpO1xuICAgICAgICAgICAgYXR0cnMyLnggPSBwMiAmJiBzZWcyW3NlZzJsZW4gLSAyXTtcbiAgICAgICAgICAgIGF0dHJzMi55ID0gcDIgJiYgc2VnMltzZWcybGVuIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwMikge1xuICAgICAgICAgICAgcHRoLmN1cnZlID0gcGF0aENsb25lKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwMiA/IFtwLCBwMl0gOiBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXBQYXRoKHBhdGgsIG1hdHJpeCkge1xuICAgICAgICBpZiAoIW1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHgsIHksIGksIGosIGlpLCBqaiwgcGF0aGk7XG4gICAgICAgIHBhdGggPSBwYXRoMmN1cnZlKHBhdGgpO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcGF0aGkgPSBwYXRoW2ldO1xuICAgICAgICAgICAgZm9yIChqID0gMSwgamogPSBwYXRoaS5sZW5ndGg7IGogPCBqajsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgeCA9IG1hdHJpeC54KHBhdGhpW2pdLCBwYXRoaVtqICsgMV0pO1xuICAgICAgICAgICAgICAgIHkgPSBtYXRyaXgueShwYXRoaVtqXSwgcGF0aGlbaiArIDFdKTtcbiAgICAgICAgICAgICAgICBwYXRoaVtqXSA9IHg7XG4gICAgICAgICAgICAgICAgcGF0aGlbaiArIDFdID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvLyBodHRwOi8vc2NoZXBlcnMuY2MvZ2V0dGluZy10by10aGUtcG9pbnRcbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tMmJlemllcihjcnAsIHopIHtcbiAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBjcnAubGVuZ3RoOyBpTGVuIC0gMiAqICF6ID4gaTsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgLSAyXSwgeTogK2NycFtpIC0gMV19LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaV0sICAgICB5OiArY3JwW2kgKyAxXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogK2NycFtpICsgMl0sIHk6ICtjcnBbaSArIDNdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgKyA0XSwgeTogK2NycFtpICsgNV19XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgICAgICBwWzBdID0ge3g6ICtjcnBbaUxlbiAtIDJdLCB5OiArY3JwW2lMZW4gLSAxXX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpTGVuIC0gNCA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSB7eDogK2NycFswXSwgeTogK2NycFsxXX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpTGVuIC0gMiA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMl0gPSB7eDogK2NycFswXSwgeTogK2NycFsxXX07XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSB7eDogK2NycFsyXSwgeTogK2NycFszXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaUxlbiAtIDQgPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBwWzNdID0gcFsyXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSB7eDogK2NycFtpXSwgeTogK2NycFtpICsgMV19O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQucHVzaChbXCJDXCIsXG4gICAgICAgICAgICAgICAgICAoLXBbMF0ueCArIDYgKiBwWzFdLnggKyBwWzJdLngpIC8gNixcbiAgICAgICAgICAgICAgICAgICgtcFswXS55ICsgNiAqIHBbMV0ueSArIHBbMl0ueSkgLyA2LFxuICAgICAgICAgICAgICAgICAgKHBbMV0ueCArIDYgKiBwWzJdLnggLSBwWzNdLngpIC8gNixcbiAgICAgICAgICAgICAgICAgIChwWzFdLnkgKyA2KnBbMl0ueSAtIHBbM10ueSkgLyA2LFxuICAgICAgICAgICAgICAgICAgcFsyXS54LFxuICAgICAgICAgICAgICAgICAgcFsyXS55XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIC8vIGV4cG9ydFxuICAgIFNuYXAucGF0aCA9IHBhdGhzO1xuXG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5nZXRUb3RhbExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBnaXZlbiBwYXRoIGluIHBpeGVsc1xuICAgICAqKlxuICAgICAtIHBhdGggKHN0cmluZykgU1ZHIHBhdGggc3RyaW5nXG4gICAgICoqXG4gICAgID0gKG51bWJlcikgbGVuZ3RoXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRUb3RhbExlbmd0aCA9IGdldFRvdGFsTGVuZ3RoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0UG9pbnRBdExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGxvY2F0ZWQgYXQgdGhlIGdpdmVuIGxlbmd0aCBhbG9uZyB0aGUgZ2l2ZW4gcGF0aFxuICAgICAqKlxuICAgICAtIHBhdGggKHN0cmluZykgU1ZHIHBhdGggc3RyaW5nXG4gICAgIC0gbGVuZ3RoIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCwgZXhjbHVkaW5nIG5vbi1yZW5kZXJpbmcganVtcHNcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSxcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIGRlcml2YXRpdmVcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRQb2ludEF0TGVuZ3RoID0gZ2V0UG9pbnRBdExlbmd0aDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmdldFN1YnBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIHN1YnBhdGggb2YgYSBnaXZlbiBwYXRoIGJldHdlZW4gZ2l2ZW4gc3RhcnQgYW5kIGVuZCBsZW5ndGhzXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgLSBmcm9tIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgc3RhcnQgb2YgdGhlIHNlZ21lbnRcbiAgICAgLSB0byAobnVtYmVyKSBsZW5ndGgsIGluIHBpeGVscywgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhdGggdG8gdGhlIGVuZCBvZiB0aGUgc2VnbWVudFxuICAgICAqKlxuICAgICA9IChzdHJpbmcpIHBhdGggc3RyaW5nIGRlZmluaXRpb24gZm9yIHRoZSBzZWdtZW50XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRTdWJwYXRoID0gZnVuY3Rpb24gKHBhdGgsIGZyb20sIHRvKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFRvdGFsTGVuZ3RoKHBhdGgpIC0gdG8gPCAxZS02KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3VicGF0aHNBdExlbmd0aChwYXRoLCBmcm9tKS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBnZXRTdWJwYXRoc0F0TGVuZ3RoKHBhdGgsIHRvLCAxKTtcbiAgICAgICAgcmV0dXJuIGZyb20gPyBnZXRTdWJwYXRoc0F0TGVuZ3RoKGEsIGZyb20pLmVuZCA6IGE7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXRUb3RhbExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoIGluIHBpeGVscyAob25seSB3b3JrcyBmb3IgYHBhdGhgIGVsZW1lbnRzKVxuICAgICA9IChudW1iZXIpIGxlbmd0aFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmdldFRvdGFsTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFNJRVJSQSBFbGVtZW50LmdldFBvaW50QXRMZW5ndGgoKS9FbGVtZW50LmdldFRvdGFsTGVuZ3RoKCk6IElmIGEgPHBhdGg+IGlzIGJyb2tlbiBpbnRvIGRpZmZlcmVudCBzZWdtZW50cywgaXMgdGhlIGp1bXAgZGlzdGFuY2UgdG8gdGhlIG5ldyBjb29yZGluYXRlcyBzZXQgYnkgdGhlIF9NXyBvciBfbV8gY29tbWFuZHMgY2FsY3VsYXRlZCBhcyBwYXJ0IG9mIHRoZSBwYXRoJ3MgdG90YWwgbGVuZ3RoP1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFBvaW50QXRMZW5ndGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGxvY2F0ZWQgYXQgdGhlIGdpdmVuIGxlbmd0aCBvbiB0aGUgZ2l2ZW4gcGF0aCAob25seSB3b3JrcyBmb3IgYHBhdGhgIGVsZW1lbnRzKVxuICAgICAqKlxuICAgICAtIGxlbmd0aCAobnVtYmVyKSBsZW5ndGgsIGluIHBpeGVscywgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhdGgsIGV4Y2x1ZGluZyBub24tcmVuZGVyaW5nIGp1bXBzXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50OlxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlLFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUsXG4gICAgIG8gICAgIGFscGhhOiAobnVtYmVyKSBhbmdsZSBvZiBkZXJpdmF0aXZlXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmdldFBvaW50QXRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBnZXRQb2ludEF0TGVuZ3RoKHRoaXMuYXR0cihcImRcIiksIGxlbmd0aCk7XG4gICAgfTtcbiAgICAvLyBTSUVSUkEgRWxlbWVudC5nZXRTdWJwYXRoKCk6IFNpbWlsYXIgdG8gdGhlIHByb2JsZW0gZm9yIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aCgpLiBVbmNsZWFyIGhvdyB0aGlzIHdvdWxkIHdvcmsgZm9yIGEgc2VnbWVudGVkIHBhdGguIE92ZXJhbGwsIHRoZSBjb25jZXB0IG9mIF9zdWJwYXRoXyBhbmQgd2hhdCBJJ20gY2FsbGluZyBhIF9zZWdtZW50XyAoc2VyaWVzIG9mIG5vbi1fTV8gb3IgX1pfIGNvbW1hbmRzKSBpcyB1bmNsZWFyLlxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFN1YnBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgc3VicGF0aCBvZiBhIGdpdmVuIGVsZW1lbnQgZnJvbSBnaXZlbiBzdGFydCBhbmQgZW5kIGxlbmd0aHMgKG9ubHkgd29ya3MgZm9yIGBwYXRoYCBlbGVtZW50cylcbiAgICAgKipcbiAgICAgLSBmcm9tIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgc3RhcnQgb2YgdGhlIHNlZ21lbnRcbiAgICAgLSB0byAobnVtYmVyKSBsZW5ndGgsIGluIHBpeGVscywgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhdGggdG8gdGhlIGVuZCBvZiB0aGUgc2VnbWVudFxuICAgICAqKlxuICAgICA9IChzdHJpbmcpIHBhdGggc3RyaW5nIGRlZmluaXRpb24gZm9yIHRoZSBzZWdtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0U3VicGF0aCA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gU25hcC5wYXRoLmdldFN1YnBhdGgodGhpcy5hdHRyKFwiZFwiKSwgZnJvbSwgdG8pO1xuICAgIH07XG4gICAgU25hcC5fLmJveCA9IGJveDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmZpbmREb3RzQXRTZWdtZW50XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIEZpbmRzIGRvdCBjb29yZGluYXRlcyBvbiB0aGUgZ2l2ZW4gY3ViaWMgYmV6acOpciBjdXJ2ZSBhdCB0aGUgZ2l2ZW4gdFxuICAgICAtIHAxeCAobnVtYmVyKSB4IG9mIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBwMXkgKG51bWJlcikgeSBvZiB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gYzF4IChudW1iZXIpIHggb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMXkgKG51bWJlcikgeSBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMyeCAobnVtYmVyKSB4IG9mIHRoZSBzZWNvbmQgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMyeSAobnVtYmVyKSB5IG9mIHRoZSBzZWNvbmQgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAyeCAobnVtYmVyKSB4IG9mIHRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gcDJ5IChudW1iZXIpIHkgb2YgdGhlIHNlY29uZCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSB0IChudW1iZXIpIHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZSAoMC4uMSlcbiAgICAgPSAob2JqZWN0KSBwb2ludCBpbmZvcm1hdGlvbiBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LFxuICAgICBvICAgICBtOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgYW5jaG9yLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IGFuY2hvclxuICAgICBvICAgICB9LFxuICAgICBvICAgICBuOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGFuY2hvcixcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYW5jaG9yXG4gICAgIG8gICAgIH0sXG4gICAgIG8gICAgIHN0YXJ0OiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZSxcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlXG4gICAgIG8gICAgIH0sXG4gICAgIG8gICAgIGVuZDoge1xuICAgICBvICAgICAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlXG4gICAgIG8gICAgIH0sXG4gICAgIG8gICAgIGFscGhhOiAobnVtYmVyKSBhbmdsZSBvZiB0aGUgY3VydmUgZGVyaXZhdGl2ZSBhdCB0aGUgcG9pbnRcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5maW5kRG90c0F0U2VnbWVudCA9IGZpbmREb3RzQXRTZWdtZW50O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguYmV6aWVyQkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggb2YgYSBnaXZlbiBjdWJpYyBiZXppw6lyIGN1cnZlXG4gICAgIC0gcDF4IChudW1iZXIpIHggb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBjMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ5IChudW1iZXIpIHkgb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gcDJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAqIG9yXG4gICAgIC0gYmV6IChhcnJheSkgYXJyYXkgb2Ygc2l4IHBvaW50cyBmb3IgYmV6acOpciBjdXJ2ZVxuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveFxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHRvcCBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHgyOiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5MjogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBib3R0b20gcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgd2lkdGg6IChudW1iZXIpIHdpZHRoIG9mIHRoZSBib3gsXG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0IG9mIHRoZSBib3hcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5iZXppZXJCQm94ID0gYmV6aWVyQkJveDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmlzUG9pbnRJbnNpZGVCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIHBvaW50IGlzIGluc2lkZSBib3VuZGluZyBib3hcbiAgICAgLSBiYm94IChzdHJpbmcpIGJvdW5kaW5nIGJveFxuICAgICAtIHggKHN0cmluZykgeCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAtIHkgKHN0cmluZykgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAgaWYgcG9pbnQgaXMgaW5zaWRlXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5pc1BvaW50SW5zaWRlQkJveCA9IGlzUG9pbnRJbnNpZGVCQm94O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguaXNCQm94SW50ZXJzZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHR3byBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICAgLSBiYm94MSAoc3RyaW5nKSBmaXJzdCBib3VuZGluZyBib3hcbiAgICAgLSBiYm94MiAoc3RyaW5nKSBzZWNvbmQgYm91bmRpbmcgYm94XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmlzQkJveEludGVyc2VjdCA9IGlzQkJveEludGVyc2VjdDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmludGVyc2VjdGlvblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBGaW5kcyBpbnRlcnNlY3Rpb25zIG9mIHR3byBwYXRoc1xuICAgICAtIHBhdGgxIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0gcGF0aDIgKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgPSAoYXJyYXkpIGRvdHMgb2YgaW50ZXJzZWN0aW9uXG4gICAgIG8gW1xuICAgICBvICAgICB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCxcbiAgICAgbyAgICAgICAgIHQxOiAobnVtYmVyKSB0IHZhbHVlIGZvciBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgdDI6IChudW1iZXIpIHQgdmFsdWUgZm9yIHNlZ21lbnQgb2YgcGF0aDIsXG4gICAgIG8gICAgICAgICBzZWdtZW50MTogKG51bWJlcikgb3JkZXIgbnVtYmVyIGZvciBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgc2VnbWVudDI6IChudW1iZXIpIG9yZGVyIG51bWJlciBmb3Igc2VnbWVudCBvZiBwYXRoMixcbiAgICAgbyAgICAgICAgIGJlejE6IChhcnJheSkgZWlnaHQgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIGJlemnDqXIgY3VydmUgZm9yIHRoZSBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgYmV6MjogKGFycmF5KSBlaWdodCBjb29yZGluYXRlcyByZXByZXNlbnRpbmcgYmV6acOpciBjdXJ2ZSBmb3IgdGhlIHNlZ21lbnQgb2YgcGF0aDJcbiAgICAgbyAgICAgfVxuICAgICBvIF1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmludGVyc2VjdGlvbiA9IHBhdGhJbnRlcnNlY3Rpb247XG4gICAgU25hcC5wYXRoLmludGVyc2VjdGlvbk51bWJlciA9IHBhdGhJbnRlcnNlY3Rpb25OdW1iZXI7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5pc1BvaW50SW5zaWRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIHBvaW50IGlzIGluc2lkZSBhIGdpdmVuIGNsb3NlZCBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZTogZmlsbCBtb2RlIGRvZXNu4oCZdCBhZmZlY3QgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZC5cbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0geCAobnVtYmVyKSB4IG9mIHRoZSBwb2ludFxuICAgICAtIHkgKG51bWJlcikgeSBvZiB0aGUgcG9pbnRcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgcGF0aFxuICAgIFxcKi9cbiAgICBTbmFwLnBhdGguaXNQb2ludEluc2lkZSA9IGlzUG9pbnRJbnNpZGVQYXRoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0QkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggb2YgYSBnaXZlbiBwYXRoXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveFxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHRvcCBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHgyOiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5MjogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBib3R0b20gcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgd2lkdGg6IChudW1iZXIpIHdpZHRoIG9mIHRoZSBib3gsXG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0IG9mIHRoZSBib3hcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRCQm94ID0gcGF0aEJCb3g7XG4gICAgU25hcC5wYXRoLmdldCA9IGdldFBhdGg7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC50b1JlbGF0aXZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIHBhdGggY29vcmRpbmF0ZXMgaW50byByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgID0gKGFycmF5KSBwYXRoIHN0cmluZ1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgudG9SZWxhdGl2ZSA9IHBhdGhUb1JlbGF0aXZlO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGgudG9BYnNvbHV0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBwYXRoIGNvb3JkaW5hdGVzIGludG8gYWJzb2x1dGUgdmFsdWVzXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChhcnJheSkgcGF0aCBzdHJpbmdcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLnRvQWJzb2x1dGUgPSBwYXRoVG9BYnNvbHV0ZTtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLnRvQ3ViaWNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogQ29udmVydHMgcGF0aCB0byBhIG5ldyBwYXRoIHdoZXJlIGFsbCBzZWdtZW50cyBhcmUgY3ViaWMgYmV6acOpciBjdXJ2ZXNcbiAgICAgLSBwYXRoU3RyaW5nIChzdHJpbmd8YXJyYXkpIHBhdGggc3RyaW5nIG9yIGFycmF5IG9mIHNlZ21lbnRzXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50c1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgudG9DdWJpYyA9IHBhdGgyY3VydmU7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5tYXBcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgcGF0aCBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbWF0cml4XG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICAtIG1hdHJpeCAob2JqZWN0KSBzZWUgQE1hdHJpeFxuICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybWVkIHBhdGggc3RyaW5nXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5tYXAgPSBtYXBQYXRoO1xuICAgIFNuYXAucGF0aC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIFNuYXAucGF0aC5jbG9uZSA9IHBhdGhDbG9uZTtcbn0pO1xuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iKSB7XG4gICAgdmFyIG1tYXggPSBNYXRoLm1heCxcbiAgICAgICAgbW1pbiA9IE1hdGgubWluO1xuXG4gICAgLy8gU2V0XG4gICAgdmFyIFNldCA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy50eXBlID0gXCJzZXRcIjtcbiAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBpdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbdGhpcy5pdGVtcy5sZW5ndGhdID0gdGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aF0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldHByb3RvID0gU2V0LnByb3RvdHlwZTtcbiAgICAvKlxcXG4gICAgICogU2V0LnB1c2hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZWFjaCBhcmd1bWVudCB0byB0aGUgY3VycmVudCBzZXRcbiAgICAgPSAob2JqZWN0KSBvcmlnaW5hbCBlbGVtZW50XG4gICAgXFwqL1xuICAgIHNldHByb3RvLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVtLFxuICAgICAgICAgICAgbGVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpc1tsZW5dID0gdGhpcy5pdGVtc1tsZW5dID0gaXRlbTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5wb3BcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgbGFzdCBlbGVtZW50IGFuZCByZXR1cm5zIGl0XG4gICAgID0gKG9iamVjdCkgZWxlbWVudFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoICYmIGRlbGV0ZSB0aGlzW3RoaXMubGVuZ3RoLS1dO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5wb3AoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuZm9yRWFjaFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRXhlY3V0ZXMgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0XG4gICAgICpcbiAgICAgKiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLCB0aGUgbG9vcCBzdG9wcyBydW5uaW5nLlxuICAgICAqKlxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgZnVuY3Rpb24gdG8gcnVuXG4gICAgIC0gdGhpc0FyZyAob2JqZWN0KSBjb250ZXh0IG9iamVjdCBmb3IgdGhlIGNhbGxiYWNrXG4gICAgID0gKG9iamVjdCkgU2V0IG9iamVjdFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5pdGVtc1tpXSwgaSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBzZXRwcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wb3AoKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHNldHByb3RvLmF0dHIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLmF0dHIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5jbGVhclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgc2V0XG4gICAgXFwqL1xuICAgIHNldHByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuc3BsaWNlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIHJhbmdlIG9mIGVsZW1lbnRzIGZyb20gdGhlIHNldFxuICAgICAqKlxuICAgICAtIGluZGV4IChudW1iZXIpIHBvc2l0aW9uIG9mIHRoZSBkZWxldGlvblxuICAgICAtIGNvdW50IChudW1iZXIpIG51bWJlciBvZiBlbGVtZW50IHRvIHJlbW92ZVxuICAgICAtIGluc2VydGlvbuKApiAob2JqZWN0KSAjb3B0aW9uYWwgZWxlbWVudHMgdG8gaW5zZXJ0XG4gICAgID0gKG9iamVjdCkgc2V0IGVsZW1lbnRzIHRoYXQgd2VyZSBkZWxldGVkXG4gICAgXFwqL1xuICAgIHNldHByb3RvLnNwbGljZSA9IGZ1bmN0aW9uIChpbmRleCwgY291bnQsIGluc2VydGlvbikge1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG1tYXgodGhpcy5sZW5ndGggKyBpbmRleCwgMCkgOiBpbmRleDtcbiAgICAgICAgY291bnQgPSBtbWF4KDAsIG1taW4odGhpcy5sZW5ndGggLSBpbmRleCwgY291bnQpKTtcbiAgICAgICAgdmFyIHRhaWwgPSBbXSxcbiAgICAgICAgICAgIHRvZGVsID0gW10sXG4gICAgICAgICAgICBhcmdzID0gW10sXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdG9kZWwucHVzaCh0aGlzW2luZGV4ICsgaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICB0YWlsLnB1c2godGhpc1tpbmRleCArIGldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJnbGVuID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdsZW4gKyB0YWlsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2luZGV4ICsgaV0gPSB0aGlzW2luZGV4ICsgaV0gPSBpIDwgYXJnbGVuID8gYXJnc1tpXSA6IHRhaWxbaSAtIGFyZ2xlbl07XG4gICAgICAgIH1cbiAgICAgICAgaSA9IHRoaXMuaXRlbXMubGVuZ3RoID0gdGhpcy5sZW5ndGggLT0gY291bnQgLSBhcmdsZW47XG4gICAgICAgIHdoaWxlICh0aGlzW2ldKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpc1tpKytdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2V0KHRvZGVsKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuZXhjbHVkZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBnaXZlbiBlbGVtZW50IGZyb20gdGhlIHNldFxuICAgICAqKlxuICAgICAtIGVsZW1lbnQgKG9iamVjdCkgZWxlbWVudCB0byByZW1vdmVcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIG9iamVjdCB3YXMgZm91bmQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgc2V0XG4gICAgXFwqL1xuICAgIHNldHByb3RvLmV4Y2x1ZGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAodGhpc1tpXSA9PSBlbCkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBzZXRwcm90by5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLmluc2VydEFmdGVyKGVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHNldHByb3RvLmdldEJCb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB4ID0gW10sXG4gICAgICAgICAgICB5ID0gW10sXG4gICAgICAgICAgICB4MiA9IFtdLFxuICAgICAgICAgICAgeTIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpLS07KSBpZiAoIXRoaXMuaXRlbXNbaV0ucmVtb3ZlZCkge1xuICAgICAgICAgICAgdmFyIGJveCA9IHRoaXMuaXRlbXNbaV0uZ2V0QkJveCgpO1xuICAgICAgICAgICAgeC5wdXNoKGJveC54KTtcbiAgICAgICAgICAgIHkucHVzaChib3gueSk7XG4gICAgICAgICAgICB4Mi5wdXNoKGJveC54ICsgYm94LndpZHRoKTtcbiAgICAgICAgICAgIHkyLnB1c2goYm94LnkgKyBib3guaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gbW1pbi5hcHBseSgwLCB4KTtcbiAgICAgICAgeSA9IG1taW4uYXBwbHkoMCwgeSk7XG4gICAgICAgIHgyID0gbW1heC5hcHBseSgwLCB4Mik7XG4gICAgICAgIHkyID0gbW1heC5hcHBseSgwLCB5Mik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgIHkyOiB5MixcbiAgICAgICAgICAgIHdpZHRoOiB4MiAtIHgsXG4gICAgICAgICAgICBoZWlnaHQ6IHkyIC0geSxcbiAgICAgICAgICAgIGN4OiB4ICsgKHgyIC0geCkgLyAyLFxuICAgICAgICAgICAgY3k6IHkgKyAoeTIgLSB5KSAvIDJcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHNldHByb3RvLmNsb25lID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcyA9IG5ldyBTZXQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcy5wdXNoKHRoaXMuaXRlbXNbaV0uY2xvbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBzZXRwcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiU25hcFxcdTIwMThzIHNldFwiO1xuICAgIH07XG4gICAgc2V0cHJvdG8udHlwZSA9IFwic2V0XCI7XG4gICAgLy8gZXhwb3J0XG4gICAgU25hcC5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZXQgPSBuZXcgU2V0O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2V0LnB1c2guYXBwbHkoc2V0LCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH07XG59KTtcbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYikge1xuICAgIHZhciBuYW1lcyA9IHt9LFxuICAgICAgICByZVVuaXQgPSAvW2Etel0rJC9pLFxuICAgICAgICBTdHIgPSBTdHJpbmc7XG4gICAgbmFtZXMuc3Ryb2tlID0gbmFtZXMuZmlsbCA9IFwiY29sb3VyXCI7XG4gICAgZnVuY3Rpb24gZ2V0RW1wdHkoaXRlbSkge1xuICAgICAgICB2YXIgbCA9IGl0ZW1bMF07XG4gICAgICAgIHN3aXRjaCAobC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidFwiOiByZXR1cm4gW2wsIDAsIDBdO1xuICAgICAgICAgICAgY2FzZSBcIm1cIjogcmV0dXJuIFtsLCAxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6IGlmIChpdGVtLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAwLCBpdGVtWzJdLCBpdGVtWzNdXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzXCI6IGlmIChpdGVtLmxlbmd0aCA9PSA1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAxLCAxLCBpdGVtWzNdLCBpdGVtWzRdXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMSwgMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXF1YWxpc2VUcmFuc2Zvcm0odDEsIHQyLCBnZXRCQm94KSB7XG4gICAgICAgIHQyID0gU3RyKHQyKS5yZXBsYWNlKC9cXC57M318XFx1MjAyNi9nLCB0MSk7XG4gICAgICAgIHQxID0gU25hcC5wYXJzZVRyYW5zZm9ybVN0cmluZyh0MSkgfHwgW107XG4gICAgICAgIHQyID0gU25hcC5wYXJzZVRyYW5zZm9ybVN0cmluZyh0MikgfHwgW107XG4gICAgICAgIHZhciBtYXhsZW5ndGggPSBNYXRoLm1heCh0MS5sZW5ndGgsIHQyLmxlbmd0aCksXG4gICAgICAgICAgICBmcm9tID0gW10sXG4gICAgICAgICAgICB0byA9IFtdLFxuICAgICAgICAgICAgaSA9IDAsIGosIGpqLFxuICAgICAgICAgICAgdHQxLCB0dDI7XG4gICAgICAgIGZvciAoOyBpIDwgbWF4bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR0MSA9IHQxW2ldIHx8IGdldEVtcHR5KHQyW2ldKTtcbiAgICAgICAgICAgIHR0MiA9IHQyW2ldIHx8IGdldEVtcHR5KHR0MSk7XG4gICAgICAgICAgICBpZiAoKHR0MVswXSAhPSB0dDJbMF0pIHx8XG4gICAgICAgICAgICAgICAgKHR0MVswXS50b0xvd2VyQ2FzZSgpID09IFwiclwiICYmICh0dDFbMl0gIT0gdHQyWzJdIHx8IHR0MVszXSAhPSB0dDJbM10pKSB8fFxuICAgICAgICAgICAgICAgICh0dDFbMF0udG9Mb3dlckNhc2UoKSA9PSBcInNcIiAmJiAodHQxWzNdICE9IHR0MlszXSB8fCB0dDFbNF0gIT0gdHQyWzRdKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeCh0MSwgZ2V0QkJveCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdDIgPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeCh0MiwgZ2V0QkJveCgpKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IFtbXCJtXCIsIHQxLmEsIHQxLmIsIHQxLmMsIHQxLmQsIHQxLmUsIHQxLmZdXTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBbW1wibVwiLCB0Mi5hLCB0Mi5iLCB0Mi5jLCB0Mi5kLCB0Mi5lLCB0Mi5mXV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbVtpXSA9IFtdO1xuICAgICAgICAgICAgdG9baV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGpqID0gTWF0aC5tYXgodHQxLmxlbmd0aCwgdHQyLmxlbmd0aCk7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgaiBpbiB0dDEgJiYgKGZyb21baV1bal0gPSB0dDFbal0pO1xuICAgICAgICAgICAgICAgIGogaW4gdHQyICYmICh0b1tpXVtqXSA9IHR0MltqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IHBhdGgyYXJyYXkoZnJvbSksXG4gICAgICAgICAgICB0bzogcGF0aDJhcnJheSh0byksXG4gICAgICAgICAgICBmOiBnZXRQYXRoKGZyb20pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE51bWJlcih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VW5pdCh1bml0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gK3ZhbC50b0ZpeGVkKDMpICsgdW5pdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29sb3VyKGNscikge1xuICAgICAgICByZXR1cm4gU25hcC5yZ2IoY2xyWzBdLCBjbHJbMV0sIGNsclsyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBhdGgocGF0aCkge1xuICAgICAgICB2YXIgayA9IDAsIGksIGlpLCBqLCBqaiwgb3V0LCBhLCBiID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBvdXQgPSBcIltcIjtcbiAgICAgICAgICAgIGEgPSBbJ1wiJyArIHBhdGhbaV1bMF0gKyAnXCInXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDEsIGpqID0gcGF0aFtpXS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgYVtqXSA9IFwidmFsW1wiICsgKGsrKykgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSBhICsgXCJdXCI7XG4gICAgICAgICAgICBiW2ldID0gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihcInZhbFwiLCBcInJldHVybiBTbmFwLnBhdGgudG9TdHJpbmcuY2FsbChbXCIgKyBiICsgXCJdKVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aDJhcnJheShwYXRoKSB7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMSwgamogPSBwYXRoW2ldLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChwYXRoW2ldW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBFbGVtZW50LnByb3RvdHlwZS5lcXVhbCA9IGZ1bmN0aW9uIChuYW1lLCBiKSB7XG4gICAgICAgIHZhciBBLCBCLCBhID0gU3RyKHRoaXMuYXR0cihuYW1lKSB8fCBcIlwiKSxcbiAgICAgICAgICAgIGVsID0gdGhpcztcbiAgICAgICAgaWYgKGEgPT0gK2EgJiYgYiA9PSArYikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiArYSxcbiAgICAgICAgICAgICAgICB0bzogK2IsXG4gICAgICAgICAgICAgICAgZjogZ2V0TnVtYmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lc1tuYW1lXSA9PSBcImNvbG91clwiKSB7XG4gICAgICAgICAgICBBID0gU25hcC5jb2xvcihhKTtcbiAgICAgICAgICAgIEIgPSBTbmFwLmNvbG9yKGIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBbQS5yLCBBLmcsIEEuYiwgQS5vcGFjaXR5XSxcbiAgICAgICAgICAgICAgICB0bzogW0IuciwgQi5nLCBCLmIsIEIub3BhY2l0eV0sXG4gICAgICAgICAgICAgICAgZjogZ2V0Q29sb3VyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwidHJhbnNmb3JtXCIgfHwgbmFtZSA9PSBcImdyYWRpZW50VHJhbnNmb3JtXCIgfHwgbmFtZSA9PSBcInBhdHRlcm5UcmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBTbmFwLk1hdHJpeCkge1xuICAgICAgICAgICAgICAgIGIgPSBiLnRvVHJhbnNmb3JtU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVNuYXAuXy5yZ1RyYW5zZm9ybS50ZXN0KGIpKSB7XG4gICAgICAgICAgICAgICAgYiA9IFNuYXAuXy5zdmdUcmFuc2Zvcm0yc3RyaW5nKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVxdWFsaXNlVHJhbnNmb3JtKGEsIGIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QkJveCgxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwiZFwiIHx8IG5hbWUgPT0gXCJwYXRoXCIpIHtcbiAgICAgICAgICAgIEEgPSBTbmFwLnBhdGgudG9DdWJpYyhhLCBiKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogcGF0aDJhcnJheShBWzBdKSxcbiAgICAgICAgICAgICAgICB0bzogcGF0aDJhcnJheShBWzFdKSxcbiAgICAgICAgICAgICAgICBmOiBnZXRQYXRoKEFbMF0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwicG9pbnRzXCIpIHtcbiAgICAgICAgICAgIEEgPSBTdHIoYSkuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgQiA9IFN0cihiKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IEEsXG4gICAgICAgICAgICAgICAgdG86IEIsXG4gICAgICAgICAgICAgICAgZjogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBhVW5pdCA9IGEubWF0Y2gocmVVbml0KSxcbiAgICAgICAgICAgIGJVbml0ID0gU3RyKGIpLm1hdGNoKHJlVW5pdCk7XG4gICAgICAgIGlmIChhVW5pdCAmJiBhVW5pdCA9PSBiVW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBwYXJzZUZsb2F0KGEpLFxuICAgICAgICAgICAgICAgIHRvOiBwYXJzZUZsb2F0KGIpLFxuICAgICAgICAgICAgICAgIGY6IGdldFVuaXQoYVVuaXQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLmFzUFgobmFtZSksXG4gICAgICAgICAgICAgICAgdG86IHRoaXMuYXNQWChuYW1lLCBiKSxcbiAgICAgICAgICAgICAgICBmOiBnZXROdW1iZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgZWxwcm90byA9IEVsZW1lbnQucHJvdG90eXBlLFxuICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICBzdXBwb3J0c1RvdWNoID0gXCJjcmVhdGVUb3VjaFwiIGluIGdsb2IuZG9jLFxuICAgIGV2ZW50cyA9IFtcbiAgICAgICAgXCJjbGlja1wiLCBcImRibGNsaWNrXCIsIFwibW91c2Vkb3duXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2VvdXRcIixcbiAgICAgICAgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZXVwXCIsIFwidG91Y2hzdGFydFwiLCBcInRvdWNobW92ZVwiLCBcInRvdWNoZW5kXCIsXG4gICAgICAgIFwidG91Y2hjYW5jZWxcIlxuICAgIF0sXG4gICAgdG91Y2hNYXAgPSB7XG4gICAgICAgIG1vdXNlZG93bjogXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAgIG1vdXNlbW92ZTogXCJ0b3VjaG1vdmVcIixcbiAgICAgICAgbW91c2V1cDogXCJ0b3VjaGVuZFwiXG4gICAgfSxcbiAgICBnZXRTY3JvbGwgPSBmdW5jdGlvbiAoeHkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB4eSA9PSBcInlcIiA/IFwic2Nyb2xsVG9wXCIgOiBcInNjcm9sbExlZnRcIjtcbiAgICAgICAgcmV0dXJuIGdsb2IuZG9jLmRvY3VtZW50RWxlbWVudFtuYW1lXSB8fCBnbG9iLmRvYy5ib2R5W25hbWVdO1xuICAgIH0sXG4gICAgcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9LFxuICAgIHByZXZlbnRUb3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfSxcbiAgICBzdG9wVG91Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBhZGRFdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChnbG9iLmRvYy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhbE5hbWUgPSBzdXBwb3J0c1RvdWNoICYmIHRvdWNoTWFwW3R5cGVdID8gdG91Y2hNYXBbdHlwZV0gOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBmID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFkgPSBnZXRTY3JvbGwoXCJ5XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFggPSBnZXRTY3JvbGwoXCJ4XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzVG91Y2ggJiYgdG91Y2hNYXBbaGFzXSh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0VG91Y2hlc1tpXS50YXJnZXQgPT0gb2JqIHx8IG9iai5jb250YWlucyhlLnRhcmdldFRvdWNoZXNbaV0udGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkZSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gZS50YXJnZXRUb3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50ID0gb2xkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgPSBwcmV2ZW50VG91Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbiA9IHN0b3BUb3VjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlLmNsaWVudFggKyBzY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBlLmNsaWVudFkgKyBzY3JvbGxZO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlbWVudCwgZSwgeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSByZWFsTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKHJlYWxOYW1lLCBmLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gcmVhbE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihyZWFsTmFtZSwgZiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChnbG9iLmRvYy5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gZSB8fCBnbG9iLndpbi5ldmVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFkgPSBnZXRTY3JvbGwoXCJ5XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWCA9IGdldFNjcm9sbChcInhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZS5jbGllbnRYICsgc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBlLmNsaWVudFkgKyBzY3JvbGxZO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gZS5wcmV2ZW50RGVmYXVsdCB8fCBwcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24gPSBlLnN0b3BQcm9wYWdhdGlvbiB8fCBzdG9wUHJvcGFnYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKGVsZW1lbnQsIGUsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb2JqLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGYpO1xuICAgICAgICAgICAgICAgIHZhciBkZXRhY2hlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXRhY2hlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KSgpLFxuICAgIGRyYWcgPSBbXSxcbiAgICBkcmFnTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB4ID0gZS5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IGUuY2xpZW50WSxcbiAgICAgICAgICAgIHNjcm9sbFkgPSBnZXRTY3JvbGwoXCJ5XCIpLFxuICAgICAgICAgICAgc2Nyb2xsWCA9IGdldFNjcm9sbChcInhcIiksXG4gICAgICAgICAgICBkcmFnaSxcbiAgICAgICAgICAgIGogPSBkcmFnLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgZHJhZ2kgPSBkcmFnW2pdO1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB0b3VjaDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoID0gZS50b3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PSBkcmFnaS5lbC5fZHJhZy5pZCB8fCBkcmFnaS5lbC5ub2RlLmNvbnRhaW5zKHRvdWNoLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB0b3VjaC5jbGllbnRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZS5vcmlnaW5hbEV2ZW50ID8gZS5vcmlnaW5hbEV2ZW50IDogZSkucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRyYWdpLmVsLm5vZGUsXG4gICAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgICBnbG9iID0gU25hcC5fLmdsb2IsXG4gICAgICAgICAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBub2RlLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAvLyBnbG9iLndpbi5vcGVyYSAmJiBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAvLyBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIC8vIG8gPSBkcmFnaS5lbC5wYXBlci5nZXRFbGVtZW50QnlQb2ludCh4LCB5KTtcbiAgICAgICAgICAgIC8vIG5vZGUuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgICAgICAgICAvLyBnbG9iLndpbi5vcGVyYSAmJiAobmV4dCA/IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSkpO1xuICAgICAgICAgICAgLy8gbyAmJiBldmUoXCJzbmFwLmRyYWcub3Zlci5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5lbCwgbyk7XG4gICAgICAgICAgICB4ICs9IHNjcm9sbFg7XG4gICAgICAgICAgICB5ICs9IHNjcm9sbFk7XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRyYWcubW92ZS5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5tb3ZlX3Njb3BlIHx8IGRyYWdpLmVsLCB4IC0gZHJhZ2kuZWwuX2RyYWcueCwgeSAtIGRyYWdpLmVsLl9kcmFnLnksIHgsIHksIGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkcmFnVXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBTbmFwLnVubW91c2Vtb3ZlKGRyYWdNb3ZlKS51bm1vdXNldXAoZHJhZ1VwKTtcbiAgICAgICAgdmFyIGkgPSBkcmFnLmxlbmd0aCxcbiAgICAgICAgICAgIGRyYWdpO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBkcmFnaSA9IGRyYWdbaV07XG4gICAgICAgICAgICBkcmFnaS5lbC5fZHJhZyA9IHt9O1xuICAgICAgICAgICAgZXZlKFwic25hcC5kcmFnLmVuZC5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5lbmRfc2NvcGUgfHwgZHJhZ2kuc3RhcnRfc2NvcGUgfHwgZHJhZ2kubW92ZV9zY29wZSB8fCBkcmFnaS5lbCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhZyA9IFtdO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBjbGljayBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBjbGljayBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5kYmxjbGlja1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIGRvdWJsZSBjbGljayBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuZGJsY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBkb3VibGUgY2xpY2sgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2Vkb3duXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2Vkb3duIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZWRvd25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBtb3VzZWRvd24gZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2Vtb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2Vtb3ZlIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBtb3VzZW1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2VvdXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBtb3VzZW91dCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2VvdXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBtb3VzZW91dCBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZW92ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBtb3VzZW92ZXIgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlb3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNlb3ZlciBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZXVwXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2V1cCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2V1cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNldXAgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG91Y2hzdGFydFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIHRvdWNoc3RhcnQgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoc3RhcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSB0b3VjaHN0YXJ0IGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cblxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNobW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIHRvdWNobW92ZSBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVudG91Y2htb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2htb3ZlIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cblxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2hlbmQgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2hlbmQgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG91Y2hjYW5jZWxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSB0b3VjaGNhbmNlbCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVudG91Y2hjYW5jZWxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSB0b3VjaGNhbmNlbCBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZm9yICh2YXIgaSA9IGV2ZW50cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIFNuYXBbZXZlbnROYW1lXSA9IGVscHJvdG9bZXZlbnROYW1lXSA9IGZ1bmN0aW9uIChmbiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoU25hcC5pcyhmbiwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGY6IGZuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5iaW5kOiBhZGRFdmVudCh0aGlzLnNoYXBlIHx8IHRoaXMubm9kZSB8fCBnbG9iLmRvYywgZXZlbnROYW1lLCBmbiwgc2NvcGUgfHwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNuYXBbXCJ1blwiICsgZXZlbnROYW1lXSA9XG4gICAgICAgICAgICBlbHByb3RvW1widW5cIiArIGV2ZW50TmFtZV0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIGwgPSBldmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChsLS0pIGlmIChldmVudHNbbF0ubmFtZSA9PSBldmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXZlbnRzW2xdLmYgPT0gZm4gfHwgIWZuKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudHNbbF0udW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5zcGxpY2UobCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICFldmVudHMubGVuZ3RoICYmIGRlbGV0ZSB0aGlzLmV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoZXZlbnRzW2ldKTtcbiAgICB9XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaG92ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgaG92ZXIgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBmX2luIChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgaW5cbiAgICAgLSBmX291dCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGhvdmVyIG91dFxuICAgICAtIGljb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBob3ZlciBpbiBoYW5kbGVyXG4gICAgIC0gb2NvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGhvdmVyIG91dCBoYW5kbGVyXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5ob3ZlciA9IGZ1bmN0aW9uIChmX2luLCBmX291dCwgc2NvcGVfaW4sIHNjb3BlX291dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZW92ZXIoZl9pbiwgc2NvcGVfaW4pLm1vdXNlb3V0KGZfb3V0LCBzY29wZV9vdXQgfHwgc2NvcGVfaW4pO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5ob3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBob3ZlciBldmVudCBoYW5kbGVycyBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gZl9pbiAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGhvdmVyIGluXG4gICAgIC0gZl9vdXQgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBvdXRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnVuaG92ZXIgPSBmdW5jdGlvbiAoZl9pbiwgZl9vdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5tb3VzZW92ZXIoZl9pbikudW5tb3VzZW91dChmX291dCk7XG4gICAgfTtcbiAgICB2YXIgZHJhZ2dhYmxlID0gW107XG4gICAgLy8gU0lFUlJBIHVuY2xlYXIgd2hhdCBfY29udGV4dF8gcmVmZXJzIHRvIGZvciBzdGFydGluZywgZW5kaW5nLCBtb3ZpbmcgdGhlIGRyYWcgZ2VzdHVyZS5cbiAgICAvLyBTSUVSUkEgRWxlbWVudC5kcmFnKCk6IF94IHBvc2l0aW9uIG9mIHRoZSBtb3VzZV86IFdoZXJlIGFyZSB0aGUgeC95IHZhbHVlcyBvZmZzZXQgZnJvbT9cbiAgICAvLyBTSUVSUkEgRWxlbWVudC5kcmFnKCk6IG11Y2ggb2YgdGhpcyBtZW1iZXIncyBkb2MgYXBwZWFycyB0byBiZSBkdXBsaWNhdGVkIGZvciBzb21lIHJlYXNvbi5cbiAgICAvLyBTSUVSUkEgVW5jbGVhciBhYm91dCB0aGlzIHNlbnRlbmNlOiBfQWRkaXRpb25hbGx5IGZvbGxvd2luZyBkcmFnIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZDogZHJhZy5zdGFydC48aWQ+IG9uIHN0YXJ0LCBkcmFnLmVuZC48aWQ+IG9uIGVuZCBhbmQgZHJhZy5tb3ZlLjxpZD4gb24gZXZlcnkgbW92ZS5fIElzIHRoZXJlIGEgZ2xvYmFsIF9kcmFnXyBvYmplY3QgdG8gd2hpY2ggeW91IGNhbiBhc3NpZ24gaGFuZGxlcnMga2V5ZWQgYnkgYW4gZWxlbWVudCdzIElEP1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmRyYWdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGFuIGVsZW1lbnQncyBkcmFnIGdlc3R1cmVcbiAgICAgKipcbiAgICAgLSBvbm1vdmUgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBtb3ZpbmdcbiAgICAgLSBvbnN0YXJ0IChmdW5jdGlvbikgaGFuZGxlciBmb3IgZHJhZyBzdGFydFxuICAgICAtIG9uZW5kIChmdW5jdGlvbikgaGFuZGxlciBmb3IgZHJhZyBlbmRcbiAgICAgLSBtY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgbW92aW5nIGhhbmRsZXJcbiAgICAgLSBzY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgZHJhZyBzdGFydCBoYW5kbGVyXG4gICAgIC0gZWNvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGRyYWcgZW5kIGhhbmRsZXJcbiAgICAgKiBBZGRpdGlvbmFseSBmb2xsb3dpbmcgYGRyYWdgIGV2ZW50cyBhcmUgdHJpZ2dlcmVkOiBgZHJhZy5zdGFydC48aWQ+YCBvbiBzdGFydCxcbiAgICAgKiBgZHJhZy5lbmQuPGlkPmAgb24gZW5kIGFuZCBgZHJhZy5tb3ZlLjxpZD5gIG9uIGV2ZXJ5IG1vdmUuIFdoZW4gZWxlbWVudCBpcyBkcmFnZ2VkIG92ZXIgYW5vdGhlciBlbGVtZW50XG4gICAgICogYGRyYWcub3Zlci48aWQ+YCBmaXJlcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogU3RhcnQgZXZlbnQgYW5kIHN0YXJ0IGhhbmRsZXIgYXJlIGNhbGxlZCBpbiBzcGVjaWZpZWQgY29udGV4dCBvciBpbiBjb250ZXh0IG9mIHRoZSBlbGVtZW50IHdpdGggZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgIG8geCAobnVtYmVyKSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIHkgKG51bWJlcikgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgICogTW92ZSBldmVudCBhbmQgbW92ZSBoYW5kbGVyIGFyZSBjYWxsZWQgaW4gc3BlY2lmaWVkIGNvbnRleHQgb3IgaW4gY29udGV4dCBvZiB0aGUgZWxlbWVudCB3aXRoIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgICBvIGR4IChudW1iZXIpIHNoaWZ0IGJ5IHggZnJvbSB0aGUgc3RhcnQgcG9pbnRcbiAgICAgbyBkeSAobnVtYmVyKSBzaGlmdCBieSB5IGZyb20gdGhlIHN0YXJ0IHBvaW50XG4gICAgIG8geCAobnVtYmVyKSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIHkgKG51bWJlcikgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgICogRW5kIGV2ZW50IGFuZCBlbmQgaGFuZGxlciBhcmUgY2FsbGVkIGluIHNwZWNpZmllZCBjb250ZXh0IG9yIGluIGNvbnRleHQgb2YgdGhlIGVsZW1lbnQgd2l0aCBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5kcmFnID0gZnVuY3Rpb24gKG9ubW92ZSwgb25zdGFydCwgb25lbmQsIG1vdmVfc2NvcGUsIHN0YXJ0X3Njb3BlLCBlbmRfc2NvcGUpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ1RyYW5zZm9ybTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYWcoZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogb3JpZ1RyYW5zZm9ybSArIChvcmlnVHJhbnNmb3JtID8gXCJUXCIgOiBcInRcIikgKyBbZHgsIGR5XVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9yaWdUcmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybSgpLmxvY2FsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhcnQoZSwgeCwgeSkge1xuICAgICAgICAgICAgKGUub3JpZ2luYWxFdmVudCB8fCBlKS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZy54ID0geDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWcueSA9IHk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnLmlkID0gZS5pZGVudGlmaWVyO1xuICAgICAgICAgICAgIWRyYWcubGVuZ3RoICYmIFNuYXAubW91c2Vtb3ZlKGRyYWdNb3ZlKS5tb3VzZXVwKGRyYWdVcCk7XG4gICAgICAgICAgICBkcmFnLnB1c2goe2VsOiB0aGlzLCBtb3ZlX3Njb3BlOiBtb3ZlX3Njb3BlLCBzdGFydF9zY29wZTogc3RhcnRfc2NvcGUsIGVuZF9zY29wZTogZW5kX3Njb3BlfSk7XG4gICAgICAgICAgICBvbnN0YXJ0ICYmIGV2ZS5vbihcInNuYXAuZHJhZy5zdGFydC5cIiArIHRoaXMuaWQsIG9uc3RhcnQpO1xuICAgICAgICAgICAgb25tb3ZlICYmIGV2ZS5vbihcInNuYXAuZHJhZy5tb3ZlLlwiICsgdGhpcy5pZCwgb25tb3ZlKTtcbiAgICAgICAgICAgIG9uZW5kICYmIGV2ZS5vbihcInNuYXAuZHJhZy5lbmQuXCIgKyB0aGlzLmlkLCBvbmVuZCk7XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRyYWcuc3RhcnQuXCIgKyB0aGlzLmlkLCBzdGFydF9zY29wZSB8fCBtb3ZlX3Njb3BlIHx8IHRoaXMsIHgsIHksIGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RyYWcgPSB7fTtcbiAgICAgICAgZHJhZ2dhYmxlLnB1c2goe2VsOiB0aGlzLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgdGhpcy5tb3VzZWRvd24oc3RhcnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXG4gICAgICogRWxlbWVudC5vbkRyYWdPdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTaG9ydGN1dCB0byBhc3NpZ24gZXZlbnQgaGFuZGxlciBmb3IgYGRyYWcub3Zlci48aWQ+YCBldmVudCwgd2hlcmUgYGlkYCBpcyB0aGUgZWxlbWVudCdzIGBpZGAgKHNlZSBARWxlbWVudC5pZClcbiAgICAgLSBmIChmdW5jdGlvbikgaGFuZGxlciBmb3IgZXZlbnQsIGZpcnN0IGFyZ3VtZW50IHdvdWxkIGJlIHRoZSBlbGVtZW50IHlvdSBhcmUgZHJhZ2dpbmcgb3ZlclxuICAgIFxcKi9cbiAgICAvLyBlbHByb3RvLm9uRHJhZ092ZXIgPSBmdW5jdGlvbiAoZikge1xuICAgIC8vICAgICBmID8gZXZlLm9uKFwic25hcC5kcmFnLm92ZXIuXCIgKyB0aGlzLmlkLCBmKSA6IGV2ZS51bmJpbmQoXCJzbmFwLmRyYWcub3Zlci5cIiArIHRoaXMuaWQpO1xuICAgIC8vIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5kcmFnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGFsbCBkcmFnIGV2ZW50IGhhbmRsZXJzIGZyb20gdGhlIGdpdmVuIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by51bmRyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gZHJhZ2dhYmxlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgaWYgKGRyYWdnYWJsZVtpXS5lbCA9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLnVubW91c2Vkb3duKGRyYWdnYWJsZVtpXS5zdGFydCk7XG4gICAgICAgICAgICBkcmFnZ2FibGUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgZXZlLnVuYmluZChcInNuYXAuZHJhZy4qLlwiICsgdGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgIWRyYWdnYWJsZS5sZW5ndGggJiYgU25hcC51bm1vdXNlbW92ZShkcmFnTW92ZSkudW5tb3VzZXVwKGRyYWdVcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59KTtcbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYikge1xuICAgIHZhciBlbHByb3RvID0gRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgIHBwcm90byA9IFBhcGVyLnByb3RvdHlwZSxcbiAgICAgICAgcmd1cmwgPSAvXlxccyp1cmxcXCgoLispXFwpLyxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICAkID0gU25hcC5fLiQ7XG4gICAgU25hcC5maWx0ZXIgPSB7fTtcbi8vIFNJRVJSQSBQYXBlci5maWx0ZXIoKTogSSBkb24ndCB1bmRlcnN0YW5kIHRoZSBub3RlLiBEb2VzIHRoYXQgbWVhbiBhbiBIVE1MIHNob3VsZCBkZWRpY2F0ZSBhIHNlcGFyYXRlIFNWRyByZWdpb24gZm9yIGEgZmlsdGVyIGRlZmluaXRpb24/IFdoYXQncyB0aGUgYWR2YW50YWdlIG92ZXIgYSBERUZTP1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5maWx0ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPGZpbHRlcj5gIGVsZW1lbnRcbiAgICAgKipcbiAgICAgLSBmaWxzdHIgKHN0cmluZykgU1ZHIGZyYWdtZW50IG9mIGZpbHRlciBwcm92aWRlZCBhcyBhIHN0cmluZ1xuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgICogTm90ZTogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGZpbHRlcnMgZW1iZWRkZWQgaW50byB0aGUgcGFnZSBpbnNpZGUgYW4gZW1wdHkgU1ZHIGVsZW1lbnQuXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgZiA9IHBhcGVyLmZpbHRlcignPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj1cIjJcIi8+JyksXG4gICAgIHwgICAgIGMgPSBwYXBlci5jaXJjbGUoMTAsIDEwLCAxMCkuYXR0cih7XG4gICAgIHwgICAgICAgICBmaWx0ZXI6IGZcbiAgICAgfCAgICAgfSk7XG4gICAgXFwqL1xuICAgIHBwcm90by5maWx0ZXIgPSBmdW5jdGlvbiAoZmlsc3RyKSB7XG4gICAgICAgIHZhciBwYXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChwYXBlci50eXBlICE9IFwic3ZnXCIpIHtcbiAgICAgICAgICAgIHBhcGVyID0gcGFwZXIucGFwZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGYgPSBTbmFwLnBhcnNlKFN0cihmaWxzdHIpKSxcbiAgICAgICAgICAgIGlkID0gU25hcC5fLmlkKCksXG4gICAgICAgICAgICB3aWR0aCA9IHBhcGVyLm5vZGUub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBwYXBlci5ub2RlLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIGZpbHRlciA9ICQoXCJmaWx0ZXJcIik7XG4gICAgICAgICQoZmlsdGVyLCB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBmaWx0ZXJVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZi5ub2RlKTtcbiAgICAgICAgcGFwZXIuZGVmcy5hcHBlbmRDaGlsZChmaWx0ZXIpO1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZmlsdGVyKTtcbiAgICB9O1xuXG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuZmlsdGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgdmFyIHAgPSAkKHRoaXMubm9kZSwgXCJmaWx0ZXJcIik7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBTdHIocCkubWF0Y2gocmd1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoICYmIFNuYXAuc2VsZWN0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmZpbHRlclwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCAmJiB2YWx1ZS50eXBlID09IFwiZmlsdGVyXCIpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgaWQgPSB2YWx1ZS5ub2RlLmlkO1xuICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgICQodmFsdWUubm9kZSwge2lkOiB2YWx1ZS5pZH0pO1xuICAgICAgICAgICAgICAgIGlkID0gdmFsdWUuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogU25hcC51cmwoaWQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5ibHVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgYmx1ciBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIGFtb3VudCBvZiBob3Jpem9udGFsIGJsdXIsIGluIHBpeGVsc1xuICAgICAtIHkgKG51bWJlcikgI29wdGlvbmFsIGFtb3VudCBvZiB2ZXJ0aWNhbCBibHVyLCBpbiBwaXhlbHNcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBmID0gcGFwZXIuZmlsdGVyKFNuYXAuZmlsdGVyLmJsdXIoNSwgMTApKSxcbiAgICAgfCAgICAgYyA9IHBhcGVyLmNpcmNsZSgxMCwgMTAsIDEwKS5hdHRyKHtcbiAgICAgfCAgICAgICAgIGZpbHRlcjogZlxuICAgICB8ICAgICB9KTtcbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuYmx1ciA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHggPSAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWYgPSB5ID09IG51bGwgPyB4IDogW3gsIHldO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJ1xcPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj1cIntkZWZ9XCIvPicsIHtcbiAgICAgICAgICAgIGRlZjogZGVmXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuYmx1ci50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5zaGFkb3dcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBzaGFkb3cgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gZHggKG51bWJlcikgaG9yaXpvbnRhbCBzaGlmdCBvZiB0aGUgc2hhZG93LCBpbiBwaXhlbHNcbiAgICAgLSBkeSAobnVtYmVyKSB2ZXJ0aWNhbCBzaGlmdCBvZiB0aGUgc2hhZG93LCBpbiBwaXhlbHNcbiAgICAgLSBibHVyIChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgb2YgYmx1clxuICAgICAtIGNvbG9yIChzdHJpbmcpICNvcHRpb25hbCBjb2xvciBvZiB0aGUgc2hhZG93XG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgZiA9IHBhcGVyLmZpbHRlcihTbmFwLmZpbHRlci5zaGFkb3coMCwgMiwgMykpLFxuICAgICB8ICAgICBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApLmF0dHIoe1xuICAgICB8ICAgICAgICAgZmlsdGVyOiBmXG4gICAgIHwgICAgIH0pO1xuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5zaGFkb3cgPSBmdW5jdGlvbiAoZHgsIGR5LCBibHVyLCBjb2xvcikge1xuICAgICAgICBjb2xvciA9IGNvbG9yIHx8IFwiIzAwMFwiO1xuICAgICAgICBpZiAoYmx1ciA9PSBudWxsKSB7XG4gICAgICAgICAgICBibHVyID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJsdXIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29sb3IgPSBibHVyO1xuICAgICAgICAgICAgYmx1ciA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgIGR5ID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgZHkgPSBkeDtcbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IFNuYXAuY29sb3IoY29sb3IpO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwie2JsdXJ9XCIvPjxmZU9mZnNldCBkeD1cIntkeH1cIiBkeT1cIntkeX1cIiByZXN1bHQ9XCJvZmZzZXRibHVyXCIvPjxmZUZsb29kIGZsb29kLWNvbG9yPVwie2NvbG9yfVwiLz48ZmVDb21wb3NpdGUgaW4yPVwib2Zmc2V0Ymx1clwiIG9wZXJhdG9yPVwiaW5cIi8+PGZlTWVyZ2U+PGZlTWVyZ2VOb2RlLz48ZmVNZXJnZU5vZGUgaW49XCJTb3VyY2VHcmFwaGljXCIvPjwvZmVNZXJnZT4nLCB7XG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICBkeDogZHgsXG4gICAgICAgICAgICBkeTogZHksXG4gICAgICAgICAgICBibHVyOiBibHVyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2hhZG93LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmdyYXlzY2FsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGdyYXlzY2FsZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5ncmF5c2NhbGUgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCJ7YX0ge2J9IHtjfSAwIDAge2R9IHtlfSB7Zn0gMCAwIHtnfSB7Yn0ge2h9IDAgMCAwIDAgMCAxIDBcIi8+Jywge1xuICAgICAgICAgICAgYTogMC4yMTI2ICsgMC43ODc0ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYjogMC43MTUyIC0gMC43MTUyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYzogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZTogMC43MTUyICsgMC4yODQ4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZjogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgaDogMC4wNzIyICsgMC45Mjc4ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuZ3JheXNjYWxlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLnNlcGlhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgc2VwaWEgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuc2VwaWEgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCJ7YX0ge2J9IHtjfSAwIDAge2R9IHtlfSB7Zn0gMCAwIHtnfSB7aH0ge2l9IDAgMCAwIDAgMCAxIDBcIi8+Jywge1xuICAgICAgICAgICAgYTogMC4zOTMgKyAwLjYwNyAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGI6IDAuNzY5IC0gMC43NjkgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBjOiAwLjE4OSAtIDAuMTg5ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4zNDkgLSAwLjM0OSAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGU6IDAuNjg2ICsgMC4zMTQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBmOiAwLjE2OCAtIDAuMTY4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yNzIgLSAwLjI3MiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGg6IDAuNTM0IC0gMC41MzQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBpOiAwLjEzMSArIDAuODY5ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2VwaWEudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuc2F0dXJhdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBzYXR1cmF0ZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29sb3JNYXRyaXggdHlwZT1cInNhdHVyYXRlXCIgdmFsdWVzPVwie2Ftb3VudH1cIi8+Jywge1xuICAgICAgICAgICAgYW1vdW50OiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2F0dXJhdGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuaHVlUm90YXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgaHVlLXJvdGF0ZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbmdsZSAobnVtYmVyKSBhbmdsZSBvZiByb3RhdGlvblxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5odWVSb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgYW5nbGUgPSBhbmdsZSB8fCAwO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJodWVSb3RhdGVcIiB2YWx1ZXM9XCJ7YW5nbGV9XCIvPicsIHtcbiAgICAgICAgICAgIGFuZ2xlOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmh1ZVJvdGF0ZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5pbnZlcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBpbnZlcnQgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuaW52ZXJ0ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFtb3VudCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCc8ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48ZmVGdW5jRyB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48ZmVGdW5jQiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48L2ZlQ29tcG9uZW50VHJhbnNmZXI+Jywge1xuICAgICAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICAgICAgICBhbW91bnQyOiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuaW52ZXJ0LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmJyaWdodG5lc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBicmlnaHRuZXNzIGZpbHRlclxuICAgICAqKlxuICAgICAtIGFtb3VudCAobnVtYmVyKSBhbW91bnQgb2YgZmlsdGVyIChgMC4uMWApXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmJyaWdodG5lc3MgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbXBvbmVudFRyYW5zZmVyPjxmZUZ1bmNSIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjxmZUZ1bmNHIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjxmZUZ1bmNCIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj4nLCB7XG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmJyaWdodG5lc3MudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuY29udHJhc3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBjb250cmFzdCBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5jb250cmFzdCA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY1IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PGZlRnVuY0cgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PGZlRnVuY0IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPicsIHtcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgYW1vdW50MjogLjUgLSBhbW91bnQgLyAyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuY29udHJhc3QudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbn0pO1xucmV0dXJuIFNuYXA7XG59KSk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgXFxcXFxuLy8g4pSCIEV2ZSAwLjQuMiAtIEphdmFTY3JpcHQgRXZlbnRzIExpYnJhcnkgICAgICAgICAgICAgICAgICAgICAg4pSCIFxcXFxcbi8vIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpCBcXFxcXG4vLyDilIIgQXV0aG9yIERtaXRyeSBCYXJhbm92c2tpeSAoaHR0cDovL2RtaXRyeS5iYXJhbm92c2tpeS5jb20vKSDilIIgXFxcXFxuLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxcXFxcblxuKGZ1bmN0aW9uIChnbG9iKSB7XG4gICAgdmFyIHZlcnNpb24gPSBcIjAuNC4yXCIsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgc2VwYXJhdG9yID0gL1tcXC5cXC9dLyxcbiAgICAgICAgd2lsZGNhcmQgPSBcIipcIixcbiAgICAgICAgZnVuID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG51bXNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50X2V2ZW50LFxuICAgICAgICBzdG9wLFxuICAgICAgICBldmVudHMgPSB7bjoge319LFxuICAgIC8qXFxcbiAgICAgKiBldmVcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogRmlyZXMgZXZlbnQgd2l0aCBnaXZlbiBgbmFtZWAsIGdpdmVuIHNjb3BlIGFuZCBvdGhlciBwYXJhbWV0ZXJzLlxuXG4gICAgID4gQXJndW1lbnRzXG5cbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlICpldmVudCosIGRvdCAoYC5gKSBvciBzbGFzaCAoYC9gKSBzZXBhcmF0ZWRcbiAgICAgLSBzY29wZSAob2JqZWN0KSBjb250ZXh0IGZvciB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgLSB2YXJhcmdzICguLi4pIHRoZSByZXN0IG9mIGFyZ3VtZW50cyB3aWxsIGJlIHNlbnQgdG8gZXZlbnQgaGFuZGxlcnNcblxuICAgICA9IChvYmplY3QpIGFycmF5IG9mIHJldHVybmVkIHZhbHVlcyBmcm9tIHRoZSBsaXN0ZW5lcnNcbiAgICBcXCovXG4gICAgICAgIGV2ZSA9IGZ1bmN0aW9uIChuYW1lLCBzY29wZSkge1xuXHRcdFx0bmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgICAgICAgIHZhciBlID0gZXZlbnRzLFxuICAgICAgICAgICAgICAgIG9sZHN0b3AgPSBzdG9wLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGV2ZS5saXN0ZW5lcnMobmFtZSksXG4gICAgICAgICAgICAgICAgeiA9IDAsXG4gICAgICAgICAgICAgICAgZiA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgICAgaW5kZXhlZCA9IFtdLFxuICAgICAgICAgICAgICAgIHF1ZXVlID0ge30sXG4gICAgICAgICAgICAgICAgb3V0ID0gW10sXG4gICAgICAgICAgICAgICAgY2UgPSBjdXJyZW50X2V2ZW50LFxuICAgICAgICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgY3VycmVudF9ldmVudCA9IG5hbWU7XG4gICAgICAgICAgICBzdG9wID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoXCJ6SW5kZXhcIiBpbiBsaXN0ZW5lcnNbaV0pIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2gobGlzdGVuZXJzW2ldLnpJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS56SW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlW2xpc3RlbmVyc1tpXS56SW5kZXhdID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ZWQuc29ydChudW1zb3J0KTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleGVkW3pdIDwgMCkge1xuICAgICAgICAgICAgICAgIGwgPSBxdWV1ZVtpbmRleGVkW3orK11dO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gb2xkc3RvcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGwgPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKFwiekluZGV4XCIgaW4gbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobC56SW5kZXggPT0gaW5kZXhlZFt6XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2gobC5hcHBseShzY29wZSwgYXJncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHF1ZXVlW2luZGV4ZWRbel1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgJiYgb3V0LnB1c2gobC5hcHBseShzY29wZSwgYXJncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGwpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVtsLnpJbmRleF0gPSBsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2gobC5hcHBseShzY29wZSwgYXJncykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wID0gb2xkc3RvcDtcbiAgICAgICAgICAgIGN1cnJlbnRfZXZlbnQgPSBjZTtcbiAgICAgICAgICAgIHJldHVybiBvdXQubGVuZ3RoID8gb3V0IDogbnVsbDtcbiAgICAgICAgfTtcblx0XHQvLyBVbmRvY3VtZW50ZWQuIERlYnVnIG9ubHkuXG5cdFx0ZXZlLl9ldmVudHMgPSBldmVudHM7XG4gICAgLypcXFxuICAgICAqIGV2ZS5saXN0ZW5lcnNcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHdoaWNoIGdpdmVzIHlvdSBhcnJheSBvZiBhbGwgZXZlbnQgaGFuZGxlcnMgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCBieSB0aGUgZ2l2ZW4gYG5hbWVgLlxuXG4gICAgID4gQXJndW1lbnRzXG5cbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkXG5cbiAgICAgPSAoYXJyYXkpIGFycmF5IG9mIGV2ZW50IGhhbmRsZXJzXG4gICAgXFwqL1xuICAgIGV2ZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICBlID0gZXZlbnRzLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBqaixcbiAgICAgICAgICAgIG5lcyxcbiAgICAgICAgICAgIGVzID0gW2VdLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGVzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlID0gZXNbal0ubjtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtlW25hbWVzW2ldXSwgZVt3aWxkY2FyZF1dO1xuICAgICAgICAgICAgICAgIGsgPSAyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KGl0ZW0uZiB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcyA9IG5lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgXG4gICAgLypcXFxuICAgICAqIGV2ZS5vblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQmluZHMgZ2l2ZW4gZXZlbnQgaGFuZGxlciB3aXRoIGEgZ2l2ZW4gbmFtZS4gWW91IGNhbiB1c2Ugd2lsZGNhcmRzIOKAnGAqYOKAnSBmb3IgdGhlIG5hbWVzOlxuICAgICB8IGV2ZS5vbihcIioudW5kZXIuKlwiLCBmKTtcbiAgICAgfCBldmUoXCJtb3VzZS51bmRlci5mbG9vclwiKTsgLy8gdHJpZ2dlcnMgZlxuICAgICAqIFVzZSBAZXZlIHRvIHRyaWdnZXIgdGhlIGxpc3RlbmVyLlxuICAgICAqKlxuICAgICA+IEFyZ3VtZW50c1xuICAgICAqKlxuICAgICAtIG5hbWUgKHN0cmluZykgbmFtZSBvZiB0aGUgZXZlbnQsIGRvdCAoYC5gKSBvciBzbGFzaCAoYC9gKSBzZXBhcmF0ZWQsIHdpdGggb3B0aW9uYWwgd2lsZGNhcmRzXG4gICAgIC0gZiAoZnVuY3Rpb24pIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKipcbiAgICAgPSAoZnVuY3Rpb24pIHJldHVybmVkIGZ1bmN0aW9uIGFjY2VwdHMgYSBzaW5nbGUgbnVtZXJpYyBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIHotaW5kZXggb2YgdGhlIGhhbmRsZXIuIEl0IGlzIGFuIG9wdGlvbmFsIGZlYXR1cmUgYW5kIG9ubHkgdXNlZCB3aGVuIHlvdSBuZWVkIHRvIGVuc3VyZSB0aGF0IHNvbWUgc3Vic2V0IG9mIGhhbmRsZXJzIHdpbGwgYmUgaW52b2tlZCBpbiBhIGdpdmVuIG9yZGVyLCBkZXNwaXRlIG9mIHRoZSBvcmRlciBvZiBhc3NpZ25tZW50LiBcbiAgICAgPiBFeGFtcGxlOlxuICAgICB8IGV2ZS5vbihcIm1vdXNlXCIsIGVhdEl0KSgyKTtcbiAgICAgfCBldmUub24oXCJtb3VzZVwiLCBzY3JlYW0pO1xuICAgICB8IGV2ZS5vbihcIm1vdXNlXCIsIGNhdGNoSXQpKDEpO1xuICAgICAqIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBgY2F0Y2hJdCgpYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgYGVhdEl0KClgLlxuXHQgKlxuICAgICAqIElmIHlvdSB3YW50IHRvIHB1dCB5b3VyIGhhbmRsZXIgYmVmb3JlIG5vbi1pbmRleGVkIGhhbmRsZXJzLCBzcGVjaWZ5IGEgbmVnYXRpdmUgdmFsdWUuXG4gICAgICogTm90ZTogSSBhc3N1bWUgbW9zdCBvZiB0aGUgdGltZSB5b3UgZG9u4oCZdCBuZWVkIHRvIHdvcnJ5IGFib3V0IHotaW5kZXgsIGJ1dCBpdOKAmXMgbmljZSB0byBoYXZlIHRoaXMgZmVhdHVyZSDigJxqdXN0IGluIGNhc2XigJ0uXG4gICAgXFwqL1xuICAgIGV2ZS5vbiA9IGZ1bmN0aW9uIChuYW1lLCBmKSB7XG5cdFx0bmFtZSA9IFN0cmluZyhuYW1lKTtcblx0XHRpZiAodHlwZW9mIGYgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge307XG5cdFx0fVxuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICBlID0gZXZlbnRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBlID0gZS5uO1xuICAgICAgICAgICAgZSA9IGUuaGFzT3duUHJvcGVydHkobmFtZXNbaV0pICYmIGVbbmFtZXNbaV1dIHx8IChlW25hbWVzW2ldXSA9IHtuOiB7fX0pO1xuICAgICAgICB9XG4gICAgICAgIGUuZiA9IGUuZiB8fCBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBlLmYubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKGUuZltpXSA9PSBmKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuO1xuICAgICAgICB9XG4gICAgICAgIGUuZi5wdXNoKGYpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHpJbmRleCkge1xuICAgICAgICAgICAgaWYgKCt6SW5kZXggPT0gK3pJbmRleCkge1xuICAgICAgICAgICAgICAgIGYuekluZGV4ID0gK3pJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUuZlxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgZmlyZSBnaXZlbiBldmVudCB3aXRoIG9wdGlvbmFsIGFyZ3VtZW50cy5cblx0ICogQXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHJlc3VsdCBmdW5jdGlvbiB3aWxsIGJlIGFsc29cblx0ICogY29uY2F0ZWQgdG8gdGhlIGxpc3Qgb2YgZmluYWwgYXJndW1lbnRzLlxuIFx0IHwgZWwub25jbGljayA9IGV2ZS5mKFwiY2xpY2tcIiwgMSwgMik7XG4gXHQgfCBldmUub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuIFx0IHwgICAgIGNvbnNvbGUubG9nKGEsIGIsIGMpOyAvLyAxLCAyLCBbZXZlbnQgb2JqZWN0XVxuIFx0IHwgfSk7XG4gICAgID4gQXJndW1lbnRzXG5cdCAtIGV2ZW50IChzdHJpbmcpIGV2ZW50IG5hbWVcblx0IC0gdmFyYXJncyAo4oCmKSBhbmQgYW55IG90aGVyIGFyZ3VtZW50c1xuXHQgPSAoZnVuY3Rpb24pIHBvc3NpYmxlIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICBcXCovXG5cdGV2ZS5mID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGF0dHJzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRldmUuYXBwbHkobnVsbCwgW2V2ZW50LCBudWxsXS5jb25jYXQoYXR0cnMpLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcblx0XHR9O1xuXHR9O1xuICAgIC8qXFxcbiAgICAgKiBldmUuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSXMgdXNlZCBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlciB0byBzdG9wIHRoZSBldmVudCwgcHJldmVudGluZyBhbnkgc3Vic2VxdWVudCBsaXN0ZW5lcnMgZnJvbSBmaXJpbmcuXG4gICAgXFwqL1xuICAgIGV2ZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9wID0gMTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUubnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvdWxkIGJlIHVzZWQgaW5zaWRlIGV2ZW50IGhhbmRsZXIgdG8gZmlndXJlIG91dCBhY3R1YWwgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICoqXG4gICAgID4gQXJndW1lbnRzXG4gICAgICoqXG4gICAgIC0gc3VibmFtZSAoc3RyaW5nKSAjb3B0aW9uYWwgc3VibmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKipcbiAgICAgPSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgaWYgYHN1Ym5hbWVgIGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBvclxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAsIGlmIGN1cnJlbnQgZXZlbnTigJlzIG5hbWUgY29udGFpbnMgYHN1Ym5hbWVgXG4gICAgXFwqL1xuICAgIGV2ZS5udCA9IGZ1bmN0aW9uIChzdWJuYW1lKSB7XG4gICAgICAgIGlmIChzdWJuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/OlxcXFwufFxcXFwvfF4pXCIgKyBzdWJuYW1lICsgXCIoPzpcXFxcLnxcXFxcL3wkKVwiKS50ZXN0KGN1cnJlbnRfZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50X2V2ZW50O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5udHNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvdWxkIGJlIHVzZWQgaW5zaWRlIGV2ZW50IGhhbmRsZXIgdG8gZmlndXJlIG91dCBhY3R1YWwgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICoqXG4gICAgICoqXG4gICAgID0gKGFycmF5KSBuYW1lcyBvZiB0aGUgZXZlbnRcbiAgICBcXCovXG4gICAgZXZlLm50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRfZXZlbnQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUub2ZmXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGdpdmVuIGZ1bmN0aW9uIGZyb20gdGhlIGxpc3Qgb2YgZXZlbnQgbGlzdGVuZXJzIGFzc2lnbmVkIHRvIGdpdmVuIG5hbWUuXG5cdCAqIElmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWQgYWxsIHRoZSBldmVudHMgd2lsbCBiZSBjbGVhcmVkLlxuICAgICAqKlxuICAgICA+IEFyZ3VtZW50c1xuICAgICAqKlxuICAgICAtIG5hbWUgKHN0cmluZykgbmFtZSBvZiB0aGUgZXZlbnQsIGRvdCAoYC5gKSBvciBzbGFzaCAoYC9gKSBzZXBhcmF0ZWQsIHdpdGggb3B0aW9uYWwgd2lsZGNhcmRzXG4gICAgIC0gZiAoZnVuY3Rpb24pIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIGV2ZS51bmJpbmRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNlZSBAZXZlLm9mZlxuICAgIFxcKi9cbiAgICBldmUub2ZmID0gZXZlLnVuYmluZCA9IGZ1bmN0aW9uIChuYW1lLCBmKSB7XG5cdFx0aWYgKCFuYW1lKSB7XG5cdFx0ICAgIGV2ZS5fZXZlbnRzID0gZXZlbnRzID0ge246IHt9fTtcblx0XHRcdHJldHVybjtcblx0XHR9XG4gICAgICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoc2VwYXJhdG9yKSxcbiAgICAgICAgICAgIGUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzcGxpY2UsXG4gICAgICAgICAgICBpLCBpaSwgaiwgamosXG4gICAgICAgICAgICBjdXIgPSBbZXZlbnRzXTtcbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VyLmxlbmd0aDsgaiArPSBzcGxpY2UubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgICAgIHNwbGljZSA9IFtqLCAxXTtcbiAgICAgICAgICAgICAgICBlID0gY3VyW2pdLm47XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzW2ldICE9IHdpbGRjYXJkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlW25hbWVzW2ldXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlLnB1c2goZVtuYW1lc1tpXV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gZSkgaWYgKGVbaGFzXShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2UucHVzaChlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ci5zcGxpY2UuYXBwbHkoY3VyLCBzcGxpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gY3VyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGUgPSBjdXJbaV07XG4gICAgICAgICAgICB3aGlsZSAoZS5uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBlLmYubGVuZ3RoOyBqIDwgamo7IGorKykgaWYgKGUuZltqXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5mLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICFlLmYubGVuZ3RoICYmIGRlbGV0ZSBlLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gZS5uKSBpZiAoZS5uW2hhc10oa2V5KSAmJiBlLm5ba2V5XS5mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3MgPSBlLm5ba2V5XS5mO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBmdW5jcy5sZW5ndGg7IGogPCBqajsgaisrKSBpZiAoZnVuY3Nbal0gPT0gZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jcy5sZW5ndGggJiYgZGVsZXRlIGUubltrZXldLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZS5mO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlLm4pIGlmIChlLm5baGFzXShrZXkpICYmIGUubltrZXldLmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlLm5ba2V5XS5mO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUgPSBlLm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUub25jZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQmluZHMgZ2l2ZW4gZXZlbnQgaGFuZGxlciB3aXRoIGEgZ2l2ZW4gbmFtZSB0byBvbmx5IHJ1biBvbmNlIHRoZW4gdW5iaW5kIGl0c2VsZi5cbiAgICAgfCBldmUub25jZShcImxvZ2luXCIsIGYpO1xuICAgICB8IGV2ZShcImxvZ2luXCIpOyAvLyB0cmlnZ2VycyBmXG4gICAgIHwgZXZlKFwibG9naW5cIik7IC8vIG5vIGxpc3RlbmVyc1xuICAgICAqIFVzZSBAZXZlIHRvIHRyaWdnZXIgdGhlIGxpc3RlbmVyLlxuICAgICAqKlxuICAgICA+IEFyZ3VtZW50c1xuICAgICAqKlxuICAgICAtIG5hbWUgKHN0cmluZykgbmFtZSBvZiB0aGUgZXZlbnQsIGRvdCAoYC5gKSBvciBzbGFzaCAoYC9gKSBzZXBhcmF0ZWQsIHdpdGggb3B0aW9uYWwgd2lsZGNhcmRzXG4gICAgIC0gZiAoZnVuY3Rpb24pIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKipcbiAgICAgPSAoZnVuY3Rpb24pIHNhbWUgcmV0dXJuIGZ1bmN0aW9uIGFzIEBldmUub25cbiAgICBcXCovXG4gICAgZXZlLm9uY2UgPSBmdW5jdGlvbiAobmFtZSwgZikge1xuICAgICAgICB2YXIgZjIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUudW5iaW5kKG5hbWUsIGYyKTtcbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBldmUub24obmFtZSwgZjIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS52ZXJzaW9uXG4gICAgIFsgcHJvcGVydHkgKHN0cmluZykgXVxuICAgICAqKlxuICAgICAqIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS5cbiAgICBcXCovXG4gICAgZXZlLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGV2ZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiWW91IGFyZSBydW5uaW5nIEV2ZSBcIiArIHZlcnNpb247XG4gICAgfTtcbiAgICAodHlwZW9mIG1vZHVsZSAhPSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSA/IChtb2R1bGUuZXhwb3J0cyA9IGV2ZSkgOiAodHlwZW9mIGRlZmluZSAhPSBcInVuZGVmaW5lZFwiID8gKGRlZmluZShcImV2ZVwiLCBbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBldmU7IH0pKSA6IChnbG9iLmV2ZSA9IGV2ZSkpO1xufSkodGhpcyk7XG4iLCJ2b2lkIGZ1bmN0aW9uKHJvb3Qpe1xuXG5cdCd1c2Ugc3RyaWN0J1xuXG5cdHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uKG8pe1xuXHRcdHZhciBGID0gZnVuY3Rpb24oKXt9XG5cdFx0Ri5wcm90b3R5cGUgPSBvXG5cdFx0cmV0dXJuIG5ldyBGKClcblx0fVxuXG5cdHZhciBleHRlbmQgPSBmdW5jdGlvbih0bywgZnJvbSl7XG5cdFx0Zm9yICggdmFyIHAgaW4gZnJvbSApIHRvW3BdID0gZnJvbVtwXVxuXHRcdHJldHVybiB0b1xuXHR9XG5cblx0Ly8gTGlicmFyeSBvYmplY3QgLSBhIGJhc2Ugb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG5cdHZhciBWaXJhbCA9IHtcblxuXHRcdC8vIGNyZWF0ZSBhbiBpbmhlcml0aW5nIG9iamVjdCwgd2l0aCBhZGRlZCBvciBjaGFuZ2VkIG1ldGhvZHMgb3IgcHJvcGVydGllc1xuXHRcdGV4dGVuZDogZnVuY3Rpb24ocHJvcHMpe1xuXHRcdFx0cmV0dXJuIGV4dGVuZChjcmVhdGUodGhpcyksIHByb3BzKVxuXHRcdH0sXG5cblx0XHQvLyBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gb2JqZWN0LCBjYWxsaW5nIGFuIGluaXQgbWV0aG9kIGlmIGF2YWlsYWJsZVxuXHRcdG1ha2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgb2JqID0gY3JlYXRlKHRoaXMpXG5cdFx0XHRpZiAoIHR5cGVvZiBvYmouaW5pdCA9PT0gJ2Z1bmN0aW9uJyApIG9iai5pbml0LmFwcGx5KG9iaiwgYXJndW1lbnRzKVxuXHRcdFx0cmV0dXJuIG9ialxuXHRcdH1cblx0fVxuXG5cdC8vIG1vZHVsZSBkYW5jZVxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICkgbW9kdWxlLmV4cG9ydHMgPSBWaXJhbFxuXHRlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkgZGVmaW5lKFZpcmFsKVxuXHRlbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5WaXJhbCA9IFZpcmFsXG5cbn0odGhpcylcbiIsInZvaWQgZnVuY3Rpb24oKXtcbiAgdmFyIHZpcmFsID0gcmVxdWlyZSgndmlyYWwnKVxuICB2YXIgU2V0ID0gcmVxdWlyZSgnLi9zZXQuanMnKVxuICB2YXIgZW5zbGF2ZSA9IHJlcXVpcmUoJ2Vuc2xhdmUnKVxuXG4gIGZ1bmN0aW9uIGNsb25lKEEpe1xuICAgIHJldHVybiBQYXRod2F5Lm1ha2UoQS5zb3VyY2VzLCBBLmVkZ2VzLCBBLnRhcmdldHMpXG4gIH1cblxuICBmdW5jdGlvbiB1bmlvbihBLCBCKXtcblxuICAgIHJldHVybiBQYXRod2F5Lm1ha2UoQS5zb3VyY2VzLnVuaW9uKEIuc291cmNlcylcbiAgICAgICAgICAgICAgICAgICAgICAsIEEuZWRnZXMudW5pb24oQi5lZGdlcylcbiAgICAgICAgICAgICAgICAgICAgICAsIEEudGFyZ2V0cy51bmlvbihCLnRhcmdldHMpKVxuICB9XG5cbiAgZnVuY3Rpb24gc2FtZShBLCBCKXtcblxuICAgIHJldHVybiBBLnNvdXJjZXMuam9pbnQoQi5zb3VyY2VzKSB8fFxuICAgICAgICAgICBBLmVkZ2VzLmpvaW50KEIuZWRnZXMpIHx8XG4gICAgICAgICAgIEEudGFyZ2V0cy5qb2ludChCLnRhcmdldHMpXG4gIH1cblxuICB2YXIgUGF0aHdheSA9IHZpcmFsLmV4dGVuZCh7XG4gICAgaW5pdDogZnVuY3Rpb24oc291cmNlcywgZWRnZXMsIHRhcmdldHMpe1xuICAgICAgdGhpcy5zb3VyY2VzID0gc291cmNlcyAhPSBudWxsID8gc291cmNlcyA6IFNldC5tYWtlKClcbiAgICAgIHRoaXMuZWRnZXMgPSBlZGdlcyAhPSBudWxsID8gZWRnZXMgOiBTZXQubWFrZSgpXG4gICAgICB0aGlzLnRhcmdldHMgPSB0YXJnZXRzICE9IG51bGwgPyB0YXJnZXRzIDogU2V0Lm1ha2UoKVxuICAgIH1cbiAgLCBzYW1lOiBlbnNsYXZlKHNhbWUpXG4gICwgY2xvbmU6IGVuc2xhdmUoY2xvbmUpXG4gICwgdW5pb246IGVuc2xhdmUodW5pb24pXG4gIH0pXG5cbiAgZnVuY3Rpb24gaW5kZXhPZihQLCBwKXtcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBQLnZhbHVlcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgIGlmICggc2FtZShQLnZhbHVlc1tpXSwgcCkgKSByZXR1cm4gaVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpemUocGF0aHdheXMpe1xuICAgIHJldHVybiBwYXRod2F5cy52YWx1ZXMubGVuZ3RoXG4gIH1cblxuXG4gIGZ1bmN0aW9uIGZvckVhY2gocGF0aHdheXMsIGZuKXtcbiAgICBwYXRod2F5cy52YWx1ZXMuZm9yRWFjaChmbilcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZChwYXRod2F5cywgc291cmNlLCBlZGdlLCB0YXJnZXQpe1xuXG4gICAgdmFyIG4gPSBQYXRod2F5Lm1ha2UoU2V0Lm1ha2UoKS5hZGQoc291cmNlKSwgU2V0Lm1ha2UoKS5hZGQoZWRnZSksIFNldC5tYWtlKCkuYWRkKHRhcmdldCkpXG5cbiAgICB2YXIgaCA9IGluZGV4T2YocGF0aHdheXMsIG4pXG4gICAgaWYgKCBoID4gLTEgICkge1xuICAgICAgcGF0aHdheXMudmFsdWVzW2hdID0gcGF0aHdheXMudmFsdWVzW2hdLnVuaW9uKG4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGh3YXlzLnZhbHVlcy5wdXNoKG4pXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGh3YXlzXG4gIH1cblxuICB2YXIgUGF0aHdheXMgPSBTZXQuZXh0ZW5kKHtcbiAgICBhZGQ6IGVuc2xhdmUoYWRkKVxuICAsIGluZGV4T2Y6IGVuc2xhdmUoaW5kZXhPZilcbiAgfSlcblxuXG4gIG1vZHVsZS5leHBvcnRzID0gUGF0aHdheXNcblxuXG59KClcbiIsInZvaWQgZnVuY3Rpb24oKXtcbiAgdmFyIHZpcmFsID0gcmVxdWlyZSgndmlyYWwnKVxuICB2YXIgZW5zbGF2ZSA9IHJlcXVpcmUoJ2Vuc2xhdmUnKVxuICB2YXIgQXJyID0gcmVxdWlyZSgnLi9hcnIuanMnKVxuXG5cbiAgZnVuY3Rpb24gaGFzKHNldCwgdmFsdWUpe1xuICAgIHJldHVybiBzZXQuaW5kZXhPZih2YWx1ZSkgPiAtMVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkKHNldCwgdmFsdWUpe1xuICAgIGlmICggISBoYXMoc2V0LCB2YWx1ZSkgKSB7XG4gICAgICBzZXQudmFsdWVzLnB1c2godmFsdWUpXG4gICAgfVxuICAgIHJldHVybiBzZXRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZShzZXQsIHZhbHVlKXtcbiAgICB2YXIgaWR4ID0gaW5kZXhPZihzZXQsIHZhbHVlKVxuICAgIGlmICggaWR4ID4gLTEgKSB7XG4gICAgICBzZXQudmFsdWVzLnNwbGljZShpZHgsIDEpXG4gICAgfVxuICAgIHJldHVybiBzZXRcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhbWUoc2V0LCBvdGhlcil7XG4gICAgcmV0dXJuIHNldC52YWx1ZXMubGVuZ3RoICE9IG90aGVyLnZhbHVlcy5sZW5ndGggPyBmYWxzZVxuICAgICAgICAgOiBzZXQudmFsdWVzLmV2ZXJ5KGZ1bmN0aW9uKGEpeyByZXR1cm4gb3RoZXIuaGFzKGEpIH0pXG4gIH1cblxuICBmdW5jdGlvbiB1bmlvbihzZXQsIG90aGVyKXtcbiAgICB2YXIgcmVzdWx0ID0gc2V0LmNsb25lKClcbiAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uKHYpe1xuICAgICAgcmVzdWx0LmFkZCh2KVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gam9pbnQoc2V0LCBvdGhlcil7XG4gICAgcmV0dXJuIHNldC5zb21lKGZ1bmN0aW9uKGEpeyByZXR1cm4gb3RoZXIuaGFzKGEpIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZShzZXQpe1xuICAgIHJldHVybiBTZXQubWFrZShzZXQpXG4gIH1cblxuICB2YXIgU2V0ID0gQXJyLmV4dGVuZCh7XG4gICAgdW5pb246IGVuc2xhdmUodW5pb24pXG4gICwgaGFzOiBlbnNsYXZlKGhhcylcbiAgLCBhZGQ6IGVuc2xhdmUoYWRkKVxuICAsIHJlbW92ZTogZW5zbGF2ZShyZW1vdmUpXG4gICwgc2FtZTogZW5zbGF2ZShzYW1lKVxuICAsIGpvaW50OiBlbnNsYXZlKGpvaW50KVxuICAsIGNsb25lOiBlbnNsYXZlKGNsb25lKVxuICB9KVxuXG4gIG1vZHVsZS5leHBvcnRzID0gU2V0XG5cbn0oKVxuIiwidm9pZCBmdW5jdGlvbigpe1xuICBcInVzZSBzdHJpY3RcIlxuICB2YXIgcnQgPSByZXF1aXJlKCdyYW5kb20tdG9rZW4nKVxuICB2YXIgcm5kID0gcmVxdWlyZSgncmFuZG9tLW51bWJlcicpXG4gIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbiAgdmFyIHd0ID0gcmVxdWlyZSgnLi4vaW5kZXguanMnKVxuICB2YXIgZG9tID0gcmVxdWlyZSgnLi4vdXRpbC9kb20uanMnKVxuICB2YXIgdWlkID0gcmVxdWlyZSgnLi4vdXRpbC91bmlxdWVfaWQuanMnKVxuICB2YXIgcmFuZF9pbnQgPSBybmQuZ2VuZXJhdG9yKHtpbnRlZ2VyOiB0cnVlfSlcbiAgdmFyIHByaW50ID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKVxuXG4gIHZhciBsaXBzY2ZnID0ge1xuICAgICAgY291bnQ6IDEgICAgICAgICAgICAgICAgICAgICAgLy8gTnVtYmVyIG9mIHdvcmRzLCBzZW50ZW5jZXMsIG9yIHBhcmFncmFwaHMgdG8gZ2VuZXJhdGUuXG4gICAgLCB1bml0czogJ3NlbnRlbmNlcycgICAgICAgICAgICAvLyBHZW5lcmF0ZSB3b3Jkcywgc2VudGVuY2VzLCBvciBwYXJhZ3JhcGhzLlxuICAgICwgc2VudGVuY2VMb3dlckJvdW5kOiAxICAgICAgICAgLy8gTWluaW11bSB3b3JkcyBwZXIgc2VudGVuY2UuXG4gICAgLCBzZW50ZW5jZVVwcGVyQm91bmQ6IDIgICAgICAgIC8vIE1heGltdW0gd29yZHMgcGVyIHNlbnRlbmNlLlxuICAgICwgZm9ybWF0OiAncGxhaW4nICAgICAgICAgICAgICAgLy8gUGxhaW4gdGV4dCBvciBodG1sXG4gIH1cblxuICB2YXIgbGlwc3VtID0gcmVxdWlyZSgnbG9yZW0taXBzdW0nKS5iaW5kKG51bGwsIGxpcHNjZmcpXG5cbiAgZnVuY3Rpb24gaXNOdW1iZXIobil7IHJldHVybiB0eXBlb2YgbiA9PSAnbnVtYmVyJyB9XG5cbiAgdmFyIGNvbmZpZyA9IHd0LmNvbmZpZyh7XG4gICAgcGFkZGluZzogMjFcbiAgLCByYW5rX2RldGVjdGlvbl9lcnJvcl9tYXJnaW46IDJcbiAgLCBlZGdlV2lkdGg6IDVcbiAgLCBlZGdlQ2xhc3M6ICdGQ0hMaW5lJ1xuICAsIGVkZ2VFbmRDbGFzczogJ0ZDSExpbmUtd2l0aGFycm93J1xuICAsIGludGVyc2VjdGlvbkNsYXNzOiAnRkNITGluZS1pbnRlcnNlY3Rpb24nXG4gIH0pXG5cbiAgdmFyIGdyYXBoID0gd3QuZ3JhcGgoe1xuICAgIHJhbmtEaXI6ICdMUidcbiAgLCB1bml2ZXJzYWxTZXA6IDI5XG4gICwgZWRnZVNlcDogMFxuICAsIHJhbmtTZXA6IDE1MFxuICB9KVxuXG4gIHZhciBub2RlcyA9IEFycmF5KDEyKVxuICB2YXIgcmFua3MgPSBbJ3NhbWVfZmlyc3QnLCdzYW1lX3NlY29uZCcsJ3NhbWVfc2Vjb25kJywnc2FtZV9zZWNvbmQnLCdzYW1lX3RoaXJkJywnc2FtZV90aGlyZCcsJ3NhbWVfdGhpcmQnLCdzYW1lX3RoaXJkJywnc2FtZV90aGlyZCcsJ3NhbWVfZm91cnRoJywnc2FtZV9mb3VydGgnLCdzYW1lX2ZvdXJ0aCddXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aCA7IGkrKyApIHtcbiAgICBub2Rlc1tpXSA9IGdyYXBoLmFkZF9ub2RlKFxuICAgICAgJ0ZDSEJveCdcbiAgICAsIGZ1bmN0aW9uIChub2RlLCB2YWx1ZXMpe1xuLy8gdGhlc2UgbGluZXMgc2hvdWxkbid0IGJlIGhlcmVcbiAgICAgICAgbm9kZS5hdHRyKCd4JywgdmFsdWVzLngpXG4gICAgICAgIG5vZGUuYXR0cigneScsIHZhbHVlcy55KVxuICAgICAgICB2YXIgeCA9IHZhbHVlcy54IC0gdmFsdWVzLndpZHRoIC8gMlxuICAgICAgICB2YXIgeSA9IHZhbHVlcy55IC0gdmFsdWVzLmhlaWdodCAvIDJcbiAgICAgICAgbm9kZS5hZGRfYXR0cignOmZpcnN0JywgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAnLCcgKyB5ICsgJyknKVxuICAgICAgICBub2RlLmFkZF9hdHRyKCcuRkNIQm94LVRleHQtYmcnLCAnd2lkdGgnLCB2YWx1ZXMud2lkdGggKVxuICAgICAgICBub2RlLmFkZF9hdHRyKCcuRkNIQm94LVRleHQtYmcnLCAnaGVpZ2h0JywgdmFsdWVzLmhlaWdodClcbiAgICB9XG4gICAgLCB7XG4gICAgICAgIFwiLkZDSEJveC1UZXh0LXRpdGxlXCI6IHtfdGV4dDogKGkrMSkgKycgJyArbGlwc3VtKCl9XG4gICAgICAsIFwiLkZDSEJveC1UZXh0LXR5cGVcIiA6IHtfdGV4dDogJ1R5cGU6ICcgKyBsaXBzdW0oKX1cbiAgICB9LCByYW5rc1tpXSlcbiAgfVxuXG4gIC8vIHZhciBybmRfbm9kZSA9IHJuZC5nZW5lcmF0b3Ioe21pbjogMCwgbWF4OiBub2Rlcy5sZW5ndGggLSAxLCBpbnRlZ2VyOiB0cnVlfSlcbiAgLy8gdmFyIGxpbmtzPSBBcnJheShyYW5kX2ludCgxLCBNYXRoLnBvdyhyYW5kX2ludCgxLCBub2Rlcy5sZW5ndGgpLCAyKSAtIDEpKVxuICB2YXIgY29ubmVjdGlvbnMgPSBbXG4gICAgWzAsMV1cbiAgLCBbMCwyXVxuICAsIFswLDNdXG4gICwgWzEsNF1cbiAgLCBbMSw1XVxuICAsIFsxLDZdXG4gICwgWzMsOV1cbiAgLCBbMiw3XVxuICAsIFsyLDhdXG4gICwgWzQsOV1cbiAgLCBbNiw5XVxuICAsIFs1LDEwXVxuICAsIFs3LDExXVxuICAsIFs4LDExXVxuICAsIFs5LDddXG4gICwgWzksOF1cbiAgLCBbOSwxMV1cbiAgLCBbMTAsN11cbiAgLCBbMTAsOF1cbiAgLCBbMTAsMTFdXG4gIF1cbiAgdmFyIGxpbmtzID0gQXJyYXkoY29ubmVjdGlvbnMubGVuZ3RoKVxuXG5cbiAgZnVuY3Rpb24gYnV0KGdlbiwgeCl7XG4gICAgdmFyIHIgPSBnZW4oKVxuICAgIHdoaWxlICggciA9PSB4ICkgeyByID0gZ2VuKCkgfVxuICAgIHJldHVybiByXG4gIH1cblxuXG4gIGZvciAoIHZhciBpID0gY29ubmVjdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tICkge1xuICAgIC8vdmFyIGxpbmsxID0gcm5kX25vZGUoKVxuXG4gICAgbGlua3NbaV0gPSBncmFwaC5jb25uZWN0KFxuICAgICAgJ0ZDSExpbmUnXG4gICAgLy8gLCBub2Rlc1tsaW5rMV1cbiAgICAvLyAsIG5vZGVzW2J1dChybmRfbm9kZSwgbGluazEpXVxuICAgICwgbm9kZXNbY29ubmVjdGlvbnNbaV1bMF1dXG4gICAgLCBub2Rlc1tjb25uZWN0aW9uc1tpXVsxXV1cbiAgKVxuXG4gIH1cblxuICB2YXIgZGlhZ3JhbSA9IHd0LmRpYWdyYW0oY29uZmlnLCBncmFwaClcbiAgZGlhZ3JhbS50b19kZWZzKFwiPGZvbnQgaG9yaXotYWR2LXg9XFxcIjIwNDhcXFwiPlxcbiAgPCEtLSBPcGVuIFNhbnMgaXMgYSB0cmFkZW1hcmsgb2YgR29vZ2xlIGFuZCBtYXkgYmUgcmVnaXN0ZXJlZCBpbiBjZXJ0YWluIGp1cmlzZGljdGlvbnMuIC0tPlxcbiAgPCEtLSBDb3B5cmlnaHQ6IENvcHlyaWdodCAyMDE0IEFkb2JlIFN5c3RlbSBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIC0tPlxcbiAgPGZvbnQtZmFjZSBmb250LWZhbWlseT1cXFwiT3BlblNhbnMtU2VtaWJvbGRcXFwiIHVuaXRzLXBlci1lbT1cXFwiMjA0OFxcXCIgdW5kZXJsaW5lLXBvc2l0aW9uPVxcXCItMTU0XFxcIiB1bmRlcmxpbmUtdGhpY2tuZXNzPVxcXCIxMDJcXFwiLz5cXG4gIDxtaXNzaW5nLWdseXBoIGhvcml6LWFkdi14PVxcXCIxMjI5XFxcIiBkPVxcXCJNMTkzLDE0NjJsODQxLDBsMCwtMTQ2MmwtODQxLDBNMjk3LDEwNGw2MzMsMGwwLDEyNTRsLTYzMywwelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIiBcXFwiIGhvcml6LWFkdi14PVxcXCI1MzJcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCIhXFxcIiBob3Jpei1hZHYteD1cXFwiNTY1XFxcIiBkPVxcXCJNMzcxLDQ0NGwtMTc0LDBsLTUyLDEwMThsMjc3LDBNMTMzLDEyNUMxMzMsMTc0IDE0NiwyMTIgMTcyLDIzOEMxOTgsMjYzIDIzNSwyNzYgMjgzLDI3NkMzMzAsMjc2IDM2NywyNjMgMzkyLDIzNkM0MTcsMjA5IDQzMCwxNzIgNDMwLDEyNUM0MzAsNzggNDE3LDQwIDM5MiwxM0MzNjYsLTE1IDMzMCwtMjkgMjgzLC0yOUMyMzYsLTI5IDE5OSwtMTYgMTczLDExQzE0NiwzOCAxMzMsNzYgMTMzLDEyNXpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCImcXVvdDtcXFwiIGhvcml6LWFkdi14PVxcXCI4OTNcXFwiIGQ9XFxcIk0zNjUsMTQ2MmwtNDEsLTUyOGwtMTUwLDBsLTQxLDUyOE03NjAsMTQ2MmwtNDEsLTUyOGwtMTUwLDBsLTQxLDUyOHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCIjXFxcIiBob3Jpei1hZHYteD1cXFwiMTMyM1xcXCIgZD1cXFwiTTk4OSw4NzBsLTU1LC0yODRsMjcwLDBsMCwtMTY4bC0zMDMsMGwtODAsLTQxOGwtMTc4LDBsODAsNDE4bC0yNDgsMGwtODAsLTQxOGwtMTc0LDBsNzYsNDE4bC0yNTAsMGwwLDE2OGwyODMsMGw1NywyODRsLTI2NCwwbDAsMTY4bDI5MywwbDgwLDQyMmwxODAsMGwtODAsLTQyMmwyNTIsMGw4MCw0MjJsMTc0LDBsLTgwLC00MjJsMjUyLDBsMCwtMTY4TTUwNiw1ODZsMjUwLDBsNTcsMjg0bC0yNTAsMHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCIkXFxcIiBob3Jpei1hZHYteD1cXFwiMTE2OVxcXCIgZD1cXFwiTTEwNjMsNDUzQzEwNjMsMzU2IDEwMjgsMjc3IDk1NywyMTRDODg2LDE1MSA3ODQsMTEzIDY1MSw5OGwwLC0yMTdsLTEzMywwbDAsMjExQzM1Myw5NSAyMTcsMTIwIDExMSwxNjhsMCwyMTFDMTY4LDM1MSAyMzUsMzI4IDMxMiwzMDlDMzg5LDI5MCA0NTcsMjgwIDUxOCwyNzlsMCwzNzRsLTg0LDMxQzMyNSw3MjYgMjQ1LDc3NiAxOTUsODM1QzE0NCw4OTMgMTE5LDk2NSAxMTksMTA1MUMxMTksMTE0MyAxNTUsMTIxOSAyMjcsMTI3OEMyOTgsMTMzNyAzOTUsMTM3MyA1MTgsMTM4NmwwLDE2OGwxMzMsMGwwLC0xNjVDNzg2LDEzODQgOTE1LDEzNTcgMTAzNiwxMzA3bC03MywtMTgzQzg1OCwxMTY1IDc1NCwxMTkwIDY1MSwxMTk4bDAsLTM2NGw3NiwtMjlDODU0LDc1NiA5NDEsNzA1IDk5MCw2NTFDMTAzOSw1OTcgMTA2Myw1MzEgMTA2Myw0NTNNODI3LDQzOEM4MjcsNDc3IDgxNCw1MDkgNzg3LDUzNEM3NjAsNTU5IDcxNCw1ODMgNjUxLDYwNmwwLC0zMTlDNzY4LDMwNSA4MjcsMzU1IDgyNyw0MzhNMzU0LDEwNTNDMzU0LDEwMTUgMzY2LDk4MyAzOTAsOTU4QzQxMyw5MzMgNDU2LDkwOCA1MTgsODgzbDAsMzExQzQ2NSwxMTg2IDQyNCwxMTcwIDM5NiwxMTQ1QzM2OCwxMTIwIDM1NCwxMDkwIDM1NCwxMDUzelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIiVcXFwiIGhvcml6LWFkdi14PVxcXCIxNzY1XFxcIiBkPVxcXCJNMjc5LDEwMjRDMjc5LDkyNSAyODksODUxIDMwOCw4MDJDMzI3LDc1MyAzNTksNzI5IDQwMyw3MjlDNDkxLDcyOSA1MzUsODI3IDUzNSwxMDI0QzUzNSwxMjIxIDQ5MSwxMzE5IDQwMywxMzE5QzM1OSwxMzE5IDMyNywxMjk1IDMwOCwxMjQ2QzI4OSwxMTk3IDI3OSwxMTIzIDI3OSwxMDI0TTcyOSwxMDI2QzcyOSw4NzMgNzAyLDc1OCA2NDcsNjgxQzU5Miw2MDQgNTEwLDU2NSA0MDMsNTY1QzMwMiw1NjUgMjIzLDYwNSAxNjgsNjg1QzExMiw3NjQgODQsODc4IDg0LDEwMjZDODQsMTMzMSAxOTAsMTQ4MyA0MDMsMTQ4M0M1MDgsMTQ4MyA1ODgsMTQ0NCA2NDUsMTM2NUM3MDEsMTI4NiA3MjksMTE3MyA3MjksMTAyNk0xMjMxLDQ0MEMxMjMxLDM0MSAxMjQxLDI2NiAxMjYxLDIxN0MxMjgwLDE2OCAxMzEyLDE0MyAxMzU2LDE0M0MxNDQzLDE0MyAxNDg3LDI0MiAxNDg3LDQ0MEMxNDg3LDYzNSAxNDQzLDczMyAxMzU2LDczM0MxMzEyLDczMyAxMjgwLDcwOSAxMjYxLDY2MUMxMjQxLDYxMyAxMjMxLDUzOSAxMjMxLDQ0ME0xNjgxLDQ0MEMxNjgxLDI4NyAxNjUzLDE3MiAxNTk4LDk1QzE1NDMsMTggMTQ2MiwtMjAgMTM1NiwtMjBDMTI1NSwtMjAgMTE3NiwyMCAxMTIwLDk5QzEwNjQsMTc4IDEwMzYsMjkxIDEwMzYsNDQwQzEwMzYsNzQ1IDExNDMsODk3IDEzNTYsODk3QzE0NTksODk3IDE1MzksODU4IDE1OTYsNzc5QzE2NTMsNzAwIDE2ODEsNTg3IDE2ODEsNDQwTTEzODQsMTQ2MmwtODExLC0xNDYybC0xOTQsMGw4MTEsMTQ2MnpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCImYW1wO1xcXCIgaG9yaXotYWR2LXg9XFxcIjE1MTZcXFwiIGQ9XFxcIk00NTEsMTE0N0M0NTEsMTEwNSA0NjIsMTA2NSA0ODUsMTAyOEM1MDcsOTkxIDUzOCw5NTEgNTc4LDkwOUM2NTMsOTUyIDcwNiw5OTIgNzM3LDEwMjlDNzY3LDEwNjYgNzgyLDExMDcgNzgyLDExNTNDNzgyLDExOTYgNzY4LDEyMzEgNzM5LDEyNTdDNzEwLDEyODMgNjcxLDEyOTYgNjIzLDEyOTZDNTcwLDEyOTYgNTI5LDEyODMgNDk4LDEyNTZDNDY3LDEyMjkgNDUxLDExOTIgNDUxLDExNDdNNjAwLDE4MkM3MjIsMTgyIDgyNiwyMTggOTEzLDI4OWwtMzgzLDM3N0M0NTksNjIxIDQxMSw1NzggMzg0LDUzOUMzNTcsNDk5IDM0NCw0NTQgMzQ0LDQwM0MzNDQsMzM4IDM2NywyODUgNDE0LDI0NEM0NjAsMjAzIDUyMiwxODIgNjAwLDE4Mk05NiwzODdDOTYsNDc0IDExNyw1NTEgMTYwLDYxNkMyMDMsNjgxIDI4MCw3NDUgMzkxLDgwOUMzMjgsODgzIDI4NSw5NDYgMjYyLDk5N0MyMzksMTA0OCAyMjcsMTEwMCAyMjcsMTE1NUMyMjcsMTI1NiAyNjMsMTMzNiAzMzYsMTM5NUM0MDgsMTQ1NCA1MDUsMTQ4MyA2MjcsMTQ4M0M3NDUsMTQ4MyA4MzgsMTQ1NSA5MDUsMTM5OEM5NzIsMTM0MSAxMDA2LDEyNjQgMTAwNiwxMTY3QzEwMDYsMTA5MSA5ODQsMTAyMiA5MzksOTYwQzg5NCw4OTggODE4LDgzNiA3MTMsNzc0bDM0NiwtMzM0QzExMTMsNTExIDExNTgsNjE2IDExOTQsNzU0bDI0MiwwQzEzODksNTY1IDEzMTUsNDEwIDEyMTIsMjkxbDMwMSwtMjkxbC0zMDMsMGwtMTQ5LDE0NUM5OTMsOTAgOTIxLDQ5IDg0NCwyMkM3NjcsLTYgNjgxLC0yMCA1ODgsLTIwQzQzNSwtMjAgMzE0LDE2IDIyNyw4OUMxNDAsMTYyIDk2LDI2MSA5NiwzODd6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiJ1xcXCIgaG9yaXotYWR2LXg9XFxcIjQ5OFxcXCIgZD1cXFwiTTM2NSwxNDYybC00MSwtNTI4bC0xNTAsMGwtNDEsNTI4elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIihcXFwiIGhvcml6LWFkdi14PVxcXCI2NDlcXFwiIGQ9XFxcIk04Miw1NjFDODIsNzM4IDEwOCw5MDMgMTYwLDEwNTdDMjExLDEyMTEgMjg2LDEzNDYgMzgzLDE0NjJsMjA1LDBDNDk1LDEzMzcgNDI0LDExOTYgMzc1LDEwNDFDMzI2LDg4NSAzMDEsNzI2IDMwMSw1NjNDMzAxLDQwMCAzMjYsMjQzIDM3NSw5MEM0MjQsLTYzIDQ5NSwtMjAxIDU4NiwtMzI0bC0yMDMsMEMyODUsLTIxMSAyMTAsLTc4IDE1OSw3M0MxMDgsMjI0IDgyLDM4NyA4Miw1NjF6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiKVxcXCIgaG9yaXotYWR2LXg9XFxcIjY0OVxcXCIgZD1cXFwiTTU2Nyw1NjFDNTY3LDM4NiA1NDEsMjIyIDQ5MCw3MUM0MzgsLTgwIDM2MywtMjEyIDI2NiwtMzI0bC0yMDMsMEMxNTUsLTE5OSAyMjYsLTYxIDI3NSw5MUMzMjQsMjQzIDM0OCw0MDAgMzQ4LDU2M0MzNDgsNzI2IDMyMyw4ODYgMjc0LDEwNDFDMjI1LDExOTYgMTU0LDEzMzYgNjEsMTQ2MmwyMDUsMEMzNjQsMTM0NSA0MzksMTIxMCA0OTAsMTA1NkM1NDEsOTAxIDU2Nyw3MzYgNTY3LDU2MXpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCIqXFxcIiBob3Jpei1hZHYteD1cXFwiMTEyMlxcXCIgZD1cXFwiTTY3MiwxNTU2bC00MSwtMzgybDM4NSwxMDhsMjgsLTIxN2wtMzYwLC0yOWwyMzYsLTMxMWwtMTk5LC0xMDdsLTE2NiwzMzhsLTE0OSwtMzM4bC0yMDUsMTA3bDIzMSwzMTFsLTM1OCwyOWwzNSwyMTdsMzc2LC0xMDhsLTQxLDM4MnpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCIrXFxcIiBob3Jpei1hZHYteD1cXFwiMTE2OVxcXCIgZD1cXFwiTTQ5NCw2MzNsLTM5OCwwbDAsMTc4bDM5OCwwbDAsNDA4bDE4MCwwbDAsLTQwOGwzOTksMGwwLC0xNzhsLTM5OSwwbDAsLTQwNmwtMTgwLDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiLFxcXCIgaG9yaXotYWR2LXg9XFxcIjU0N1xcXCIgZD1cXFwiTTQxMiwyMTVDMzgwLDkxIDMyMSwtNjkgMjM2LC0yNjRsLTE3MywwQzEwOSwtODQgMTQzLDgzIDE2NiwyMzhsMjMxLDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiLVxcXCIgaG9yaXotYWR2LXg9XFxcIjY1OVxcXCIgZD1cXFwiTTcyLDQ0OWwwLDIwMGw1MTQsMGwwLC0yMDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiLlxcXCIgaG9yaXotYWR2LXg9XFxcIjU2M1xcXCIgZD1cXFwiTTEzMywxMjVDMTMzLDE3NCAxNDYsMjExIDE3MSwyMzdDMTk2LDI2MyAyMzMsMjc2IDI4MSwyNzZDMzMwLDI3NiAzNjcsMjYzIDM5MiwyMzZDNDE3LDIwOSA0MzAsMTcyIDQzMCwxMjVDNDMwLDc4IDQxNyw0MCAzOTIsMTNDMzY2LC0xNSAzMjksLTI5IDI4MSwtMjlDMjMzLC0yOSAxOTYsLTE1IDE3MSwxMkMxNDYsMzkgMTMzLDc3IDEzMywxMjV6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiL1xcXCIgaG9yaXotYWR2LXg9XFxcIjc5OVxcXCIgZD1cXFwiTTc4MiwxNDYybC01NDQsLTE0NjJsLTIyMiwwbDU0NSwxNDYyelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIjBcXFwiIGhvcml6LWFkdi14PVxcXCIxMTY5XFxcIiBkPVxcXCJNMTA4MSw3MzFDMTA4MSw0NzcgMTA0MCwyODggOTU5LDE2NUM4NzcsNDIgNzUyLC0yMCA1ODQsLTIwQzQyMSwtMjAgMjk4LDQ0IDIxNCwxNzFDMTMwLDI5OCA4OCw0ODUgODgsNzMxQzg4LDk4OSAxMjksMTE3OSAyMTEsMTMwMkMyOTIsMTQyNCA0MTcsMTQ4NSA1ODQsMTQ4NUM3NDcsMTQ4NSA4NzEsMTQyMSA5NTUsMTI5M0MxMDM5LDExNjUgMTA4MSw5NzggMTA4MSw3MzFNMzI2LDczMUMzMjYsNTMyIDM0NywzODkgMzg4LDMwNEM0MjksMjE5IDQ5NCwxNzYgNTg0LDE3NkM2NzQsMTc2IDc0MCwyMTkgNzgyLDMwNkM4MjMsMzkzIDg0NCw1MzQgODQ0LDczMUM4NDQsOTI3IDgyMywxMDY5IDc4MiwxMTU3Qzc0MCwxMjQ0IDY3NCwxMjg4IDU4NCwxMjg4QzQ5NCwxMjg4IDQyOSwxMjQ1IDM4OCwxMTU5QzM0NywxMDczIDMyNiw5MzAgMzI2LDczMXpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCIxXFxcIiBob3Jpei1hZHYteD1cXFwiMTE2OVxcXCIgZD1cXFwiTTc4MCwwbC0yMzUsMGwwLDk0NEM1NDUsMTA1NyA1NDgsMTE0NiA1NTMsMTIxMkM1MzgsMTE5NiA1MTksMTE3OCA0OTcsMTE1OUM0NzQsMTE0MCAzOTksMTA3OCAyNzIsOTc1bC0xMTgsMTQ5bDQzMCwzMzhsMTk2LDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiMlxcXCIgaG9yaXotYWR2LXg9XFxcIjExNjlcXFwiIGQ9XFxcIk0xMDgxLDBsLTk5MSwwbDAsMTc4bDM3NywzNzlDNTc4LDY3MSA2NTIsNzUyIDY4OSw4MDBDNzI1LDg0NyA3NTEsODkyIDc2OCw5MzRDNzg1LDk3NiA3OTMsMTAyMSA3OTMsMTA2OUM3OTMsMTEzNSA3NzMsMTE4NyA3MzQsMTIyNUM2OTQsMTI2MyA2MzksMTI4MiA1NjksMTI4MkM1MTMsMTI4MiA0NTksMTI3MiA0MDcsMTI1MUMzNTQsMTIzMCAyOTQsMTE5MyAyMjUsMTEzOWwtMTI3LDE1NUMxNzksMTM2MyAyNTgsMTQxMSAzMzUsMTQ0MEM0MTIsMTQ2OSA0OTMsMTQ4MyA1ODAsMTQ4M0M3MTYsMTQ4MyA4MjUsMTQ0OCA5MDcsMTM3N0M5ODksMTMwNiAxMDMwLDEyMTAgMTAzMCwxMDkwQzEwMzAsMTAyNCAxMDE4LDk2MSA5OTUsOTAyQzk3MSw4NDMgOTM1LDc4MiA4ODYsNzE5QzgzNyw2NTYgNzU1LDU3MCA2NDEsNDYzbC0yNTQsLTI0NmwwLC0xMGw2OTQsMHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCIzXFxcIiBob3Jpei1hZHYteD1cXFwiMTE2OVxcXCIgZD1cXFwiTTEwMjYsMTEyNkMxMDI2LDEwMzMgOTk5LDk1NiA5NDUsODk1Qzg5MSw4MzMgODE1LDc5MSA3MTcsNzcwbDAsLThDODM0LDc0NyA5MjIsNzExIDk4MSw2NTNDMTA0MCw1OTQgMTA2OSw1MTcgMTA2OSw0MjBDMTA2OSwyNzkgMTAxOSwxNzEgOTIwLDk1QzgyMSwxOCA2NzksLTIwIDQ5NiwtMjBDMzM0LC0yMCAxOTcsNiA4Niw1OWwwLDIwOUMxNDgsMjM3IDIxNCwyMTQgMjgzLDE5N0MzNTIsMTgwIDQxOSwxNzIgNDgzLDE3MkM1OTYsMTcyIDY4MSwxOTMgNzM3LDIzNUM3OTMsMjc3IDgyMSwzNDIgODIxLDQzMEM4MjEsNTA4IDc5MCw1NjUgNzI4LDYwMkM2NjYsNjM5IDU2OSw2NTcgNDM2LDY1N2wtMTI3LDBsMCwxOTFsMTI5LDBDNjcxLDg0OCA3ODgsOTI5IDc4OCwxMDkwQzc4OCwxMTUzIDc2OCwxMjAxIDcyNywxMjM1QzY4NiwxMjY5IDYyNiwxMjg2IDU0NywxMjg2QzQ5MiwxMjg2IDQzOCwxMjc4IDM4NywxMjYzQzMzNiwxMjQ3IDI3NSwxMjE2IDIwNSwxMTcxbC0xMTUsMTY0QzIyNCwxNDM0IDM4MCwxNDgzIDU1NywxNDgzQzcwNCwxNDgzIDgxOSwxNDUxIDkwMiwxMzg4Qzk4NSwxMzI1IDEwMjYsMTIzNyAxMDI2LDExMjZ6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiNFxcXCIgaG9yaXotYWR2LXg9XFxcIjExNjlcXFwiIGQ9XFxcIk0xMTMzLDMxOWwtMTk3LDBsMCwtMzE5bC0yMjksMGwwLDMxOWwtNjY4LDBsMCwxODFsNjY4LDk2NmwyMjksMGwwLC05NTJsMTk3LDBNNzA3LDUxNGwwLDM2N0M3MDcsMTAxMiA3MTAsMTExOSA3MTcsMTIwMmwtOCwwQzY5MCwxMTU4IDY2MSwxMTA1IDYyMSwxMDQybC0zNjMsLTUyOHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCI1XFxcIiBob3Jpei1hZHYteD1cXFwiMTE2OVxcXCIgZD1cXFwiTTU4Niw5MTNDNzMzLDkxMyA4NTAsODc0IDkzNiw3OTZDMTAyMiw3MTggMTA2NSw2MTIgMTA2NSw0NzdDMTA2NSwzMjEgMTAxNiwxOTkgOTE5LDExMkM4MjEsMjQgNjgyLC0yMCA1MDIsLTIwQzMzOSwtMjAgMjEwLDYgMTE3LDU5bDAsMjEzQzE3MSwyNDEgMjMzLDIxOCAzMDMsMjAxQzM3MywxODQgNDM4LDE3NiA0OTgsMTc2QzYwNCwxNzYgNjg1LDIwMCA3NDAsMjQ3Qzc5NSwyOTQgODIzLDM2NCA4MjMsNDU1QzgyMyw2MzAgNzEyLDcxNyA0ODksNzE3QzQ1OCw3MTcgNDE5LDcxNCAzNzMsNzA4QzMyNyw3MDEgMjg3LDY5NCAyNTIsNjg2bC0xMDUsNjJsNTYsNzE0bDc2MCwwbDAsLTIwOWwtNTUzLDBsLTMzLC0zNjJDNDAwLDg5NSA0MjksOTAwIDQ2Myw5MDVDNDk2LDkxMCA1MzcsOTEzIDU4Niw5MTN6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiNlxcXCIgaG9yaXotYWR2LXg9XFxcIjExNjlcXFwiIGQ9XFxcIk05NCw2MjNDOTQsMTE5NSAzMjcsMTQ4MSA3OTMsMTQ4MUM4NjYsMTQ4MSA5MjgsMTQ3NSA5NzksMTQ2NGwwLC0xOTZDOTI4LDEyODMgODcwLDEyOTAgODAzLDEyOTBDNjQ2LDEyOTAgNTI5LDEyNDggNDUwLDExNjRDMzcxLDEwODAgMzI5LDk0NSAzMjIsNzYwbDEyLDBDMzY1LDgxNCA0MDksODU2IDQ2Niw4ODZDNTIzLDkxNSA1ODksOTMwIDY2Niw5MzBDNzk5LDkzMCA5MDIsODg5IDk3Niw4MDhDMTA1MCw3MjcgMTA4Nyw2MTYgMTA4Nyw0NzdDMTA4NywzMjQgMTA0NCwyMDMgOTU5LDExNEM4NzMsMjUgNzU2LC0yMCA2MDgsLTIwQzUwMywtMjAgNDEyLDUgMzM1LDU2QzI1OCwxMDYgMTk4LDE3OSAxNTcsMjc2QzExNSwzNzIgOTQsNDg4IDk0LDYyM002MDQsMTc0QzY4NSwxNzQgNzQ3LDIwMCA3OTEsMjUyQzgzNCwzMDQgODU2LDM3OCA4NTYsNDc1Qzg1Niw1NTkgODM2LDYyNSA3OTUsNjczQzc1NCw3MjEgNjkyLDc0NSA2MTAsNzQ1QzU1OSw3NDUgNTEzLDczNCA0NzAsNzEzQzQyNyw2OTEgMzk0LDY2MSAzNjksNjI0QzM0NCw1ODYgMzMyLDU0NyAzMzIsNTA4QzMzMiw0MTQgMzU4LDMzNSA0MDksMjcxQzQ2MCwyMDYgNTI1LDE3NCA2MDQsMTc0elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIjdcXFwiIGhvcml6LWFkdi14PVxcXCIxMTY5XFxcIiBkPVxcXCJNMjU2LDBsNTc4LDEyNTNsLTc2MCwwbDAsMjA3bDEwMTEsMGwwLC0xNjRsLTU3NSwtMTI5NnpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCI4XFxcIiBob3Jpei1hZHYteD1cXFwiMTE2OVxcXCIgZD1cXFwiTTU4NCwxNDgxQzcyMywxNDgxIDgzMiwxNDQ5IDkxMywxMzg2Qzk5NCwxMzIyIDEwMzQsMTIzNyAxMDM0LDExMzBDMTAzNCw5ODAgOTQ0LDg2MSA3NjQsNzcyQzg3OSw3MTUgOTYwLDY1NCAxMDA5LDU5MUMxMDU3LDUyOCAxMDgxLDQ1NyAxMDgxLDM3OUMxMDgxLDI1OCAxMDM3LDE2MiA5NDgsODlDODU5LDE2IDczOSwtMjAgNTg4LC0yMEM0MjksLTIwIDMwNiwxNCAyMTksODJDMTMyLDE1MCA4OCwyNDYgODgsMzcxQzg4LDQ1MiAxMTEsNTI2IDE1Nyw1OTFDMjAyLDY1NiAyNzcsNzEzIDM4MSw3NjRDMjkyLDgxNyAyMjgsODc0IDE5MCw5MzNDMTUyLDk5MiAxMzMsMTA1OSAxMzMsMTEzM0MxMzMsMTIzOSAxNzUsMTMyNCAyNTgsMTM4N0MzNDEsMTQ1MCA0NTAsMTQ4MSA1ODQsMTQ4MU0zMTMsMzc5QzMxMywzMTAgMzM3LDI1NiAzODYsMjE4QzQzNSwxNzkgNTAxLDE2MCA1ODQsMTYwQzY3MCwxNjAgNzM3LDE4MCA3ODUsMjIwQzgzMiwyNTkgODU2LDMxMyA4NTYsMzgxQzg1Niw0MzUgODM0LDQ4NCA3OTAsNTI5Qzc0Niw1NzQgNjc5LDYxNSA1OTAsNjUzbC0yOSwxM0M0NzMsNjI3IDQxMCw1ODUgMzcxLDUzOUMzMzIsNDkyIDMxMyw0MzkgMzEzLDM3OU01ODIsMTMwMEM1MTUsMTMwMCA0NjIsMTI4NCA0MjEsMTI1MUMzODAsMTIxOCAzNjAsMTE3MyAzNjAsMTExNkMzNjAsMTA4MSAzNjcsMTA1MCAzODIsMTAyM0MzOTcsOTk2IDQxOCw5NzEgNDQ2LDk0OUM0NzQsOTI2IDUyMSw4OTkgNTg4LDg2OEM2NjgsOTAzIDcyNSw5NDEgNzU4LDk4MEM3OTEsMTAxOSA4MDcsMTA2NCA4MDcsMTExNkM4MDcsMTE3MyA3ODcsMTIxOCA3NDYsMTI1MUM3MDUsMTI4NCA2NTAsMTMwMCA1ODIsMTMwMHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCI5XFxcIiBob3Jpei1hZHYteD1cXFwiMTE2OVxcXCIgZD1cXFwiTTEwNzksODM4QzEwNzksNTUwIDEwMjEsMzM1IDkwNSwxOTNDNzg5LDUxIDYxNCwtMjAgMzgxLC0yMEMyOTIsLTIwIDIyOSwtMTUgMTkwLC00bDAsMTk3QzI0OSwxNzYgMzA5LDE2OCAzNjksMTY4QzUyOCwxNjggNjQ2LDIxMSA3MjQsMjk2QzgwMiwzODEgODQ1LDUxNSA4NTIsNjk4bC0xMiwwQzgwMSw2MzggNzUzLDU5NSA2OTgsNTY4QzY0Miw1NDEgNTc3LDUyOCA1MDIsNTI4QzM3Myw1MjggMjcxLDU2OCAxOTcsNjQ5QzEyMyw3MzAgODYsODQwIDg2LDk4MUM4NiwxMTM0IDEyOSwxMjU1IDIxNSwxMzQ2QzMwMCwxNDM2IDQxNywxNDgxIDU2NSwxNDgxQzY2OSwxNDgxIDc2MCwxNDU2IDgzNywxNDA1QzkxNCwxMzU0IDk3NCwxMjgxIDEwMTYsMTE4NUMxMDU4LDEwODggMTA3OSw5NzMgMTA3OSw4MzhNNTY5LDEyODZDNDg4LDEyODYgNDI1LDEyNjAgMzgyLDEyMDdDMzM5LDExNTQgMzE3LDEwNzkgMzE3LDk4M0MzMTcsOTAwIDMzNyw4MzQgMzc4LDc4N0M0MTgsNzM5IDQ3OSw3MTUgNTYxLDcxNUM2NDAsNzE1IDcwNyw3MzkgNzYxLDc4NkM4MTUsODMzIDg0Miw4ODkgODQyLDk1MkM4NDIsMTAxMSA4MzEsMTA2NyA4MDgsMTExOUM3ODUsMTE3MCA3NTIsMTIxMSA3MTEsMTI0MUM2NzAsMTI3MSA2MjIsMTI4NiA1NjksMTI4NnpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCI6XFxcIiBob3Jpei1hZHYteD1cXFwiNTYzXFxcIiBkPVxcXCJNMTMzLDEyNUMxMzMsMTc0IDE0NiwyMTEgMTcxLDIzN0MxOTYsMjYzIDIzMywyNzYgMjgxLDI3NkMzMzAsMjc2IDM2NywyNjMgMzkyLDIzNkM0MTcsMjA5IDQzMCwxNzIgNDMwLDEyNUM0MzAsNzggNDE3LDQwIDM5MiwxM0MzNjYsLTE1IDMyOSwtMjkgMjgxLC0yOUMyMzMsLTI5IDE5NiwtMTUgMTcxLDEyQzE0NiwzOSAxMzMsNzcgMTMzLDEyNU0xMzMsOTc5QzEzMywxMDgwIDE4MiwxMTMwIDI4MSwxMTMwQzMzMSwxMTMwIDM2OCwxMTE3IDM5MywxMDkwQzQxOCwxMDYzIDQzMCwxMDI2IDQzMCw5NzlDNDMwLDkzMiA0MTcsODk0IDM5Miw4NjdDMzY2LDgzOSAzMjksODI1IDI4MSw4MjVDMjMzLDgyNSAxOTYsODM5IDE3MSw4NjZDMTQ2LDg5MyAxMzMsOTMxIDEzMyw5Nzl6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiO1xcXCIgaG9yaXotYWR2LXg9XFxcIjU2OVxcXCIgZD1cXFwiTTM5NywyMzhsMTUsLTIzQzM4MCw5MSAzMjEsLTY5IDIzNiwtMjY0bC0xNzMsMEMxMDksLTg0IDE0Myw4MyAxNjYsMjM4TTEzMSw5NzlDMTMxLDEwODAgMTgwLDExMzAgMjc5LDExMzBDMzI5LDExMzAgMzY2LDExMTcgMzkxLDEwOTBDNDE2LDEwNjMgNDI4LDEwMjYgNDI4LDk3OUM0MjgsOTMyIDQxNSw4OTQgMzkwLDg2N0MzNjQsODM5IDMyNyw4MjUgMjc5LDgyNUMyMzEsODI1IDE5NCw4MzkgMTY5LDg2NkMxNDQsODkzIDEzMSw5MzEgMTMxLDk3OXpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCImbHQ7XFxcIiBob3Jpei1hZHYteD1cXFwiMTE2OVxcXCIgZD1cXFwiTTEwNzMsMjIxbC05NzcsNDMwbDAsMTIxbDk3Nyw0ODhsMCwtMTk1bC03MzMsLTM0NGw3MzMsLTMwM3pcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCI9XFxcIiBob3Jpei1hZHYteD1cXFwiMTE2OVxcXCIgZD1cXFwiTTEwMiw4MzFsMCwxNzlsOTYzLDBsMCwtMTc5TTEwMiw0MzJsMCwxNzhsOTYzLDBsMCwtMTc4elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIiZndDtcXFwiIGhvcml6LWFkdi14PVxcXCIxMTY5XFxcIiBkPVxcXCJNOTYsNDE4bDczMywzMDNsLTczMywzNDRsMCwxOTVsOTc3LC00ODhsMCwtMTIxbC05NzcsLTQzMHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCI/XFxcIiBob3Jpei1hZHYteD1cXFwiOTI4XFxcIiBkPVxcXCJNMjgzLDQ0NGwwLDY0QzI4Myw1ODEgMjk2LDY0MiAzMjMsNjkxQzM1MCw3NDAgMzk2LDc5MCA0NjMsODQyQzU0Miw5MDUgNTk0LDk1MyA2MTcsOTg4QzY0MCwxMDIzIDY1MSwxMDY0IDY1MSwxMTEyQzY1MSwxMTY4IDYzMiwxMjExIDU5NSwxMjQxQzU1OCwxMjcxIDUwNCwxMjg2IDQzNCwxMjg2QzM3MSwxMjg2IDMxMiwxMjc3IDI1OCwxMjU5QzIwNCwxMjQxIDE1MSwxMjE5IDEwMCwxMTk0bC04NCwxNzZDMTUxLDE0NDUgMjk2LDE0ODMgNDUxLDE0ODNDNTgyLDE0ODMgNjg1LDE0NTEgNzYyLDEzODdDODM5LDEzMjMgODc3LDEyMzUgODc3LDExMjJDODc3LDEwNzIgODcwLDEwMjggODU1LDk4OUM4NDAsOTUwIDgxOCw5MTIgNzg5LDg3N0M3NTksODQyIDcwOCw3OTYgNjM1LDczOUM1NzMsNjkwIDUzMiw2NTAgNTExLDYxOEM0OTAsNTg2IDQ3OSw1NDMgNDc5LDQ4OWwwLC00NU0yNDIsMTI1QzI0MiwyMjYgMjkxLDI3NiAzODksMjc2QzQzNywyNzYgNDc0LDI2MyA0OTksMjM3QzUyNCwyMTAgNTM3LDE3MyA1MzcsMTI1QzUzNyw3OCA1MjQsNDAgNDk5LDEzQzQ3MywtMTUgNDM2LC0yOSAzODksLTI5QzM0MiwtMjkgMzA1LC0xNSAyODAsMTJDMjU1LDM5IDI0Miw3NiAyNDIsMTI1elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIkBcXFwiIGhvcml6LWFkdi14PVxcXCIxODM5XFxcIiBkPVxcXCJNMTcyNiw3MzlDMTcyNiw2NDQgMTcxMSw1NTcgMTY4MSw0NzhDMTY1MSwzOTkgMTYwOSwzMzcgMTU1NSwyOTNDMTUwMCwyNDkgMTQzNywyMjcgMTM2NiwyMjdDMTMxMywyMjcgMTI2OCwyNDEgMTIyOSwyNjlDMTE5MCwyOTcgMTE2NCwzMzUgMTE1MSwzODNsLTEyLDBDMTEwNiwzMzEgMTA2NiwyOTIgMTAxOCwyNjZDOTcwLDI0MCA5MTYsMjI3IDg1NiwyMjdDNzQ3LDIyNyA2NjIsMjYyIDYwMCwzMzJDNTM3LDQwMiA1MDYsNDk3IDUwNiw2MTZDNTA2LDc1MyA1NDcsODY1IDYzMCw5NTFDNzEzLDEwMzYgODI0LDEwNzkgOTYzLDEwNzlDMTAxNCwxMDc5IDEwNzAsMTA3NSAxMTMyLDEwNjZDMTE5MywxMDU3IDEyNDgsMTA0NCAxMjk2LDEwMjhsLTIyLC00NjVsMCwtMjRDMTI3NCw0MzIgMTMwOSwzNzkgMTM3OCwzNzlDMTQzMSwzNzkgMTQ3Myw0MTMgMTUwNCw0ODFDMTUzNSw1NDkgMTU1MCw2MzYgMTU1MCw3NDFDMTU1MCw4NTUgMTUyNyw5NTUgMTQ4MCwxMDQyQzE0MzMsMTEyOCAxMzY3LDExOTQgMTI4MSwxMjQxQzExOTUsMTI4OCAxMDk2LDEzMTEgOTg1LDEzMTFDODQzLDEzMTEgNzIwLDEyODIgNjE1LDEyMjNDNTEwLDExNjQgNDI5LDEwODEgMzc0LDk3MkMzMTksODYzIDI5MSw3MzYgMjkxLDU5MkMyOTEsMzk5IDM0MywyNTAgNDQ2LDE0NkM1NDksNDIgNjk4LC0xMCA4OTEsLTEwQzEwMzgsLTEwIDExOTIsMjAgMTM1Miw4MGwwLC0xNjRDMTIxMiwtMTQxIDEwNjAsLTE3MCA4OTUsLTE3MEM2NDgsLTE3MCA0NTYsLTEwMyAzMTgsMzBDMTgwLDE2MyAxMTEsMzQ4IDExMSw1ODZDMTExLDc2MCAxNDgsOTE1IDIyMywxMDUxQzI5OCwxMTg2IDQwMSwxMjkwIDUzNCwxMzYyQzY2NiwxNDM0IDgxNiwxNDcwIDk4MywxNDcwQzExMjgsMTQ3MCAxMjU3LDE0NDAgMTM3MCwxMzgwQzE0ODMsMTMyMCAxNTcwLDEyMzUgMTYzMywxMTI0QzE2OTUsMTAxMyAxNzI2LDg4NCAxNzI2LDczOU02OTgsNjEyQzY5OCw0NTcgNzU5LDM3OSA4ODEsMzc5QzEwMTAsMzc5IDEwODAsNDc3IDEwOTIsNjcybDEyLDIzOUMxMDYyLDkyMiAxMDE3LDkyOCA5NjksOTI4Qzg4NCw5MjggODE3LDkwMCA3NzAsODQzQzcyMiw3ODYgNjk4LDcwOSA2OTgsNjEyelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIkFcXFwiIGhvcml6LWFkdi14PVxcXCIxMzU0XFxcIiBkPVxcXCJNMTEwMCwwbC0xNDYsNDA2bC01NTksMGwtMTQzLC00MDZsLTI1MiwwbDU0NywxNDY4bDI2MCwwbDU0NywtMTQ2OE04OTEsNjEybC0xMzcsMzk4Qzc0NCwxMDM3IDczMCwxMDc5IDcxMywxMTM2QzY5NSwxMTkzIDY4MywxMjM1IDY3NiwxMjYyQzY1OCwxMTgwIDYzMiwxMDkwIDU5Nyw5OTNsLTEzMiwtMzgxelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIkJcXFwiIGhvcml6LWFkdi14PVxcXCIxMzUyXFxcIiBkPVxcXCJNMTkzLDE0NjJsNDM0LDBDODI4LDE0NjIgOTc0LDE0MzMgMTA2NCwxMzc0QzExNTMsMTMxNSAxMTk4LDEyMjMgMTE5OCwxMDk2QzExOTgsMTAxMSAxMTc2LDk0MCAxMTMyLDg4M0MxMDg4LDgyNiAxMDI1LDc5MSA5NDIsNzc2bDAsLTEwQzEwNDUsNzQ3IDExMjAsNzA5IDExNjksNjUyQzEyMTcsNTk1IDEyNDEsNTE3IDEyNDEsNDIwQzEyNDEsMjg5IDExOTUsMTg2IDExMDQsMTEyQzEwMTIsMzcgODg0LDAgNzIxLDBsLTUyOCwwTTQzMiw4NThsMjMwLDBDNzYyLDg1OCA4MzUsODc0IDg4MSw5MDZDOTI3LDkzNyA5NTAsOTkxIDk1MCwxMDY3Qzk1MCwxMTM2IDkyNSwxMTg1IDg3NiwxMjE2QzgyNiwxMjQ3IDc0NywxMjYyIDYzOSwxMjYybC0yMDcsME00MzIsNjY0bDAsLTQ2M2wyNTQsMEM3ODYsMjAxIDg2MiwyMjAgOTEzLDI1OUM5NjQsMjk3IDk4OSwzNTcgOTg5LDQ0MEM5ODksNTE2IDk2Myw1NzIgOTExLDYwOUM4NTksNjQ2IDc4MCw2NjQgNjc0LDY2NHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJDXFxcIiBob3Jpei1hZHYteD1cXFwiMTI5OFxcXCIgZD1cXFwiTTgxNSwxMjc4QzY3OCwxMjc4IDU3MCwxMjI5IDQ5MSwxMTMyQzQxMiwxMDM1IDM3Myw5MDAgMzczLDcyOUMzNzMsNTUwIDQxMSw0MTQgNDg3LDMyMkM1NjIsMjMwIDY3MiwxODQgODE1LDE4NEM4NzcsMTg0IDkzNywxOTAgOTk1LDIwM0MxMDUzLDIxNSAxMTEzLDIzMSAxMTc2LDI1MGwwLC0yMDVDMTA2MSwyIDkzMSwtMjAgNzg2LC0yMEM1NzIsLTIwIDQwOCw0NSAyOTMsMTc1QzE3OCwzMDQgMTIxLDQ5MCAxMjEsNzMxQzEyMSw4ODMgMTQ5LDEwMTYgMjA1LDExMzBDMjYwLDEyNDQgMzQxLDEzMzEgNDQ2LDEzOTJDNTUxLDE0NTMgNjc1LDE0ODMgODE3LDE0ODNDOTY2LDE0ODMgMTEwNCwxNDUyIDEyMzEsMTM4OWwtODYsLTE5OUMxMDk2LDEyMTMgMTA0NCwxMjM0IDk4OSwxMjUyQzkzNCwxMjY5IDg3NiwxMjc4IDgxNSwxMjc4elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIkRcXFwiIGhvcml6LWFkdi14PVxcXCIxNTAzXFxcIiBkPVxcXCJNMTM4Miw3NDVDMTM4Miw1MDQgMTMxNSwzMTkgMTE4MSwxOTJDMTA0Nyw2NCA4NTQsMCA2MDIsMGwtNDA5LDBsMCwxNDYybDQ1MiwwQzg3OCwxNDYyIDEwNTksMTM5OSAxMTg4LDEyNzRDMTMxNywxMTQ5IDEzODIsOTcyIDEzODIsNzQ1TTExMzAsNzM3QzExMzAsMTA4NyA5NjYsMTI2MiA2MzksMTI2MmwtMjA3LDBsMCwtMTA2MWwxNzAsMEM5NTQsMjAxIDExMzAsMzgwIDExMzAsNzM3elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIkVcXFwiIGhvcml6LWFkdi14PVxcXCIxMTQzXFxcIiBkPVxcXCJNMTAyMCwwbC04MjcsMGwwLDE0NjJsODI3LDBsMCwtMjAybC01ODgsMGwwLC0zOThsNTUxLDBsMCwtMjAwbC01NTEsMGwwLC00NTlsNTg4LDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiRlxcXCIgaG9yaXotYWR2LXg9XFxcIjEwOTBcXFwiIGQ9XFxcIk00MzAsMGwtMjM3LDBsMCwxNDYybDgyNSwwbDAsLTIwMmwtNTg4LDBsMCwtNDU3bDU1MSwwbDAsLTIwM2wtNTUxLDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiR1xcXCIgaG9yaXotYWR2LXg9XFxcIjE0ODdcXFwiIGQ9XFxcIk03OTEsNzkzbDUzOCwwbDAsLTczNEMxMjQxLDMwIDExNTcsMTAgMTA3NiwtMkM5OTUsLTE0IDkwNywtMjAgODEzLC0yMEM1OTIsLTIwIDQyMSw0NiAzMDEsMTc3QzE4MSwzMDggMTIxLDQ5MiAxMjEsNzMxQzEyMSw5NjYgMTg5LDExNTEgMzI0LDEyODRDNDU5LDE0MTcgNjQ2LDE0ODMgODgzLDE0ODNDMTAzNiwxNDgzIDExODAsMTQ1NCAxMzE3LDEzOTVsLTg0LC0xOTlDMTExNCwxMjUxIDk5NiwxMjc4IDg3NywxMjc4QzcyMSwxMjc4IDU5OCwxMjI5IDUwNywxMTMxQzQxNiwxMDMzIDM3MSw4OTkgMzcxLDcyOUMzNzEsNTUwIDQxMiw0MTUgNDk0LDMyMkM1NzUsMjI5IDY5MywxODIgODQ2LDE4MkM5MjMsMTgyIDEwMDYsMTkyIDEwOTQsMjExbDAsMzc3bC0zMDMsMHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJIXFxcIiBob3Jpei1hZHYteD1cXFwiMTUzOFxcXCIgZD1cXFwiTTEzNDYsMGwtMjQwLDBsMCw2NTlsLTY3NCwwbDAsLTY1OWwtMjM5LDBsMCwxNDYybDIzOSwwbDAsLTU5OGw2NzQsMGwwLDU5OGwyNDAsMHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJKXFxcIiBob3Jpei1hZHYteD1cXFwiNjEyXFxcIiBkPVxcXCJNOCwtNDA4Qy01NywtNDA4IC0xMTIsLTQwMCAtMTU2LC0zODNsMCwyMDFDLTEwMCwtMTk2IC01MSwtMjAzIC0xMCwtMjAzQzEyMSwtMjAzIDE4NiwtMTIwIDE4Niw0NWwwLDE0MTdsMjQwLDBsMCwtMTQwOUM0MjYsLTk2IDM5MSwtMjEwIDMyMCwtMjg5QzI0OSwtMzY4IDE0NSwtNDA4IDgsLTQwOHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJLXFxcIiBob3Jpei1hZHYteD1cXFwiMTMwOVxcXCIgZD1cXFwiTTEzMDksMGwtMjc3LDBsLTQ1OSw2NjJsLTE0MSwtMTE1bDAsLTU0N2wtMjM5LDBsMCwxNDYybDIzOSwwbDAsLTY5OEM0OTcsODQ0IDU2Miw5MjEgNjI3LDk5NWwzOTUsNDY3bDI3MiwwQzEwMzksMTE2MiA4NTYsOTQ4IDc0NSw4MjF6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiTFxcXCIgaG9yaXotYWR2LXg9XFxcIjExMTBcXFwiIGQ9XFxcIk0xOTMsMGwwLDE0NjJsMjM5LDBsMCwtMTI1N2w2MTksMGwwLC0yMDV6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiTVxcXCIgaG9yaXotYWR2LXg9XFxcIjE4OTBcXFwiIGQ9XFxcIk04MjUsMGwtNDI0LDEyMjFsLTgsMEM0MDQsMTA0MCA0MTAsODcwIDQxMCw3MTFsMCwtNzExbC0yMTcsMGwwLDE0NjJsMzM3LDBsNDA2LC0xMTYzbDYsMGw0MTgsMTE2M2wzMzgsMGwwLC0xNDYybC0yMzAsMGwwLDcyM0MxNDY4LDc5NiAxNDcwLDg5MCAxNDc0LDEwMDdDMTQ3NywxMTI0IDE0ODAsMTE5NCAxNDgzLDEyMTlsLTgsMGwtNDM5LC0xMjE5elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIk5cXFwiIGhvcml6LWFkdi14PVxcXCIxNjA0XFxcIiBkPVxcXCJNMTQxMSwwbC0yOTMsMGwtNzE5LDExNjVsLTgsMGw1LC02NUM0MDUsOTc2IDQxMCw4NjMgNDEwLDc2MGwwLC03NjBsLTIxNywwbDAsMTQ2MmwyOTAsMGw3MTcsLTExNTlsNiwwQzEyMDUsMzE4IDEyMDIsMzc0IDExOTgsNDcxQzExOTQsNTY3IDExOTIsNjQyIDExOTIsNjk2bDAsNzY2bDIxOSwwelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIk9cXFwiIGhvcml6LWFkdi14PVxcXCIxNjEyXFxcIiBkPVxcXCJNMTQ5MSw3MzNDMTQ5MSw0OTUgMTQzMiwzMTAgMTMxMywxNzhDMTE5NCw0NiAxMDI1LC0yMCA4MDcsLTIwQzU4NiwtMjAgNDE3LDQ2IDI5OSwxNzdDMTgwLDMwOCAxMjEsNDk0IDEyMSw3MzVDMTIxLDk3NiAxODEsMTE2MiAzMDAsMTI5MUM0MTksMTQyMCA1ODgsMTQ4NSA4MDksMTQ4NUMxMDI2LDE0ODUgMTE5NCwxNDE5IDEzMTMsMTI4OEMxNDMyLDExNTcgMTQ5MSw5NzIgMTQ5MSw3MzNNMzc1LDczM0MzNzUsNTUzIDQxMSw0MTcgNDg0LDMyNEM1NTcsMjMxIDY2NCwxODQgODA3LDE4NEM5NDksMTg0IDEwNTYsMjMwIDExMjksMzIyQzEyMDEsNDE0IDEyMzcsNTUxIDEyMzcsNzMzQzEyMzcsOTEyIDEyMDEsMTA0OCAxMTMwLDExNDFDMTA1OCwxMjM0IDk1MSwxMjgwIDgwOSwxMjgwQzY2NiwxMjgwIDU1OCwxMjM0IDQ4NSwxMTQxQzQxMiwxMDQ4IDM3NSw5MTIgMzc1LDczM3pcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJQXFxcIiBob3Jpei1hZHYteD1cXFwiMTI2MFxcXCIgZD1cXFwiTTExNjEsMTAyMEMxMTYxLDg2NyAxMTExLDc1MCAxMDExLDY2OUM5MTEsNTg4IDc2OSw1NDcgNTg0LDU0N2wtMTUyLDBsMCwtNTQ3bC0yMzksMGwwLDE0NjJsNDIxLDBDNzk3LDE0NjIgOTM0LDE0MjUgMTAyNSwxMzUwQzExMTYsMTI3NSAxMTYxLDExNjUgMTE2MSwxMDIwTTQzMiw3NDhsMTI3LDBDNjgyLDc0OCA3NzIsNzY5IDgyOSw4MTJDODg2LDg1NSA5MTUsOTIxIDkxNSwxMDEyQzkxNSwxMDk2IDg4OSwxMTU5IDgzOCwxMjAwQzc4NywxMjQxIDcwNywxMjYyIDU5OCwxMjYybC0xNjYsMHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJRXFxcIiBob3Jpei1hZHYteD1cXFwiMTYxMlxcXCIgZD1cXFwiTTE0OTEsNzMzQzE0OTEsNTU2IDE0NTcsNDA2IDEzOTAsMjg1QzEzMjIsMTY0IDEyMjMsNzggMTA5NCwyOWwzNTAsLTM3N2wtMzIyLDBsLTI3NiwzMjhsLTM5LDBDNTg2LC0yMCA0MTcsNDYgMjk5LDE3N0MxODAsMzA4IDEyMSw0OTQgMTIxLDczNUMxMjEsOTc2IDE4MSwxMTYyIDMwMCwxMjkxQzQxOSwxNDIwIDU4OCwxNDg1IDgwOSwxNDg1QzEwMjYsMTQ4NSAxMTk0LDE0MTkgMTMxMywxMjg4QzE0MzIsMTE1NyAxNDkxLDk3MiAxNDkxLDczM00zNzUsNzMzQzM3NSw1NTMgNDExLDQxNyA0ODQsMzI0QzU1NywyMzEgNjY0LDE4NCA4MDcsMTg0Qzk0OSwxODQgMTA1NiwyMzAgMTEyOSwzMjJDMTIwMSw0MTQgMTIzNyw1NTEgMTIzNyw3MzNDMTIzNyw5MTIgMTIwMSwxMDQ4IDExMzAsMTE0MUMxMDU4LDEyMzQgOTUxLDEyODAgODA5LDEyODBDNjY2LDEyODAgNTU4LDEyMzQgNDg1LDExNDFDNDEyLDEwNDggMzc1LDkxMiAzNzUsNzMzelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIlJcXFwiIGhvcml6LWFkdi14PVxcXCIxMzA5XFxcIiBkPVxcXCJNNDMyLDc4MmwxNjYsMEM3MDksNzgyIDc5MCw4MDMgODQwLDg0NEM4OTAsODg1IDkxNSw5NDcgOTE1LDEwMjhDOTE1LDExMTEgODg4LDExNzAgODM0LDEyMDZDNzgwLDEyNDIgNjk5LDEyNjAgNTkwLDEyNjBsLTE1OCwwTTQzMiw1ODRsMCwtNTg0bC0yMzksMGwwLDE0NjJsNDEzLDBDNzk1LDE0NjIgOTM0LDE0MjcgMTAyNSwxMzU2QzExMTYsMTI4NSAxMTYxLDExNzkgMTE2MSwxMDM2QzExNjEsODU0IDEwNjYsNzI0IDg3Nyw2NDdsNDEzLC02NDdsLTI3MiwwbC0zNTAsNTg0elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIlNcXFwiIGhvcml6LWFkdi14PVxcXCIxMTI2XFxcIiBkPVxcXCJNMTAzNiwzOTdDMTAzNiwyNjcgOTg5LDE2NSA4OTUsOTFDODAxLDE3IDY3MSwtMjAgNTA2LC0yMEMzNDEsLTIwIDIwNSw2IDEwMCw1N2wwLDIyNkMxNjcsMjUyIDIzOCwyMjcgMzEzLDIwOUMzODgsMTkxIDQ1NywxODIgNTIyLDE4MkM2MTcsMTgyIDY4NywyMDAgNzMyLDIzNkM3NzcsMjcyIDc5OSwzMjAgNzk5LDM4MUM3OTksNDM2IDc3OCw0ODIgNzM3LDUyMEM2OTYsNTU4IDYxMCw2MDMgNDgxLDY1NUMzNDgsNzA5IDI1NCw3NzEgMTk5LDg0MEMxNDQsOTA5IDExNyw5OTMgMTE3LDEwOTBDMTE3LDEyMTIgMTYwLDEzMDggMjQ3LDEzNzhDMzM0LDE0NDggNDUwLDE0ODMgNTk2LDE0ODNDNzM2LDE0ODMgODc1LDE0NTIgMTAxNCwxMzkxbC03NiwtMTk1QzgwOCwxMjUxIDY5MiwxMjc4IDU5MCwxMjc4QzUxMywxMjc4IDQ1NCwxMjYxIDQxNCwxMjI4QzM3NCwxMTk0IDM1NCwxMTQ5IDM1NCwxMDk0QzM1NCwxMDU2IDM2MiwxMDI0IDM3OCw5OTdDMzk0LDk3MCA0MjAsOTQ0IDQ1Nyw5MjBDNDk0LDg5NiA1NjAsODY0IDY1NSw4MjVDNzYyLDc4MCA4NDEsNzM5IDg5MSw3MDBDOTQxLDY2MSA5NzgsNjE4IDEwMDEsNTY5QzEwMjQsNTIwIDEwMzYsNDYzIDEwMzYsMzk3elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIlRcXFwiIGhvcml6LWFkdi14PVxcXCIxMTU5XFxcIiBkPVxcXCJNNjk4LDBsLTIzOSwwbDAsMTI1N2wtNDMwLDBsMCwyMDVsMTA5OSwwbDAsLTIwNWwtNDMwLDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiVVxcXCIgaG9yaXotYWR2LXg9XFxcIjE1MjBcXFwiIGQ9XFxcIk0xMzM5LDE0NjJsMCwtOTQ2QzEzMzksNDA4IDEzMTYsMzE0IDEyNzAsMjMzQzEyMjMsMTUyIDExNTYsODkgMTA2OSw0NkM5ODEsMiA4NzYsLTIwIDc1NCwtMjBDNTczLC0yMCA0MzIsMjggMzMxLDEyNEMyMzAsMjIwIDE4MCwzNTIgMTgwLDUyMGwwLDk0MmwyNDAsMGwwLC05MjVDNDIwLDQxNiA0NDgsMzI3IDUwNCwyNzBDNTYwLDIxMyA2NDYsMTg0IDc2MiwxODRDOTg3LDE4NCAxMTAwLDMwMiAxMTAwLDUzOWwwLDkyM3pcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJWXFxcIiBob3Jpei1hZHYteD1cXFwiMTI3NFxcXCIgZD1cXFwiTTEwMjYsMTQ2MmwyNDgsMGwtNTEyLC0xNDYybC0yNTIsMGwtNTEwLDE0NjJsMjQ2LDBsMzA1LC05MDlDNTY3LDUxMCA1ODQsNDU0IDYwMiwzODZDNjIwLDMxNyA2MzIsMjY2IDYzNywyMzNDNjQ2LDI4NCA2NTksMzQyIDY3Nyw0MDlDNjk1LDQ3NiA3MTAsNTI1IDcyMSw1NTd6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiV1xcXCIgaG9yaXotYWR2LXg9XFxcIjE5MzdcXFwiIGQ9XFxcIk0xNTQyLDBsLTI2MCwwbC0yNDgsODcyQzEwMjMsOTEwIDEwMTAsOTY1IDk5NCwxMDM3Qzk3OCwxMTA4IDk2OCwxMTU4IDk2NSwxMTg2Qzk1OCwxMTQzIDk0OCwxMDg4IDkzMywxMDIwQzkxOCw5NTIgOTA1LDkwMSA4OTUsODY4bC0yNDIsLTg2OGwtMjYwLDBsLTE4OSw3MzJsLTE5Miw3MzBsMjQ0LDBsMjA5LC04NTJDNDk4LDQ3MyA1MjEsMzUzIDUzNSwyNDhDNTQyLDMwNSA1NTMsMzY4IDU2OCw0MzhDNTgzLDUwOCA1OTYsNTY1IDYwOCw2MDhsMjM4LDg1NGwyMzcsMGwyNDQsLTg1OEMxMzUwLDUyNSAxMzc1LDQwNiAxNDAxLDI0OEMxNDExLDM0MyAxNDM1LDQ2NSAxNDczLDYxMmwyMDgsODUwbDI0MiwwelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIlhcXFwiIGhvcml6LWFkdi14PVxcXCIxMjc0XFxcIiBkPVxcXCJNMTI3MCwwbC0yNzUsMGwtMzY2LDU5OGwtMzY5LC01OThsLTI1NiwwbDQ4NSw3NThsLTQ1NCw3MDRsMjY2LDBsMzM4LC01NTNsMzM4LDU1M2wyNTgsMGwtNDU3LC03MDh6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiWVxcXCIgaG9yaXotYWR2LXg9XFxcIjEyMTJcXFwiIGQ9XFxcIk02MDYsNzk1bDM0Niw2NjdsMjYwLDBsLTQ4NywtODk1bDAsLTU2N2wtMjQwLDBsMCw1NTlsLTQ4NSw5MDNsMjYwLDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiWlxcXCIgaG9yaXotYWR2LXg9XFxcIjExNzhcXFwiIGQ9XFxcIk0xMTEyLDBsLTEwNDYsMGwwLDE2Nmw3MzcsMTA5MWwtNzE3LDBsMCwyMDVsMTAwNiwwbDAsLTE2OGwtNzQwLC0xMDg5bDc2MCwwelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIlxcXFxcXFwiIGhvcml6LWFkdi14PVxcXCI3OTlcXFwiIGQ9XFxcIk0yMzgsMTQ2Mmw1NDQsLTE0NjJsLTIyMSwwbC01NDUsMTQ2MnpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJeXFxcIiBob3Jpei1hZHYteD1cXFwiMTEwMFxcXCIgZD1cXFwiTTI5LDUzNWw0MzYsOTM1bDEyMSwwbDQ4NSwtOTM1bC0xOTQsMGwtMzQ5LDY5NGwtMzA3LC02OTR6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiX1xcXCIgaG9yaXotYWR2LXg9XFxcIjg3OVxcXCIgZD1cXFwiTTg4MywtMzE5bC04ODcsMGwwLDEzNWw4ODcsMHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJhXFxcIiBob3Jpei1hZHYteD1cXFwiMTE4OFxcXCIgZD1cXFwiTTg2MCwwbC00NywxNTRsLTgsMEM3NTIsODcgNjk4LDQxIDY0NCwxN0M1OTAsLTggNTIxLC0yMCA0MzYsLTIwQzMyNywtMjAgMjQzLDkgMTgyLDY4QzEyMSwxMjcgOTAsMjEwIDkwLDMxN0M5MCw0MzEgMTMyLDUxNyAyMTcsNTc1QzMwMiw2MzMgNDMxLDY2NSA2MDQsNjcwbDE5MSw2bDAsNTlDNzk1LDgwNiA3NzksODU5IDc0Niw4OTRDNzEzLDkyOSA2NjEsOTQ2IDU5Miw5NDZDNTM1LDk0NiA0ODEsOTM4IDQyOSw5MjFDMzc3LDkwNCAzMjcsODg1IDI3OSw4NjJsLTc2LDE2OEMyNjMsMTA2MSAzMjksMTA4NSA0MDAsMTEwMkM0NzEsMTExOCA1MzksMTEyNiA2MDIsMTEyNkM3NDMsMTEyNiA4NDksMTA5NSA5MjEsMTAzNEM5OTIsOTczIDEwMjgsODc2IDEwMjgsNzQ1bDAsLTc0NU01MTAsMTYwQzU5NSwxNjAgNjY0LDE4NCA3MTYsMjMyQzc2NywyNzkgNzkzLDM0NiA3OTMsNDMybDAsOTZsLTE0MiwtNkM1NDAsNTE4IDQ2MCw1MDAgNDEwLDQ2N0MzNTksNDM0IDMzNCwzODMgMzM0LDMxNUMzMzQsMjY2IDM0OSwyMjggMzc4LDIwMUM0MDcsMTc0IDQ1MSwxNjAgNTEwLDE2MHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJiXFxcIiBob3Jpei1hZHYteD1cXFwiMTI3NlxcXCIgZD1cXFwiTTczMywxMTI2Qzg3MSwxMTI2IDk3OSwxMDc2IDEwNTYsOTc2QzExMzMsODc2IDExNzEsNzM2IDExNzEsNTU1QzExNzEsMzc0IDExMzIsMjMzIDEwNTQsMTMyQzk3NiwzMSA4NjgsLTIwIDcyOSwtMjBDNTg5LC0yMCA0ODAsMzAgNDAzLDEzMWwtMTYsMGwtNDMsLTEzMWwtMTc2LDBsMCwxNTU2bDIzNSwwbDAsLTM3MEM0MDMsMTE1OSA0MDIsMTExOCAzOTksMTA2NEMzOTYsMTAxMCAzOTQsOTc2IDM5Myw5NjFsMTAsMEM0NzgsMTA3MSA1ODgsMTEyNiA3MzMsMTEyNk02NzIsOTM0QzU3Nyw5MzQgNTA5LDkwNiA0NjgsODUxQzQyNiw3OTUgNDA0LDcwMiA0MDMsNTcxbDAsLTE2QzQwMyw0MjAgNDI0LDMyMyA0NjcsMjYzQzUxMCwyMDIgNTc5LDE3MiA2NzYsMTcyQzc1OSwxNzIgODIzLDIwNSA4NjYsMjcxQzkwOSwzMzcgOTMwLDQzMiA5MzAsNTU3QzkzMCw4MDggODQ0LDkzNCA2NzIsOTM0elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcImNcXFwiIGhvcml6LWFkdi14PVxcXCIxMDE0XFxcIiBkPVxcXCJNNjE0LC0yMEM0NDcsLTIwIDMyMCwyOSAyMzMsMTI3QzE0NiwyMjQgMTAyLDM2NCAxMDIsNTQ3QzEwMiw3MzMgMTQ4LDg3NiAyMzksOTc2QzMzMCwxMDc2IDQ2MSwxMTI2IDYzMywxMTI2Qzc1MCwxMTI2IDg1NSwxMTA0IDk0OCwxMDYxbC03MSwtMTg5Qzc3OCw5MTEgNjk2LDkzMCA2MzEsOTMwQzQ0MCw5MzAgMzQ0LDgwMyAzNDQsNTQ5QzM0NCw0MjUgMzY4LDMzMiA0MTYsMjcwQzQ2MywyMDcgNTMzLDE3NiA2MjUsMTc2QzczMCwxNzYgODI5LDIwMiA5MjIsMjU0bDAsLTIwNUM4ODAsMjQgODM1LDcgNzg4LC00Qzc0MCwtMTUgNjgyLC0yMCA2MTQsLTIwelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcImRcXFwiIGhvcml6LWFkdi14PVxcXCIxMjc2XFxcIiBkPVxcXCJNNTQxLC0yMEM0MDMsLTIwIDI5NSwzMCAyMTgsMTMwQzE0MSwyMzAgMTAyLDM3MCAxMDIsNTUxQzEwMiw3MzIgMTQxLDg3NCAyMjAsOTc1QzI5OCwxMDc2IDQwNiwxMTI2IDU0NSwxMTI2QzY5MCwxMTI2IDgwMSwxMDcyIDg3Nyw5NjVsMTIsMEM4NzgsMTA0NCA4NzIsMTEwNyA4NzIsMTE1M2wwLDQwM2wyMzYsMGwwLC0xNTU2bC0xODQsMGwtNDEsMTQ1bC0xMSwwQzc5NywzNSA2ODYsLTIwIDU0MSwtMjBNNjA0LDE3MEM3MDEsMTcwIDc3MSwxOTcgODE1LDI1MkM4NTksMzA2IDg4MiwzOTQgODgzLDUxNmwwLDMzQzg4Myw2ODggODYwLDc4NyA4MTUsODQ2Qzc3MCw5MDUgNjk5LDkzNCA2MDIsOTM0QzUxOSw5MzQgNDU2LDkwMSA0MTEsODM0QzM2Niw3NjcgMzQ0LDY3MSAzNDQsNTQ3QzM0NCw0MjQgMzY2LDMzMSA0MDksMjY3QzQ1MiwyMDIgNTE3LDE3MCA2MDQsMTcwelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcImVcXFwiIGhvcml6LWFkdi14PVxcXCIxMTgwXFxcIiBkPVxcXCJNNjUxLC0yMEM0NzksLTIwIDM0NSwzMCAyNDgsMTMxQzE1MSwyMzEgMTAyLDM2OSAxMDIsNTQ1QzEwMiw3MjYgMTQ3LDg2OCAyMzcsOTcxQzMyNywxMDc0IDQ1MSwxMTI2IDYwOCwxMTI2Qzc1NCwxMTI2IDg2OSwxMDgyIDk1NCw5OTNDMTAzOSw5MDQgMTA4MSw3ODIgMTA4MSw2MjdsMCwtMTI3bC03MzcsMEMzNDcsMzkzIDM3NiwzMTAgNDMxLDI1M0M0ODYsMTk1IDU2MywxNjYgNjYyLDE2NkM3MjcsMTY2IDc4OCwxNzIgODQ1LDE4NUM5MDEsMTk3IDk2MSwyMTcgMTAyNiwyNDZsMCwtMTkxQzk2OSwyOCA5MTEsOCA4NTIsLTNDNzkzLC0xNCA3MjYsLTIwIDY1MSwtMjBNNjA4LDk0OEM1MzMsOTQ4IDQ3NCw5MjQgNDI5LDg3N0MzODQsODMwIDM1Nyw3NjEgMzQ4LDY3MGw1MDIsMEM4NDksNzYxIDgyNyw4MzEgNzg0LDg3OEM3NDEsOTI1IDY4Myw5NDggNjA4LDk0OHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJmXFxcIiBob3Jpei1hZHYteD1cXFwiNzQzXFxcIiBkPVxcXCJNNzIzLDkyOGwtMjcwLDBsMCwtOTI4bC0yMzYsMGwwLDkyOGwtMTgyLDBsMCwxMTBsMTgyLDcybDAsNzJDMjE3LDEzMTMgMjQ4LDE0MTAgMzA5LDE0NzNDMzcwLDE1MzYgNDY0LDE1NjcgNTkwLDE1NjdDNjczLDE1NjcgNzU0LDE1NTMgODM0LDE1MjZsLTYyLC0xNzhDNzE0LDEzNjcgNjU5LDEzNzYgNjA2LDEzNzZDNTUzLDEzNzYgNTE0LDEzNjAgNDkwLDEzMjdDNDY1LDEyOTQgNDUzLDEyNDQgNDUzLDExNzhsMCwtNzJsMjcwLDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiZ1xcXCIgaG9yaXotYWR2LXg9XFxcIjExMzlcXFwiIGQ9XFxcIk0xMTAyLDExMDZsMCwtMTI5bC0xODksLTM1QzkzMCw5MTkgOTQ1LDg5MCA5NTYsODU2Qzk2Nyw4MjIgOTczLDc4NiA5NzMsNzQ4Qzk3Myw2MzQgOTM0LDU0NCA4NTUsNDc5Qzc3Niw0MTQgNjY4LDM4MSA1MzAsMzgxQzQ5NSwzODEgNDYzLDM4NCA0MzQsMzg5QzM4MywzNTggMzU4LDMyMSAzNTgsMjc5QzM1OCwyNTQgMzcwLDIzNSAzOTQsMjIyQzQxNywyMDkgNDYxLDIwMyA1MjQsMjAzbDE5MywwQzgzOSwyMDMgOTMyLDE3NyA5OTUsMTI1QzEwNTgsNzMgMTA5MCwtMiAxMDkwLC0xMDBDMTA5MCwtMjI1IDEwMzgsLTMyMiA5MzUsLTM5MEM4MzIsLTQ1OCA2ODIsLTQ5MiA0ODcsLTQ5MkMzMzYsLTQ5MiAyMjEsLTQ2NSAxNDIsLTQxMkM2MywtMzU5IDIzLC0yODMgMjMsLTE4NEMyMywtMTE2IDQ1LC01OSA4OCwtMTJDMTMxLDM0IDE5MSw2NiAyNjgsODRDMjM3LDk3IDIxMSwxMTkgMTkxLDE0OUMxNzAsMTc4IDE2MCwyMDkgMTYwLDI0MkMxNjAsMjgzIDE3MiwzMTggMTk1LDM0N0MyMTgsMzc2IDI1Myw0MDQgMjk5LDQzMkMyNDIsNDU3IDE5NSw0OTcgMTYwLDU1M0MxMjQsNjA4IDEwNiw2NzMgMTA2LDc0OEMxMDYsODY4IDE0NCw5NjEgMjIwLDEwMjdDMjk1LDEwOTMgNDAzLDExMjYgNTQzLDExMjZDNTc0LDExMjYgNjA3LDExMjQgNjQyLDExMjBDNjc2LDExMTUgNzAyLDExMTEgNzE5LDExMDZNMjMzLC0xNzJDMjMzLC0yMjMgMjU2LC0yNjIgMzAyLC0yODlDMzQ3LC0zMTYgNDExLC0zMzAgNDk0LC0zMzBDNjIyLC0zMzAgNzE3LC0zMTIgNzgwLC0yNzVDODQzLC0yMzggODc0LC0xOTAgODc0LC0xMjlDODc0LC04MSA4NTcsLTQ3IDgyMywtMjZDNzg4LC02IDcyNCw0IDYzMSw0bC0xNzgsMEMzODYsNCAzMzIsLTEyIDI5MywtNDNDMjUzLC03NSAyMzMsLTExOCAyMzMsLTE3Mk0zMzQsNzQ4QzMzNCw2NzkgMzUyLDYyNSAzODgsNTg4QzQyMyw1NTEgNDc0LDUzMiA1NDEsNTMyQzY3Nyw1MzIgNzQ1LDYwNSA3NDUsNzUwQzc0NSw4MjIgNzI4LDg3OCA2OTUsOTE3QzY2MSw5NTYgNjEwLDk3NSA1NDEsOTc1QzQ3Myw5NzUgNDIyLDk1NiAzODcsOTE3QzM1Miw4NzggMzM0LDgyMiAzMzQsNzQ4elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcImhcXFwiIGhvcml6LWFkdi14PVxcXCIxMzAwXFxcIiBkPVxcXCJNMTE0MSwwbC0yMzYsMGwwLDY4MEM5MDUsNzY1IDg4OCw4MjkgODU0LDg3MUM4MTksOTEzIDc2NSw5MzQgNjkwLDkzNEM1OTEsOTM0IDUxOSw5MDUgNDczLDg0NkM0MjYsNzg3IDQwMyw2ODggNDAzLDU0OWwwLC01NDlsLTIzNSwwbDAsMTU1NmwyMzUsMGwwLC0zOTVDNDAzLDEwOTggMzk5LDEwMzAgMzkxLDk1OGwxNSwwQzQzOCwxMDExIDQ4MywxMDUzIDU0MCwxMDgyQzU5NywxMTExIDY2MywxMTI2IDczOSwxMTI2QzEwMDcsMTEyNiAxMTQxLDk5MSAxMTQxLDcyMXpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJpXFxcIiBob3Jpei1hZHYteD1cXFwiNTcxXFxcIiBkPVxcXCJNNDAzLDBsLTIzNSwwbDAsMTEwNmwyMzUsME0xNTQsMTM5OUMxNTQsMTQ0MSAxNjYsMTQ3MyAxODksMTQ5NkMyMTIsMTUxOSAyNDQsMTUzMCAyODcsMTUzMEMzMjgsMTUzMCAzNjEsMTUxOSAzODQsMTQ5NkM0MDcsMTQ3MyA0MTgsMTQ0MSA0MTgsMTM5OUM0MTgsMTM1OSA0MDcsMTMyOCAzODQsMTMwNUMzNjEsMTI4MiAzMjgsMTI3MCAyODcsMTI3MEMyNDQsMTI3MCAyMTIsMTI4MiAxODksMTMwNUMxNjYsMTMyOCAxNTQsMTM1OSAxNTQsMTM5OXpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJqXFxcIiBob3Jpei1hZHYteD1cXFwiNTcxXFxcIiBkPVxcXCJNNTUsLTQ5MkMtMTYsLTQ5MiAtNzQsLTQ4NCAtMTIxLC00NjdsMCwxODZDLTc2LC0yOTMgLTI5LC0yOTkgMTgsLTI5OUMxMTgsLTI5OSAxNjgsLTI0MiAxNjgsLTEyOWwwLDEyMzVsMjM1LDBsMCwtMTI1MUM0MDMsLTI1OSAzNzMsLTM0NSAzMTQsLTQwNEMyNTQsLTQ2MyAxNjgsLTQ5MiA1NSwtNDkyTTE1NCwxMzk5QzE1NCwxNDQxIDE2NiwxNDczIDE4OSwxNDk2QzIxMiwxNTE5IDI0NCwxNTMwIDI4NywxNTMwQzMyOCwxNTMwIDM2MSwxNTE5IDM4NCwxNDk2QzQwNywxNDczIDQxOCwxNDQxIDQxOCwxMzk5QzQxOCwxMzU5IDQwNywxMzI4IDM4NCwxMzA1QzM2MSwxMjgyIDMyOCwxMjcwIDI4NywxMjcwQzI0NCwxMjcwIDIxMiwxMjgyIDE4OSwxMzA1QzE2NiwxMzI4IDE1NCwxMzU5IDE1NCwxMzk5elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcImtcXFwiIGhvcml6LWFkdi14PVxcXCIxMTcxXFxcIiBkPVxcXCJNMzk1LDU4NGwxMzMsMTY2bDMzNCwzNTZsMjcxLDBsLTQ0NSwtNDc1bDQ3MywtNjMxbC0yNzYsMGwtMzU1LDQ4NWwtMTI5LC0xMDZsMCwtMzc5bC0yMzMsMGwwLDE1NTZsMjMzLDBsMCwtNzU5bC0xMiwtMjEzelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcImxcXFwiIGhvcml6LWFkdi14PVxcXCI1NzFcXFwiIGQ9XFxcIk00MDMsMGwtMjM1LDBsMCwxNTU2bDIzNSwwelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIm1cXFwiIGhvcml6LWFkdi14PVxcXCIxOTU4XFxcIiBkPVxcXCJNMTEwMCwwbC0yMzYsMGwwLDY4MkM4NjQsNzY3IDg0OCw4MzAgODE2LDg3MkM3ODQsOTEzIDczNCw5MzQgNjY2LDkzNEM1NzUsOTM0IDUwOSw5MDUgNDY3LDg0NkM0MjQsNzg3IDQwMyw2ODggNDAzLDU1MWwwLC01NTFsLTIzNSwwbDAsMTEwNmwxODQsMGwzMywtMTQ1bDEyLDBDNDI4LDEwMTQgNDcyLDEwNTQgNTMxLDEwODNDNTg5LDExMTIgNjUzLDExMjYgNzIzLDExMjZDODkzLDExMjYgMTAwNiwxMDY4IDEwNjEsOTUybDE2LDBDMTExMCwxMDA3IDExNTYsMTA0OSAxMjE1LDEwODBDMTI3NCwxMTExIDEzNDIsMTEyNiAxNDE5LDExMjZDMTU1MSwxMTI2IDE2NDcsMTA5MyAxNzA4LDEwMjZDMTc2OCw5NTkgMTc5OCw4NTggMTc5OCw3MjFsMCwtNzIxbC0yMzUsMGwwLDY4MkMxNTYzLDc2NyAxNTQ3LDgzMCAxNTE1LDg3MkMxNDgyLDkxMyAxNDMyLDkzNCAxMzY0LDkzNEMxMjczLDkzNCAxMjA2LDkwNiAxMTY0LDg0OUMxMTIxLDc5MiAxMTAwLDcwNCAxMTAwLDU4NnpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJuXFxcIiBob3Jpei1hZHYteD1cXFwiMTMwMFxcXCIgZD1cXFwiTTExNDEsMGwtMjM2LDBsMCw2ODBDOTA1LDc2NSA4ODgsODI5IDg1NCw4NzFDODE5LDkxMyA3NjUsOTM0IDY5MCw5MzRDNTkxLDkzNCA1MTgsOTA1IDQ3Miw4NDZDNDI2LDc4NyA0MDMsNjg5IDQwMyw1NTFsMCwtNTUxbC0yMzUsMGwwLDExMDZsMTg0LDBsMzMsLTE0NWwxMiwwQzQzMCwxMDE0IDQ3OCwxMDU0IDUzOSwxMDgzQzYwMCwxMTEyIDY2OCwxMTI2IDc0MywxMTI2QzEwMDgsMTEyNiAxMTQxLDk5MSAxMTQxLDcyMXpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJvXFxcIiBob3Jpei1hZHYteD1cXFwiMTI1MVxcXCIgZD1cXFwiTTExNDksNTU1QzExNDksMzc0IDExMDMsMjMzIDEwMTAsMTMyQzkxNywzMSA3ODgsLTIwIDYyMywtMjBDNTIwLC0yMCA0MjgsMyAzNDksNTBDMjcwLDk3IDIwOSwxNjQgMTY2LDI1MUMxMjMsMzM4IDEwMiw0NDAgMTAyLDU1NUMxMDIsNzM0IDE0OCw4NzQgMjQwLDk3NUMzMzIsMTA3NiA0NjIsMTEyNiA2MjksMTEyNkM3ODksMTEyNiA5MTYsMTA3NSAxMDA5LDk3MkMxMTAyLDg2OSAxMTQ5LDczMCAxMTQ5LDU1NU0zNDQsNTU1QzM0NCwzMDAgNDM4LDE3MiA2MjcsMTcyQzgxNCwxNzIgOTA3LDMwMCA5MDcsNTU1QzkwNyw4MDggODEzLDkzNCA2MjUsOTM0QzUyNiw5MzQgNDU1LDkwMSA0MTEsODM2QzM2Niw3NzEgMzQ0LDY3NyAzNDQsNTU1elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcInBcXFwiIGhvcml6LWFkdi14PVxcXCIxMjc2XFxcIiBkPVxcXCJNNzI5LC0yMEM1ODksLTIwIDQ4MCwzMCA0MDMsMTMxbC0xNCwwQzM5OCwzOCA0MDMsLTE5IDQwMywtMzlsMCwtNDUzbC0yMzUsMGwwLDE1OThsMTkwLDBDMzYzLDEwODUgMzc0LDEwMzYgMzkxLDk1OGwxMiwwQzQ3NiwxMDcwIDU4NiwxMTI2IDczMywxMTI2Qzg3MSwxMTI2IDk3OSwxMDc2IDEwNTYsOTc2QzExMzMsODc2IDExNzEsNzM2IDExNzEsNTU1QzExNzEsMzc0IDExMzIsMjMzIDEwNTQsMTMyQzk3NSwzMSA4NjcsLTIwIDcyOSwtMjBNNjcyLDkzNEM1NzksOTM0IDUxMSw5MDcgNDY4LDg1MkM0MjUsNzk3IDQwMyw3MTAgNDAzLDU5MGwwLC0zNUM0MDMsNDIwIDQyNCwzMjMgNDY3LDI2M0M1MTAsMjAyIDU3OSwxNzIgNjc2LDE3MkM3NTcsMTcyIDgyMCwyMDUgODY0LDI3MkM5MDgsMzM5IDkzMCw0MzQgOTMwLDU1N0M5MzAsNjgxIDkwOCw3NzUgODY1LDgzOUM4MjEsOTAyIDc1Nyw5MzQgNjcyLDkzNHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJxXFxcIiBob3Jpei1hZHYteD1cXFwiMTI3NlxcXCIgZD1cXFwiTTYwNiwxNjhDNzA1LDE2OCA3NzYsMTk3IDgxOSwyNTRDODYyLDMxMSA4ODMsMzk3IDg4Myw1MTJsMCwzN0M4ODMsNjg2IDg2MSw3ODQgODE3LDg0NEM3NzIsOTA0IDcwMSw5MzQgNjAyLDkzNEM1MTgsOTM0IDQ1NCw5MDEgNDEwLDgzNEMzNjYsNzY3IDM0NCw2NzIgMzQ0LDU0N0MzNDQsMjk0IDQzMSwxNjggNjA2LDE2OE01MzksLTIwQzQwMiwtMjAgMjk1LDMwIDIxOCwxMzFDMTQxLDIzMSAxMDIsMzcxIDEwMiw1NTFDMTAyLDczMSAxNDEsODcyIDIyMCw5NzRDMjk5LDEwNzUgNDA3LDExMjYgNTQ1LDExMjZDNjE0LDExMjYgNjc3LDExMTMgNzMyLDEwODhDNzg3LDEwNjIgODM2LDEwMjAgODc5LDk2MWw4LDBsMjYsMTQ1bDE5NSwwbDAsLTE1OThsLTIzNiwwbDAsNDY5Qzg3Miw2IDg3MywzNyA4NzYsNzBDODc5LDEwMyA4ODEsMTI4IDg4MywxNDVsLTEzLDBDODAxLDM1IDY5MCwtMjAgNTM5LC0yMHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJyXFxcIiBob3Jpei1hZHYteD1cXFwiODgzXFxcIiBkPVxcXCJNNzI5LDExMjZDNzc2LDExMjYgODE1LDExMjMgODQ2LDExMTZsLTIzLC0yMTlDNzkwLDkwNSA3NTUsOTA5IDcxOSw5MDlDNjI1LDkwOSA1NDksODc4IDQ5MSw4MTdDNDMyLDc1NiA0MDMsNjc2IDQwMyw1NzhsMCwtNTc4bC0yMzUsMGwwLDExMDZsMTg0LDBsMzEsLTE5NWwxMiwwQzQzMiw5NzcgNDgwLDEwMjkgNTM5LDEwNjhDNTk4LDExMDcgNjYxLDExMjYgNzI5LDExMjZ6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwic1xcXCIgaG9yaXotYWR2LXg9XFxcIjk5N1xcXCIgZD1cXFwiTTkxMSwzMTVDOTExLDIwNyA4NzIsMTI0IDc5Myw2N0M3MTQsOSA2MDIsLTIwIDQ1NSwtMjBDMzA4LC0yMCAxODksMiAxMDAsNDdsMCwyMDNDMjMwLDE5MCAzNTEsMTYwIDQ2MywxNjBDNjA4LDE2MCA2ODAsMjA0IDY4MCwyOTFDNjgwLDMxOSA2NzIsMzQyIDY1NiwzNjFDNjQwLDM4MCA2MTQsMzk5IDU3Nyw0MTlDNTQwLDQzOSA0ODksNDYyIDQyNCw0ODdDMjk3LDUzNiAyMTEsNTg2IDE2Niw2MzVDMTIxLDY4NCA5OCw3NDggOTgsODI3Qzk4LDkyMiAxMzYsOTk1IDIxMywxMDQ4QzI4OSwxMTAwIDM5MywxMTI2IDUyNCwxMTI2QzY1NCwxMTI2IDc3NywxMTAwIDg5MywxMDQ3bC03NiwtMTc3QzY5OCw5MTkgNTk3LDk0NCA1MTYsOTQ0QzM5Miw5NDQgMzMwLDkwOSAzMzAsODM4QzMzMCw4MDMgMzQ2LDc3NCAzNzksNzUwQzQxMSw3MjYgNDgxLDY5MyA1OTAsNjUxQzY4MSw2MTYgNzQ4LDU4MyA3ODksNTU0QzgzMCw1MjUgODYxLDQ5MSA4ODEsNDUzQzkwMSw0MTQgOTExLDM2OCA5MTEsMzE1elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcInRcXFwiIGhvcml6LWFkdi14PVxcXCI4MDVcXFwiIGQ9XFxcIk01ODAsMTcwQzYzNywxNzAgNjk1LDE3OSA3NTIsMTk3bDAsLTE3N0M3MjYsOSA2OTMsLTEgNjUyLC04QzYxMSwtMTYgNTY4LC0yMCA1MjQsLTIwQzMwMSwtMjAgMTkwLDk3IDE5MCwzMzJsMCw1OTZsLTE1MSwwbDAsMTA0bDE2Miw4Nmw4MCwyMzRsMTQ1LDBsMCwtMjQ2bDMxNSwwbDAsLTE3OGwtMzE1LDBsMCwtNTkyQzQyNiwyNzkgNDQwLDIzOCA0NjksMjExQzQ5NywxODQgNTM0LDE3MCA1ODAsMTcwelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcInVcXFwiIGhvcml6LWFkdi14PVxcXCIxMzAwXFxcIiBkPVxcXCJNOTQ4LDBsLTMzLDE0NWwtMTIsMEM4NzAsOTQgODI0LDUzIDc2NCwyNEM3MDMsLTUgNjM0LC0yMCA1NTcsLTIwQzQyMywtMjAgMzIzLDEzIDI1Nyw4MEMxOTEsMTQ3IDE1OCwyNDggMTU4LDM4M2wwLDcyM2wyMzcsMGwwLC02ODJDMzk1LDMzOSA0MTIsMjc2IDQ0NywyMzRDNDgyLDE5MSA1MzYsMTcwIDYxMCwxNzBDNzA5LDE3MCA3ODEsMjAwIDgyOCwyNTlDODc0LDMxOCA4OTcsNDE2IDg5Nyw1NTVsMCw1NTFsMjM2LDBsMCwtMTEwNnpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJ2XFxcIiBob3Jpei1hZHYteD1cXFwiMTA5NlxcXCIgZD1cXFwiTTQyMCwwbC00MjAsMTEwNmwyNDgsMGwyMjUsLTY0M0M1MTIsMzU1IDUzNSwyNjggNTQzLDIwMWw4LDBDNTU3LDI0OSA1ODAsMzM2IDYyMSw0NjNsMjI1LDY0M2wyNTAsMGwtNDIyLC0xMTA2elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIndcXFwiIGhvcml6LWFkdi14PVxcXCIxNjczXFxcIiBkPVxcXCJNMTA3NSwwbC0xNDMsNTE2QzkxNSw1NzEgODgzLDY5OCA4MzgsODk3bC05LDBDNzkwLDcxNyA3NjAsNTg5IDczNyw1MTRsLTE0NywtNTE0bC0yNjAsMGwtMzEwLDExMDZsMjQwLDBsMTQxLC01NDVDNDMzLDQyNiA0NTYsMzExIDQ2OSwyMTVsNiwwQzQ4MiwyNjQgNDkyLDMyMCA1MDYsMzgzQzUxOSw0NDYgNTMxLDQ5MyA1NDEsNTI0bDE2OCw1ODJsMjU4LDBsMTYzLC01ODJDMTE0MCw0OTEgMTE1Myw0NDEgMTE2OCwzNzRDMTE4MywzMDcgMTE5MSwyNTQgMTE5NCwyMTdsOCwwQzEyMTIsMjk5IDEyMzUsNDE0IDEyNzIsNTYxbDE0Myw1NDVsMjM2LDBsLTMxMiwtMTEwNnpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJ4XFxcIiBob3Jpei1hZHYteD1cXFwiMTEyOFxcXCIgZD1cXFwiTTQxNCw1NjVsLTM3MSw1NDFsMjY4LDBsMjUyLC0zODdsMjU0LDM4N2wyNjYsMGwtMzcyLC01NDFsMzkxLC01NjVsLTI2NiwwbC0yNzMsNDE0bC0yNzIsLTQxNGwtMjY2LDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwieVxcXCIgaG9yaXotYWR2LXg9XFxcIjEwOThcXFwiIGQ9XFxcIk0wLDExMDZsMjU2LDBsMjI1LC02MjdDNTE1LDM5MCA1MzgsMzA2IDU0OSwyMjdsOCwwQzU2MywyNjQgNTc0LDMwOCA1OTAsMzYxQzYwNiw0MTMgNjkxLDY2MSA4NDQsMTEwNmwyNTQsMGwtNDczLC0xMjUzQzUzOSwtMzc3IDM5NiwtNDkyIDE5NSwtNDkyQzE0MywtNDkyIDkyLC00ODYgNDMsLTQ3NWwwLDE4NkM3OCwtMjk3IDExOSwtMzAxIDE2NCwtMzAxQzI3NywtMzAxIDM1NywtMjM1IDQwMywtMTA0bDQxLDEwNHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCJ6XFxcIiBob3Jpei1hZHYteD1cXFwiOTc5XFxcIiBkPVxcXCJNOTA3LDBsLTgzOSwwbDAsMTQ1bDU1OSw3ODFsLTUyNSwwbDAsMTgwbDc4OSwwbDAsLTE2NGwtNTQ3LC03NjJsNTYzLDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiflxcXCIgaG9yaXotYWR2LXg9XFxcIjExNjlcXFwiIGQ9XFxcIk0zMzAsNjkyQzI5Nyw2OTIgMjYwLDY4MiAyMTksNjYyQzE3OCw2NDIgMTM3LDYxMiA5Niw1NzFsMCwxOTFDMTYyLDgzNCAyNDUsODcwIDM0Niw4NzBDMzkwLDg3MCA0MzIsODY2IDQ3MSw4NTdDNTEwLDg0OCA1NTksODMyIDYxOCw4MDdDNzA1LDc3MCA3NzksNzUyIDgzOCw3NTJDODczLDc1MiA5MTEsNzYyIDk1Myw3ODNDOTk0LDgwNCAxMDM0LDgzMyAxMDczLDg3MmwwLC0xOTBDMTAwMyw2MDggOTIwLDU3MSA4MjMsNTcxQzc4MCw1NzEgNzM3LDU3NiA2OTYsNTg3QzY1NCw1OTcgNjA1LDYxNCA1NDksNjM3QzQ2NCw2NzQgMzkxLDY5MiAzMzAsNjkyelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIiYjeEEwO1xcXCIgaG9yaXotYWR2LXg9XFxcIjUzMlxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIiYjeEEzO1xcXCIgaG9yaXotYWR2LXg9XFxcIjExNjlcXFwiIGQ9XFxcIk02OTAsMTQ4MUM4MTksMTQ4MSA5NDQsMTQ1NCAxMDY1LDEzOTlsLTc2LC0xODJDODgxLDEyNjQgNzg2LDEyODggNzA1LDEyODhDNTY4LDEyODggNTAwLDEyMTUgNTAwLDEwNjlsMCwtMjQ0bDM5NywwbDAsLTE3MmwtMzk3LDBsMCwtMTgyQzUwMCw0MTAgNDg5LDM1OSA0NjcsMzE2QzQ0NSwyNzMgNDA3LDIzNyAzNTQsMjA3bDc1NiwwbDAsLTIwN2wtMTAzOCwwbDAsMTk1QzEzNywyMTUgMTg2LDI0NyAyMTcsMjkxQzI0OCwzMzUgMjY0LDM5NCAyNjQsNDY5bDAsMTg0bC0xODgsMGwwLDE3MmwxODgsMGwwLDI1NkMyNjQsMTIwNiAzMDIsMTMwNCAzNzgsMTM3NUM0NTMsMTQ0NiA1NTcsMTQ4MSA2OTAsMTQ4MXpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCImI3hBOTtcXFwiIGhvcml6LWFkdi14PVxcXCIxNzA0XFxcIiBkPVxcXCJNODkzLDEwMzRDODE5LDEwMzQgNzYyLDEwMDcgNzIyLDk1NEM2ODIsOTAwIDY2Miw4MjYgNjYyLDczMUM2NjIsNjMzIDY4MCw1NTggNzE2LDUwNUM3NTIsNDUyIDgxMSw0MjYgODkzLDQyNkM5MzAsNDI2IDk2OSw0MzEgMTAxMSw0NDFDMTA1Myw0NTEgMTA4OSw0NjMgMTEyMCw0NzdsMCwtMTU4QzEwNDMsMjg1IDk2NSwyNjggODg1LDI2OEM3NTQsMjY4IDY1MiwzMDggNTgwLDM4OUM1MDcsNDY5IDQ3MSw1ODMgNDcxLDczMUM0NzEsODc0IDUwOCw5ODYgNTgxLDEwNjlDNjU0LDExNTEgNzU2LDExOTIgODg3LDExOTJDOTc5LDExOTIgMTA3MCwxMTY5IDExNjEsMTEyMmwtNjUsLTE0M0MxMDI1LDEwMTYgOTU4LDEwMzQgODkzLDEwMzRNMTAwLDczMUMxMDAsODY0IDEzMyw5ODkgMjAwLDExMDZDMjY3LDEyMjMgMzU4LDEzMTUgNDc1LDEzODJDNTkyLDE0NDkgNzE3LDE0ODMgODUyLDE0ODNDOTg1LDE0ODMgMTExMCwxNDUwIDEyMjcsMTM4M0MxMzQ0LDEzMTYgMTQzNiwxMjI1IDE1MDMsMTEwOEMxNTcwLDk5MSAxNjA0LDg2NiAxNjA0LDczMUMxNjA0LDYwMCAxNTcyLDQ3NiAxNTA3LDM2MUMxNDQyLDI0NiAxMzUyLDE1MyAxMjM1LDg0QzExMTgsMTUgOTkxLC0yMCA4NTIsLTIwQzcxNCwtMjAgNTg3LDE1IDQ3MCw4NEMzNTMsMTUzIDI2MywyNDUgMTk4LDM2MEMxMzMsNDc1IDEwMCw1OTkgMTAwLDczMU0yMjMsNzMxQzIyMyw2MTggMjUxLDUxMyAzMDgsNDE2QzM2NCwzMTkgNDQxLDI0MiA1MzgsMTg2QzYzNSwxMzAgNzQwLDEwMiA4NTIsMTAyQzk2NSwxMDIgMTA3MSwxMzEgMTE2OCwxODhDMTI2NSwyNDUgMTM0MiwzMjEgMTM5OCw0MThDMTQ1Myw1MTQgMTQ4MSw2MTggMTQ4MSw3MzFDMTQ4MSw4NDMgMTQ1Myw5NDggMTM5NywxMDQ2QzEzNDAsMTE0MyAxMjYzLDEyMjAgMTE2NiwxMjc2QzEwNjgsMTMzMiA5NjMsMTM2MCA4NTIsMTM2MEM3NDAsMTM2MCA2MzYsMTMzMiA1NDAsMTI3N0M0NDMsMTIyMiAzNjYsMTE0NSAzMDksMTA0OEMyNTIsOTUxIDIyMyw4NDUgMjIzLDczMXpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCImI3hBRDtcXFwiIGhvcml6LWFkdi14PVxcXCI2NTlcXFwiIGQ9XFxcIk03Miw0NDlsMCwyMDBsNTE0LDBsMCwtMjAwelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIiYjeEFFO1xcXCIgaG9yaXotYWR2LXg9XFxcIjE3MDRcXFwiIGQ9XFxcIk03NDgsNzcwbDY5LDBDODY2LDc3MCA5MDQsNzgyIDkyOSw4MDVDOTU0LDgyOCA5NjcsODYyIDk2Nyw5MDVDOTY3LDk1MyA5NTUsOTg3IDkzMSwxMDA2QzkwNiwxMDI1IDg2OCwxMDM0IDgxNSwxMDM0bC02NywwTTExNTcsOTA5QzExNTcsNzk1IDExMDYsNzE3IDEwMDQsNjc2bDIzNywtMzk3bC0yMTEsMGwtMTkyLDM0NmwtOTAsMGwwLC0zNDZsLTE4OSwwbDAsOTAzbDI2MiwwQzkzNywxMTgyIDEwMjIsMTE1OSAxMDc2LDExMTRDMTEzMCwxMDY5IDExNTcsMTAwMCAxMTU3LDkwOU0xMDAsNzMxQzEwMCw4NjQgMTMzLDk4OSAyMDAsMTEwNkMyNjcsMTIyMyAzNTgsMTMxNSA0NzUsMTM4MkM1OTIsMTQ0OSA3MTcsMTQ4MyA4NTIsMTQ4M0M5ODUsMTQ4MyAxMTEwLDE0NTAgMTIyNywxMzgzQzEzNDQsMTMxNiAxNDM2LDEyMjUgMTUwMywxMTA4QzE1NzAsOTkxIDE2MDQsODY2IDE2MDQsNzMxQzE2MDQsNjAwIDE1NzIsNDc2IDE1MDcsMzYxQzE0NDIsMjQ2IDEzNTIsMTUzIDEyMzUsODRDMTExOCwxNSA5OTEsLTIwIDg1MiwtMjBDNzE0LC0yMCA1ODcsMTUgNDcwLDg0QzM1MywxNTMgMjYzLDI0NSAxOTgsMzYwQzEzMyw0NzUgMTAwLDU5OSAxMDAsNzMxTTIyMyw3MzFDMjIzLDYxOCAyNTEsNTEzIDMwOCw0MTZDMzY0LDMxOSA0NDEsMjQyIDUzOCwxODZDNjM1LDEzMCA3NDAsMTAyIDg1MiwxMDJDOTY1LDEwMiAxMDcxLDEzMSAxMTY4LDE4OEMxMjY1LDI0NSAxMzQyLDMyMSAxMzk4LDQxOEMxNDUzLDUxNCAxNDgxLDYxOCAxNDgxLDczMUMxNDgxLDg0MyAxNDUzLDk0OCAxMzk3LDEwNDZDMTM0MCwxMTQzIDEyNjMsMTIyMCAxMTY2LDEyNzZDMTA2OCwxMzMyIDk2MywxMzYwIDg1MiwxMzYwQzc0MCwxMzYwIDYzNiwxMzMyIDU0MCwxMjc3QzQ0MywxMjIyIDM2NiwxMTQ1IDMwOSwxMDQ4QzI1Miw5NTEgMjIzLDg0NSAyMjMsNzMxelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIiYjeDIwMTg7XFxcIiBob3Jpei1hZHYteD1cXFwiMzk1XFxcIiBkPVxcXCJNMzcsOTYxbC0xMiwyMkMzOCwxMDM4IDYyLDExMTMgOTYsMTIwN0MxMzAsMTMwMSAxNjUsMTM4NiAyMDEsMTQ2MmwxNzAsMEMzMjgsMTI5MSAyOTUsMTEyNCAyNzAsOTYxelxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIiYjeDIwMTk7XFxcIiBob3Jpei1hZHYteD1cXFwiMzk1XFxcIiBkPVxcXCJNMzU2LDE0NjJsMTUsLTIyQzMzNiwxMzAxIDI3NywxMTQxIDE5NSw5NjFsLTE3MCwwQzcxLDExNTQgMTA0LDEzMjEgMTI1LDE0NjJ6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiJiN4MjAxQztcXFwiIGhvcml6LWFkdi14PVxcXCI4MTNcXFwiIGQ9XFxcIk00NDAsOTgzQzQ3NSwxMTE4IDUzNSwxMjc4IDYxOCwxNDYybDE3MCwwQzc0MiwxMjY1IDcwOSwxMDk4IDY4OCw5NjFsLTIzMywwTTI1LDk4M0MzOCwxMDM4IDYyLDExMTMgOTYsMTIwN0MxMzAsMTMwMSAxNjUsMTM4NiAyMDEsMTQ2MmwxNzAsMEMzMjgsMTI5MSAyOTUsMTEyNCAyNzAsOTYxbC0yMzMsMHpcXFwiLz5cXG4gIDxnbHlwaCB1bmljb2RlPVxcXCImI3gyMDFEO1xcXCIgaG9yaXotYWR2LXg9XFxcIjgxM1xcXCIgZD1cXFwiTTM3MSwxNDQwQzMzNiwxMzAxIDI3NywxMTQxIDE5NSw5NjFsLTE3MCwwQzcxLDExNTQgMTA0LDEzMjEgMTI1LDE0NjJsMjMxLDBNNzg4LDE0NDBDNzUzLDEzMDEgNjk0LDExNDEgNjEyLDk2MWwtMTcyLDBDNDg2LDExNDIgNTIwLDEzMDkgNTQzLDE0NjJsMjMxLDB6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiJiN4MjAyMjtcXFwiIGhvcml6LWFkdi14PVxcXCI3NzBcXFwiIGQ9XFxcIk0xMzEsNzQ4QzEzMSw4NDAgMTUzLDkxMCAxOTcsOTU4QzI0MSwxMDA2IDMwNCwxMDMwIDM4NSwxMDMwQzQ2NiwxMDMwIDUyOCwxMDA2IDU3Myw5NThDNjE3LDkwOSA2MzksODM5IDYzOSw3NDhDNjM5LDY1OCA2MTcsNTg4IDU3Miw1MzlDNTI3LDQ5MCA0NjUsNDY1IDM4NSw0NjVDMzA1LDQ2NSAyNDMsNDg5IDE5OCw1MzhDMTUzLDU4NiAxMzEsNjU2IDEzMSw3NDh6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiJiN4MjBBQztcXFwiIGhvcml6LWFkdi14PVxcXCIxMTg4XFxcIiBkPVxcXCJNNzk5LDEyNzhDNzA1LDEyNzggNjI4LDEyNTAgNTY5LDExOTRDNTA5LDExMzggNDY5LDEwNTMgNDQ5LDk0MGw0NTYsMGwwLC0xNTRsLTQ3MSwwbC0yLC00NWwwLC01NWwyLC0zOWw0MDgsMGwwLC0xNTNsLTM5MSwwQzQ5NCwyODYgNjE1LDE4MiA4MTUsMTgyQzkxMCwxODIgMTAwOCwyMDMgMTEwOCwyNDRsMCwtMjAzQzEwMjEsMCA5MTksLTIwIDgwMywtMjBDNjQyLC0yMCA1MTIsMjQgNDEyLDExMkMzMTEsMjAwIDI0NiwzMjcgMjE1LDQ5NGwtMTUyLDBsMCwxNTNsMTM2LDBsLTIsMzdsMCwzN2wyLDY1bC0xMzYsMGwwLDE1NGwxNTAsMEMyMzgsMTEwNyAzMDIsMTIzOSA0MDQsMTMzNEM1MDYsMTQyOSA2MzgsMTQ3NyA3OTksMTQ3N0M5MzIsMTQ3NyAxMDUyLDE0NDggMTE1NywxMzg5bC04NCwtMTg3Qzk3MCwxMjUzIDg3OSwxMjc4IDc5OSwxMjc4elxcXCIvPlxcbiAgPGdseXBoIHVuaWNvZGU9XFxcIiYjeDIxMjI7XFxcIiBob3Jpei1hZHYteD1cXFwiMTU2MVxcXCIgZD1cXFwiTTM3NSw3NDFsLTE0NiwwbDAsNTkybC0yMDIsMGwwLDEyOWw1NTMsMGwwLC0xMjlsLTIwNSwwTTk2Myw3NDFsLTE4NSw1NDNsLTYsMGw0LC0xMTlsMCwtNDI0bC0xNDEsMGwwLDcyMWwyMTcsMGwxNzgsLTUzNGwxODcsNTM0bDIxMCwwbDAsLTcyMWwtMTQ3LDBsMCw0MTRsNCwxMjlsLTYsMGwtMTkzLC01NDN6XFxcIi8+XFxuICA8Z2x5cGggdW5pY29kZT1cXFwiSVxcXCIgaG9yaXotYWR2LXg9XFxcIjYyNVxcXCIgZD1cXFwiTTE5MywwbDAsMTQ2MmwyMzksMGwwLC0xNDYyelxcXCIvPlxcbiA8L2ZvbnQ+XFxuXCIpXG4gIC8vIGRpYWdyYW0udG9fZGVmcyhmcy5yZWFkRmlsZVN5bmMoJy4uL3Jlc291cmNlcy9iYWNrZ3JvdW5kLnN2ZycpKVxuICBkaWFncmFtLnRvX2RlZnMoXCI8ZyBjbGFzcz1cXFwiRkNIQm94XFxcIj5cXG4gIDxnPlxcbiAgICA8cGF0aCBmaWxsPVxcXCIjRkZGRkZGXFxcIiBkPVxcXCJtMTYwIDUwYzAgMSAtMSAzIC0yIDNoLTE1NWMtMSAwIC0yIC0xIC0yIC0ydi00NWMwIC0xIDEgLTIgMyAtMmgxNTVjMSAwIDMgMSAzIDN2NDV6XFxcIi8+XFxuICAgIDxwYXRoIGZpbGw9XFxcIiNBQUIyQkRcXFwiIGQ9XFxcIm0xNjAgMHY1MGgtMTU1di00NWgxNTVtMCAtNWgtMTU1Yy0zIDAgLTUgMiAtNSA1djQ1YzAgMyAyIDUgNSA1aDE1NWMzIDAgNSAtMiA1IC01di00NWMwIC0zIC0yIC01IC01IC01bDAgMHpcXFwiLz5cXG4gIDwvZz5cXG4gIDxyZWN0IGNsYXNzPVxcXCJGQ0hCb3gtVGV4dC1iZ1xcXCIgIGZpbGw9XFxcIm5vbmVcXFwiIHdpZHRoPVxcXCIxMzVcXFwiIGhlaWdodD1cXFwiMzIuN1xcXCIvPlxcbiAgPGcgY2xhc3M9XFxcIkZDSEJveC1UZXh0XFxcIj5cXG4gICAgPHRleHQgY2xhc3M9XFxcIkZDSEJveC1UZXh0LXRpdGxlXFxcIiB4PVxcXCIxNVxcXCIgeT1cXFwiMjFcXFwiIGZpbGw9XFxcIiNBQUIyQkRcXFwiIGZvbnQtZmFtaWx5PVxcXCInT3BlblNhbnMtU2VtaWJvbGQnXFxcIiBmb250LXNpemU9XFxcIjE0XFxcIj5BY3Rpb24gVGl0bGU8L3RleHQ+XFxuICAgIDx0ZXh0IGNsYXNzPVxcXCJGQ0hCb3gtVGV4dC10eXBlXFxcIiB4PVxcXCIxNVxcXCIgeT1cXFwiNDJcXFwiIGZpbGw9XFxcIiNBQUIyQkRcXFwiIGZvbnQtZmFtaWx5PVxcXCInT3BlblNhbnMtU2VtaWJvbGQnXFxcIiBmb250LXNpemU9XFxcIjE0XFxcIj5UeXBlOiBOb3JtYWw8L3RleHQ+XFxuICA8L2c+XFxuPC9nPlxcblwiKVxuICBkaWFncmFtLnRvX2RlZnMoXCI8cGF0dGVybiBpZD1cXFwiZmhjLWxpbmUtcGF0dGVyblxcXCIgcGF0dGVybkNvbnRlbnRVbml0cz1cXFwib2JqZWN0Qm91bmRpbmdCb3hcXFwiIGNsYXNzPVxcXCJGQ0hMaW5lLXBhdHRlcm5cXFwiPlxcbiAgPGNpcmNsZSBmaWxsPVxcXCIjQUFCMkJEXFxcIiByPVxcXCIyLjVcXFwiLz5cXG48L3BhdHRlcm4+XFxuXCIpXG4gIGRpYWdyYW0udG9fZGVmcyhcIjxnIGNsYXNzPVxcXCJGQ0hMaW5lLWFycm93XFxcIj5cXG4gIDxtYXJrZXIgaWQ9XFxcImZjaC1lbmRhcnJvd1xcXCIgb3ZlcmZsb3c9XFxcInZpc2libGVcXFwiIG9yaWVudD1cXFwiYXV0b1xcXCIgPlxcbiAgIDxwb2x5Z29uIHBvaW50cz1cXFwiLTUsLTUgMCwwIC01LDVcXFwiIGZpbGw9XFxcIiNBQUIyQkRcXFwiLz5cXG4gIDwvbWFya2VyPlxcbjwvZz5cXG5cIilcbiAgZGlhZ3JhbS50b19kZWZzKFwiPGcgY2xhc3M9XFxcIkZDSExpbmUtaW50ZXJzZWN0aW9uIEVkZ2UtaW50ZXJzZWN0aW9uXFxcIj5cXG4gIDwhLS1yZWN0IHg9XFxcIjE4XFxcIiB5PVxcXCIxN1xcXCIgd2lkdGg9XFxcIjlcXFwiIGhlaWdodD1cXFwiMTFcXFwiIC8+XFxuICA8bGluZSB4MT1cXFwiNDVcXFwiIHkxPVxcXCIyOFxcXCIgeDI9XFxcIjMwXFxcIiB5Mj1cXFwiMjhcXFwiLz5cXG4gIDxsaW5lIHgxPVxcXCIzMFxcXCIgeTE9XFxcIjE3XFxcIiB4Mj1cXFwiNDVcXFwiIHkyPVxcXCIxN1xcXCIvPlxcbiAgPGxpbmUgeDE9XFxcIjE1XFxcIiB5MT1cXFwiMjhcXFwiICAgICAgICAgeTI9XFxcIjI4XFxcIiAvPlxcbiAgPGxpbmUgICAgICAgICB5MT1cXFwiMTdcXFwiIHgyPVxcXCIxNVxcXCIgeTI9XFxcIjE3XFxcIi8+XFxuICA8bGluZSB4MT1cXFwiMTdcXFwiIHkxPVxcXCI0NVxcXCIgeDI9XFxcIjE3XFxcIi8+XFxuICA8bGluZSB4MT1cXFwiMjhcXFwiIHgyPVxcXCIyOFxcXCIgeTI9XFxcIjQ1XFxcIi8tLT5cXG48cmVjdCB4PVxcXCIxMlxcXCIgeT1cXFwiMTBcXFwiIHdpZHRoPVxcXCIxMFxcXCIgaGVpZ2h0PVxcXCIxM1xcXCIvPlxcbjxsaW5lIHgxPVxcXCIzNFxcXCIgeTE9XFxcIjIzXFxcIiB4Mj1cXFwiMjNcXFwiIHkyPVxcXCIyM1xcXCIgLz5cXG5cXG48bGluZSB4MT1cXFwiMjNcXFwiIHkxPVxcXCIxMVxcXCIgeDI9XFxcIjM0XFxcIiB5Mj1cXFwiMTFcXFwiIC8+XFxuPGxpbmUgeDE9XFxcIjExXFxcIiB5MT1cXFwiMjNcXFwiICAgICAgICAgeTI9XFxcIjIzXFxcIiAvPlxcbjxsaW5lICAgICAgICAgeTE9XFxcIjExXFxcIiB4Mj1cXFwiMTFcXFwiIHkyPVxcXCIxMVxcXCIgLz5cXG48bGluZSB4MT1cXFwiMTFcXFwiIHkxPVxcXCIzNFxcXCIgICB4Mj1cXFwiMTFcXFwiICAgICAgICAgLz5cXG48bGluZSB4MT1cXFwiMjNcXFwiICAgICAgICAgICB4Mj1cXFwiMjNcXFwiIHkyPVxcXCIzNFxcXCIgLz5cXG5cXG5cXG48L2c+XFxuXCIpXG4gIGRpYWdyYW0udG9fZGVmcyhcIjxnIGNsYXNzPVxcXCJGQ0hMaW5lXFxcIj5cXG4gIDxsaW5lIGNsYXNzPVxcXCJGQ0hMaW5lLWRvdHMgRWRnZVxcXCIgLz5cXG48L2c+XFxuXCIpXG4gIGRpYWdyYW0udG9fZGVmcyhcIjxnIGNsYXNzPVxcXCJGQ0hMaW5lLXdpdGhhcnJvd1xcXCI+XFxuICA8bGluZSBjbGFzcz1cXFwiRkNITGluZS1kb3RzIEVkZ2VcXFwiIC8+XFxuICA8bGluZSBjbGFzcz1cXFwiRkNITGluZS1lbmRhcnJvdyBFZGdlLS1lbmRcXFwiIC8+XFxuPC9nPlxcblwiKVxuICBkaWFncmFtLmRpc3BsYXkoKVxuXG5cbn0oKVxuIiwidm9pZCBmdW5jdGlvbigpe1xuICBcInVzZSBzdHJpY3RcIlxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKG9iaikge1xuICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkuZm9yRWFjaChmdW5jdGlvbihzb3VyY2Upe1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKG9ialtwcm9wXSA9PT0gdW5kZWZpbmVkKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF1cbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBvYmpcbiAgfVxufSgpXG4iLCJ2b2lkIGZ1bmN0aW9uKCl7XG5cbiAgZnVuY3Rpb24gcXVlcnkoc2VsZWN0b3IsIHBhcmVudCl7XG4gICAgcGFyZW50ID0gcGFyZW50IHx8IGRvY3VtZW50XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlKHRhZ19uYW1lLCBhdHRycyl7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ19uYW1lKVxuICAgIGlmICggYXR0cnMgKSB7IHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKSB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGUobm9kZSwgYXR0cil7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSx2YWx1ZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKXtcbiAgICBPYmplY3Qua2V5cyhhdHRycylcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKVxuICAgICAgICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRfdGV4dChub2RlKXtcbiAgICByZXR1cm4gbm9kZS50ZXh0Q29udGVudCB8fCBub2RlLmlubmVyVGV4dFxuICB9XG5cbiAgZnVuY3Rpb24gc2V0X3RleHQobm9kZSwgdGV4dCl7XG4gICAgbm9kZS50ZXh0Q29udGVudCA9IG5vZGUuaW5uZXJUZXh0ID0gdGV4dFxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIocGFyZW50RWwsIHNwMSwgc3AyKXtcbiAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUoc3AxLCBzcDIubmV4dFNpYmxpbmcpXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpe1xuICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKVxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJCAgICAgICAgICAgICA6IHF1ZXJ5XG4gIC8vLCAkaWQgICAgICAgICAgIDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQuYmluZChkb2N1bWVudClcbiAgLCAkaWQgICAgICAgICAgIDogZnVuY3Rpb24oaWQpeyByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIH1cbiAgLCBjcmVhdGUgICAgICAgIDogY3JlYXRlXG4gICwgYXR0ciAgICAgICAgICA6IHNldF9hdHRyaWJ1dGVcbiAgLCBhdHRycyAgICAgICAgIDogc2V0X2F0dHJpYnV0ZXNcbiAgLCBnZXRfdGV4dCAgICAgIDogZ2V0X3RleHRcbiAgLCBzZXRfdGV4dCAgICAgIDogc2V0X3RleHRcbiAgLCByZW1vdmUgICAgICAgIDogcmVtb3ZlTm9kZVxuICAsIGluc2VydEFmdGVyICAgOiBpbnNlcnRBZnRlclxuICB9XG5cbn0oKVxuIiwidm9pZCBmdW5jdGlvbigpe1xuICB2YXIgaWRzID0gW11cbiAgdmFyIHJ0ID0gcmVxdWlyZSgncmFuZG9tLXRva2VuJylcbiAgdmFyIGxldHRlcnMgPSBydC5nZW4oJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl0JylcblxuICBmdW5jdGlvbiB0b2tlbigpeyByZXR1cm4gbGV0dGVycygxKSArIHJ0KDE2KSB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBpZCA9IHRva2VuKClcbiAgICB3aGlsZSAoIGlkcy5pbmRleE9mKGlkKSAhPSAtMSApe1xuICAgICAgaWQgPSB0b2tlbigpXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG59KClcbiIsbnVsbCwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIl19
