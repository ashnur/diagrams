
/*
  function text_in_node(item){
    var label = item.input.label
    var g = item.g
    // create node if not present
    var text_el = g.select('.Item-text')
    // set text of node
    if ( ! text_el ) {
      text_el = replace_text(item, [item.input.label.trim()])
    } else {
      //dom.set_text(text_el, [label.trim()])
      replace_text(item, [label.trim()])
    }

    var font_size = item.input.font_size
    var line_height = item.input.line_height
    var font_line_ratio = font_size / line_height
    var item_width = item.value.width
    var item_height = item.value.height
    var box_ratio = item_width / item_height

    // add history of text replacements for vertical scale
    item.text_history = []
    var i = 0

    // calculate width
    // break it up if too long and try to fit it
    while ( true ) {
      var text_node = text_el.node
      var text_width = (width = text_node.getBoundingClientRect().width)
      var width_ratio = text_width / item_width
      var text_height = i && item.text_history[item.text_history.length - 1].length * line_height
      var height_ratio = text_height / item_height
      var text_ratio = text_width / text_height
      var lines = g.selectAll('tspan').items
      item.text_history.push(lines)
      var widest = lines.reduce(function(widest, next){
        return get_textwidth(widest.node) <  get_textwidth(next.node) ? next : widest
      })
      var label = dom.get_text(widest.node)
      var spaces = label.match(/ /g)
      var space_count = spaces && spaces.length || 0


      // when it fits, or we already know it wont fit, give up
      if ( i ++ > 100 || (width_ratio <= 1 && height_ratio <= 1) || space_count == 0 ) break

      if ( width_ratio > 1 ) {

        var cut = min(ceil(space_count / 2), space_count)
        var pattern = RegExp('^((?:[^\\s]+\\s?){' + cut + '})((?:[^\\s]+\\s?)+)$')
        var matches = pattern.exec(label)
        if ( matches ) {
          text_el = replace_text(item, lines.reduce(function(wrapped_lines, line){
            if ( widest != line ) {
              var n = dom.get_text(line.node)
              if ( n ) wrapped_lines.push(n)
            } else {
              if ( matches[1] ) wrapped_lines.push(matches[1].trim())
              if ( matches[2] ) wrapped_lines.push(matches[2].trim())
            }
            return wrapped_lines
          }, []))
        }
      }

      if ( height_ratio > 1 ) {
        font_size = item.input.font_size = font_size - 1
        line_height = item.input.line_height = floor(font_size / font_line_ratio)
        var pos = pos_calc(item.value.x, item.value.width, item.value.y, item.value.height)
        var top = max(pos[1] - line_height + font_size, item.value.y)
        var el =  text_el.attr({ y: (text_height + line_height) < item.value.height ? top : item.value.y + line_height
                               , 'text-anchor': 'middle', class: 'Item-text', 'font-size': font_size})
        set_line_attrs(item, line_height, pos[0])
      }

    }
  }
*/
/*
  function replace_text(item, arr){
    var g = item.g
    var font_size = item.input.font_size
    var line_height = item.input.line_height
    var tnode = g.select('text')
    var dim = tnode && tnode.getBBox()
    g.selectAll('text').forEach(function(t){ t.remove() })
    var pos = pos_calc(item.value.x, item.value.width, item.value.y, item.value.height)
    var top = max(pos[1] - line_height + font_size, item.value.y)
    var el =  g.text(pos[0], dim ? (dim.height + line_height) < item.value.height ? top : item.value.y + font_size : top - font_size + line_height, arr)
               .attr({ 'text-anchor': 'middle', class: 'Item-text', 'font-size': font_size })
    set_line_attrs(item, line_height, pos[0])
    return el
  }
*/
/*
  function draw_connection(item){
    var g = item.g
    var line = g.paper(item.value.x, item.value.y, item.value.width, item.value.height)
                    .attr({fill: '#fff', stroke: '#000', class: 'Item'})

    // item.edges.push(line)
    // add head (then maybe tail)
  }
*/
